Python 3.7.8
Module(body=[Expr(value=Str(s='The Maximum Likelihood Amplitude Estimation algorithm.')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Union', asname=None), alias(name='Tuple', asname=None), alias(name='Dict', asname=None), alias(name='Callable', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='scipy.optimize', names=[alias(name='brute', asname=None)], level=0), ImportFrom(module='scipy.stats', names=[alias(name='norm', asname=None), alias(name='chi2', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='amplitude_estimator', names=[alias(name='AmplitudeEstimator', asname=None), alias(name='AmplitudeEstimatorResult', asname=None)], level=1), ImportFrom(module='estimation_problem', names=[alias(name='EstimationProblem', asname=None)], level=1), ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2), Assign(targets=[Name(id='MINIMIZER', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ClassDef(name='MaximumLikelihoodAmplitudeEstimation', bases=[Name(id='AmplitudeEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Maximum Likelihood Amplitude Estimation algorithm.\n\n    This class implements the quantum amplitude estimation (QAE) algorithm without phase\n    estimation, as introduced in [1]. In comparison to the original QAE algorithm [2],\n    this implementation relies solely on different powers of the Grover operator and does not\n    require additional evaluation qubits.\n    Finally, the estimate is determined via a maximum likelihood estimation, which is why this\n    class in named ``MaximumLikelihoodAmplitudeEstimation``.\n\n    References:\n        [1]: Suzuki, Y., Uno, S., Raymond, R., Tanaka, T., Onodera, T., & Yamamoto, N. (2019).\n             Amplitude Estimation without Phase Estimation.\n             `arXiv:1904.10246 <https://arxiv.org/abs/1904.10246>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='minimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n                element must be non-negative. If a non-negative integer, an exponential schedule is\n                used where the highest power is 2 to the integer minus 1:\n                `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n            minimizer: A minimizer used to find the minimum of the likelihood function.\n                Defaults to a brute search where the number of evaluation points is determined\n                according to ``evaluation_schedule``. The minimizer takes a function as first\n                argument and a list of (float, float) tuples (as bounds) as second argument and\n                returns a single float which is the found minimum.\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            ValueError: If the number of oracle circuits is smaller than 1.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])))], orelse=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))]), If(test=Compare(left=Name(id='minimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), FunctionDef(name='default_minimizer', args=arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='default_minimizer', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='minimizer', ctx=Load()))])], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='construct_circuits', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the Amplitude Estimation w/o QPE quantum circuits.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\n        Returns:\n            A list with the QuantumCircuit objects for the algorithm.\n        ')), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='num_qubits', ctx=Load()), Str(s='q')], keywords=[])), Assign(targets=[Name(id='qc_0', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='qc_a'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), For(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), body=[Assign(targets=[Name(id='qc_k', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Name(id='circuits', ctx=Store()), op=Add(), value=List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='compute_confidence_interval', args=arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='kind', annotation=Name(id='str', ctx=Load())), arg(arg='apply_post_processing', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='fisher'), NameConstant(value=False)]), body=[Expr(value=Str(s="Compute the `alpha` confidence interval using the method `kind`.\n\n        The confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n        'likelihood_ratio' and 'observed_fisher' with shorthand\n        notations 'fi', 'lr' and 'oi', respectively.\n\n        Args:\n            result: A maximum likelihood amplitude estimation result.\n            alpha: The confidence level.\n            kind: The method to compute the confidence interval. Defaults to 'fisher', which\n                computes the theoretical Fisher information.\n            apply_post_processing: If True, apply post-processing to the confidence interval.\n\n        Returns:\n            The specified confidence interval.\n\n        Raises:\n            AlgorithmError: If `run()` hasn't been called yet.\n            NotImplementedError: If the method `kind` is not supported.\n        ")), Assign(targets=[Name(id='interval', ctx=Store())], value=NameConstant(value=None)), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])])]), If(test=Compare(left=Name(id='interval', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[]), cause=None)], orelse=[]), If(test=Name(id='apply_post_processing', ctx=Load()), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), Return(value=Name(id='interval', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='compute_mle', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='circuit_results', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='return_counts', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the MLE via a grid-search.\n\n        This is a stable approach if sufficient gridpoints are used.\n\n        Args:\n            circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n            estimation_problem: The estimation problem containing the evaluation schedule and the\n                number of likelihood function evaluations used to find the minimum.\n            num_state_qubits: The number of state qubits, required for statevector simulations.\n            return_counts: If True, returns the good counts.\n\n        Returns:\n            The MLE for the provided result object.\n        ')), Assign(targets=[Tuple(elts=[Name(id='good_counts', ctx=Store()), Name(id='all_counts', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_get_counts', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15)), Assign(targets=[Name(id='search_range', ctx=Store())], value=List(elts=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))], ctx=Load())), FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load())))], decorator_list=[], returns=None), Assign(targets=[Name(id='est_theta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()), args=[Name(id='loglikelihood', ctx=Load()), List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='return_counts', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='est_theta', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='minimizer', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevectors', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='statevectors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))]), Assign(targets=[Name(id='num_state_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='theta', ctx=Store()), Name(id='good_counts', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load()), NameConstant(value=True)], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Store())], value=Name(id='good_counts', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load()), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='alpha', value=Num(n=0.05)), keyword(arg='kind', value=Str(s='fisher'))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='MaximumLikelihoodAmplitudeEstimationResult'))], decorator_list=[]), ClassDef(name='MaximumLikelihoodAmplitudeEstimationResult', bases=[Name(id='AmplitudeEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The ``MaximumLikelihoodAmplitudeEstimation`` result object.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimate for the angle :math:`\\theta`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimate for the angle :math:`\\theta`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the minimizer used for the search of the likelihood function.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='callable', ctx=Load())), FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='callable', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the number minimizer used for the search of the likelihood function.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='minimizer', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the percentage of good counts per circuit power.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='counts', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the percentage of good counts per circuit power.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=Name(id='counts', ctx=Load()))], decorator_list=[Attribute(value=Name(id='good_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the evaluation schedule for the powers of the Grover operator.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the evaluation schedule for the powers of the Grover operator.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))], decorator_list=[Attribute(value=Name(id='evaluation_schedule', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the Fisher information for the estimated amplitude.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the Fisher information for the estimated amplitude.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='fisher_information', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[]), FunctionDef(name='_safe_min', args=arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='min', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))], decorator_list=[], returns=None), FunctionDef(name='_safe_max', args=arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='max', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))], decorator_list=[], returns=None), FunctionDef(name='_compute_fisher_information', args=arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='num_sum_terms', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation result.\n        num_sum_terms: The number of sum terms to be included in the calculation of the\n            Fisher information. By default all values are included.\n        observed: If True, compute the observed Fisher information, otherwise the theoretical\n            one.\n\n    Returns:\n        The computed Fisher information, or np.inf if statevector simulation was used.\n\n    Raises:\n        KeyError: Call run() first!\n    ')), Assign(targets=[Name(id='a', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())), Assign(targets=[Name(id='theta_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='one_hits', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())), If(test=Compare(left=Name(id='num_sum_terms', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Subscript(value=Name(id='evaluation_schedule', ctx=Load()), slice=Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None)), If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='d_loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='h_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='one_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='tan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))))], orelse=[]), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Div(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))], keywords=[])), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2)), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), AugAssign(target=Name(id='fisher_information', ctx=Store()), op=Div(), value=BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))))]), Return(value=Name(id='fisher_information', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='_fisher_confint', args=arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the `alpha` confidence interval based on the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (must be <= 0.5), default to 0.05.\n        observed: If True, use observed Fisher information.\n\n    Returns:\n        float: The alpha confidence interval based on the Fisher information\n    Raises:\n        AssertionError: Call run() first!\n    ')), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None)), Try(body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[]), If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[]), Assign(targets=[Name(id='normal_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='norm', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='confint', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[]), op=Add(), right=BinOp(left=BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[])))), Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='mapped_confint', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_likelihood_ratio_confint', args=arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='nevals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=None)]), body=[Expr(value=Str(s='Compute the likelihood-ratio confidence interval.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (< 0.5), defaults to 0.05.\n        nevals: The number of evaluations to find the intersection with the loglikelihood\n            function. Defaults to an adaptive value based on the maximal power of Q.\n\n    Returns:\n        The alpha-likelihood-ratio confidence interval.\n    ')), If(test=Compare(left=Name(id='nevals', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))], orelse=[]), FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None), arg(arg='one_counts', annotation=None), arg(arg='all_counts', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=Name(id='loglik', ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Name(id='one_counts', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())), Assign(targets=[Name(id='all_counts', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15)), Assign(targets=[Name(id='thetas', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='linspace', ctx=Load()), args=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load())), Name(id='nevals', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='theta', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='values', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='loglik_mle', ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[])), Assign(targets=[Name(id='chi2_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='chi2', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=Name(id='alpha', ctx=Load()))], keywords=[keyword(arg='df', value=Num(n=1))])), Assign(targets=[Name(id='thres', ctx=Store())], value=BinOp(left=Name(id='loglik_mle', ctx=Load()), op=Sub(), right=BinOp(left=Name(id='chi2_quantile', ctx=Load()), op=Div(), right=Num(n=2)))), Assign(targets=[Name(id='above_thres', ctx=Store())], value=Subscript(value=Name(id='thetas', ctx=Load()), slice=Index(value=Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())])), ctx=Load())), Assign(targets=[Name(id='confint', ctx=Store())], value=List(elts=[Call(func=Name(id='_safe_min', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=Num(n=0))]), Call(func=Name(id='_safe_max', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))])], ctx=Load())), Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='mapped_confint', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), FunctionDef(name='_get_counts', args=arguments(args=[arg(arg='circuit_results', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the good and total counts.\n\n    Returns:\n        A pair of two lists, ([1-counts per experiment], [shots per experiment]).\n\n    Raises:\n        AlgorithmError: If self.run() has not been called yet.\n    ')), Assign(targets=[Name(id='one_hits', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='probabilities', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), For(target=Name(id='statevector', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Assign(targets=[Name(id='p_k', ctx=Store())], value=Num(n=0.0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])], orelse=[]), AugAssign(target=Name(id='probabilities', ctx=Store()), op=Add(), value=List(elts=[Name(id='p_k', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='one_hits', ctx=Store())], value=Name(id='probabilities', ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))], orelse=[For(target=Name(id='counts', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[]))], orelse=[])]), Return(value=Tuple(elts=[Name(id='one_hits', ctx=Load()), Name(id='all_hits', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))])
Expr(value=Str(s='The Maximum Likelihood Amplitude Estimation algorithm.'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Union', asname=None), alias(name='Tuple', asname=None), alias(name='Dict', asname=None), alias(name='Callable', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='scipy.optimize', names=[alias(name='brute', asname=None)], level=0)
ImportFrom(module='scipy.stats', names=[alias(name='norm', asname=None), alias(name='chi2', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='amplitude_estimator', names=[alias(name='AmplitudeEstimator', asname=None), alias(name='AmplitudeEstimatorResult', asname=None)], level=1)
ImportFrom(module='estimation_problem', names=[alias(name='EstimationProblem', asname=None)], level=1)
ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2)
Assign(targets=[Name(id='MINIMIZER', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
ClassDef(name='MaximumLikelihoodAmplitudeEstimation', bases=[Name(id='AmplitudeEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Maximum Likelihood Amplitude Estimation algorithm.\n\n    This class implements the quantum amplitude estimation (QAE) algorithm without phase\n    estimation, as introduced in [1]. In comparison to the original QAE algorithm [2],\n    this implementation relies solely on different powers of the Grover operator and does not\n    require additional evaluation qubits.\n    Finally, the estimate is determined via a maximum likelihood estimation, which is why this\n    class in named ``MaximumLikelihoodAmplitudeEstimation``.\n\n    References:\n        [1]: Suzuki, Y., Uno, S., Raymond, R., Tanaka, T., Onodera, T., & Yamamoto, N. (2019).\n             Amplitude Estimation without Phase Estimation.\n             `arXiv:1904.10246 <https://arxiv.org/abs/1904.10246>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='minimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n                element must be non-negative. If a non-negative integer, an exponential schedule is\n                used where the highest power is 2 to the integer minus 1:\n                `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n            minimizer: A minimizer used to find the minimum of the likelihood function.\n                Defaults to a brute search where the number of evaluation points is determined\n                according to ``evaluation_schedule``. The minimizer takes a function as first\n                argument and a list of (float, float) tuples (as bounds) as second argument and\n                returns a single float which is the found minimum.\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            ValueError: If the number of oracle circuits is smaller than 1.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])))], orelse=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))]), If(test=Compare(left=Name(id='minimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), FunctionDef(name='default_minimizer', args=arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='default_minimizer', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='minimizer', ctx=Load()))])], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='construct_circuits', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the Amplitude Estimation w/o QPE quantum circuits.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\n        Returns:\n            A list with the QuantumCircuit objects for the algorithm.\n        ')), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='num_qubits', ctx=Load()), Str(s='q')], keywords=[])), Assign(targets=[Name(id='qc_0', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='qc_a'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), For(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), body=[Assign(targets=[Name(id='qc_k', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Name(id='circuits', ctx=Store()), op=Add(), value=List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='compute_confidence_interval', args=arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='kind', annotation=Name(id='str', ctx=Load())), arg(arg='apply_post_processing', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='fisher'), NameConstant(value=False)]), body=[Expr(value=Str(s="Compute the `alpha` confidence interval using the method `kind`.\n\n        The confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n        'likelihood_ratio' and 'observed_fisher' with shorthand\n        notations 'fi', 'lr' and 'oi', respectively.\n\n        Args:\n            result: A maximum likelihood amplitude estimation result.\n            alpha: The confidence level.\n            kind: The method to compute the confidence interval. Defaults to 'fisher', which\n                computes the theoretical Fisher information.\n            apply_post_processing: If True, apply post-processing to the confidence interval.\n\n        Returns:\n            The specified confidence interval.\n\n        Raises:\n            AlgorithmError: If `run()` hasn't been called yet.\n            NotImplementedError: If the method `kind` is not supported.\n        ")), Assign(targets=[Name(id='interval', ctx=Store())], value=NameConstant(value=None)), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])])]), If(test=Compare(left=Name(id='interval', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[]), cause=None)], orelse=[]), If(test=Name(id='apply_post_processing', ctx=Load()), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), Return(value=Name(id='interval', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='compute_mle', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='circuit_results', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='return_counts', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the MLE via a grid-search.\n\n        This is a stable approach if sufficient gridpoints are used.\n\n        Args:\n            circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n            estimation_problem: The estimation problem containing the evaluation schedule and the\n                number of likelihood function evaluations used to find the minimum.\n            num_state_qubits: The number of state qubits, required for statevector simulations.\n            return_counts: If True, returns the good counts.\n\n        Returns:\n            The MLE for the provided result object.\n        ')), Assign(targets=[Tuple(elts=[Name(id='good_counts', ctx=Store()), Name(id='all_counts', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_get_counts', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15)), Assign(targets=[Name(id='search_range', ctx=Store())], value=List(elts=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))], ctx=Load())), FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load())))], decorator_list=[], returns=None), Assign(targets=[Name(id='est_theta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()), args=[Name(id='loglikelihood', ctx=Load()), List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='return_counts', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='est_theta', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='minimizer', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevectors', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='statevectors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))]), Assign(targets=[Name(id='num_state_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='theta', ctx=Store()), Name(id='good_counts', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load()), NameConstant(value=True)], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Store())], value=Name(id='good_counts', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load()), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='alpha', value=Num(n=0.05)), keyword(arg='kind', value=Str(s='fisher'))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='MaximumLikelihoodAmplitudeEstimationResult'))], decorator_list=[])
ClassDef(name='MaximumLikelihoodAmplitudeEstimationResult', bases=[Name(id='AmplitudeEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The ``MaximumLikelihoodAmplitudeEstimation`` result object.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimate for the angle :math:`\\theta`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimate for the angle :math:`\\theta`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the minimizer used for the search of the likelihood function.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='callable', ctx=Load())), FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='callable', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the number minimizer used for the search of the likelihood function.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='minimizer', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the percentage of good counts per circuit power.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='counts', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the percentage of good counts per circuit power.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=Name(id='counts', ctx=Load()))], decorator_list=[Attribute(value=Name(id='good_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the evaluation schedule for the powers of the Grover operator.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the evaluation schedule for the powers of the Grover operator.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))], decorator_list=[Attribute(value=Name(id='evaluation_schedule', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the Fisher information for the estimated amplitude.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the Fisher information for the estimated amplitude.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='fisher_information', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
FunctionDef(name='_safe_min', args=arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='min', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))], decorator_list=[], returns=None)
FunctionDef(name='_safe_max', args=arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='max', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))], decorator_list=[], returns=None)
FunctionDef(name='_compute_fisher_information', args=arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='num_sum_terms', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation result.\n        num_sum_terms: The number of sum terms to be included in the calculation of the\n            Fisher information. By default all values are included.\n        observed: If True, compute the observed Fisher information, otherwise the theoretical\n            one.\n\n    Returns:\n        The computed Fisher information, or np.inf if statevector simulation was used.\n\n    Raises:\n        KeyError: Call run() first!\n    ')), Assign(targets=[Name(id='a', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())), Assign(targets=[Name(id='theta_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='one_hits', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())), If(test=Compare(left=Name(id='num_sum_terms', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Subscript(value=Name(id='evaluation_schedule', ctx=Load()), slice=Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None)), If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='d_loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='h_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='one_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='tan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))))], orelse=[]), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Div(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))], keywords=[])), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2)), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), AugAssign(target=Name(id='fisher_information', ctx=Store()), op=Div(), value=BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))))]), Return(value=Name(id='fisher_information', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load()))
FunctionDef(name='_fisher_confint', args=arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the `alpha` confidence interval based on the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (must be <= 0.5), default to 0.05.\n        observed: If True, use observed Fisher information.\n\n    Returns:\n        float: The alpha confidence interval based on the Fisher information\n    Raises:\n        AssertionError: Call run() first!\n    ')), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None)), Try(body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[]), If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[]), Assign(targets=[Name(id='normal_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='norm', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='confint', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[]), op=Add(), right=BinOp(left=BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[])))), Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='mapped_confint', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='_likelihood_ratio_confint', args=arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='nevals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=None)]), body=[Expr(value=Str(s='Compute the likelihood-ratio confidence interval.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (< 0.5), defaults to 0.05.\n        nevals: The number of evaluations to find the intersection with the loglikelihood\n            function. Defaults to an adaptive value based on the maximal power of Q.\n\n    Returns:\n        The alpha-likelihood-ratio confidence interval.\n    ')), If(test=Compare(left=Name(id='nevals', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))], orelse=[]), FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None), arg(arg='one_counts', annotation=None), arg(arg='all_counts', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=Name(id='loglik', ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Name(id='one_counts', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())), Assign(targets=[Name(id='all_counts', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15)), Assign(targets=[Name(id='thetas', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='linspace', ctx=Load()), args=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load())), Name(id='nevals', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='theta', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='values', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='loglik_mle', ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[])), Assign(targets=[Name(id='chi2_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='chi2', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=Name(id='alpha', ctx=Load()))], keywords=[keyword(arg='df', value=Num(n=1))])), Assign(targets=[Name(id='thres', ctx=Store())], value=BinOp(left=Name(id='loglik_mle', ctx=Load()), op=Sub(), right=BinOp(left=Name(id='chi2_quantile', ctx=Load()), op=Div(), right=Num(n=2)))), Assign(targets=[Name(id='above_thres', ctx=Store())], value=Subscript(value=Name(id='thetas', ctx=Load()), slice=Index(value=Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())])), ctx=Load())), Assign(targets=[Name(id='confint', ctx=Store())], value=List(elts=[Call(func=Name(id='_safe_min', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=Num(n=0))]), Call(func=Name(id='_safe_max', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))])], ctx=Load())), Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='mapped_confint', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
FunctionDef(name='_get_counts', args=arguments(args=[arg(arg='circuit_results', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the good and total counts.\n\n    Returns:\n        A pair of two lists, ([1-counts per experiment], [shots per experiment]).\n\n    Raises:\n        AlgorithmError: If self.run() has not been called yet.\n    ')), Assign(targets=[Name(id='one_hits', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='probabilities', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), For(target=Name(id='statevector', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Assign(targets=[Name(id='p_k', ctx=Store())], value=Num(n=0.0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])], orelse=[]), AugAssign(target=Name(id='probabilities', ctx=Store()), op=Add(), value=List(elts=[Name(id='p_k', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='one_hits', ctx=Store())], value=Name(id='probabilities', ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))], orelse=[For(target=Name(id='counts', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[]))], orelse=[])]), Return(value=Tuple(elts=[Name(id='one_hits', ctx=Load()), Name(id='all_hits', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='The Maximum Likelihood Amplitude Estimation algorithm.')
alias(name='Optional', asname=None)
alias(name='List', asname=None)
alias(name='Union', asname=None)
alias(name='Tuple', asname=None)
alias(name='Dict', asname=None)
alias(name='Callable', asname=None)
alias(name='numpy', asname='np')
alias(name='brute', asname=None)
alias(name='norm', asname=None)
alias(name='chi2', asname=None)
alias(name='Backend', asname=None)
alias(name='ClassicalRegister', asname=None)
alias(name='QuantumRegister', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='AmplitudeEstimator', asname=None)
alias(name='AmplitudeEstimatorResult', asname=None)
alias(name='EstimationProblem', asname=None)
alias(name='AlgorithmError', asname=None)
Name(id='MINIMIZER', ctx=Store())
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='AmplitudeEstimator', ctx=Load())
Expr(value=Str(s='The Maximum Likelihood Amplitude Estimation algorithm.\n\n    This class implements the quantum amplitude estimation (QAE) algorithm without phase\n    estimation, as introduced in [1]. In comparison to the original QAE algorithm [2],\n    this implementation relies solely on different powers of the Grover operator and does not\n    require additional evaluation qubits.\n    Finally, the estimate is determined via a maximum likelihood estimation, which is why this\n    class in named ``MaximumLikelihoodAmplitudeEstimation``.\n\n    References:\n        [1]: Suzuki, Y., Uno, S., Raymond, R., Tanaka, T., Onodera, T., & Yamamoto, N. (2019).\n             Amplitude Estimation without Phase Estimation.\n             `arXiv:1904.10246 <https://arxiv.org/abs/1904.10246>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='minimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n                element must be non-negative. If a non-negative integer, an exponential schedule is\n                used where the highest power is 2 to the integer minus 1:\n                `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n            minimizer: A minimizer used to find the minimum of the likelihood function.\n                Defaults to a brute search where the number of evaluation points is determined\n                according to ``evaluation_schedule``. The minimizer takes a function as first\n                argument and a list of (float, float) tuples (as bounds) as second argument and\n                returns a single float which is the found minimum.\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            ValueError: If the number of oracle circuits is smaller than 1.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])))], orelse=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))]), If(test=Compare(left=Name(id='minimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), FunctionDef(name='default_minimizer', args=arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='default_minimizer', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='minimizer', ctx=Load()))])], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='construct_circuits', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the Amplitude Estimation w/o QPE quantum circuits.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\n        Returns:\n            A list with the QuantumCircuit objects for the algorithm.\n        ')), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='num_qubits', ctx=Load()), Str(s='q')], keywords=[])), Assign(targets=[Name(id='qc_0', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='qc_a'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), For(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), body=[Assign(targets=[Name(id='qc_k', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Name(id='circuits', ctx=Store()), op=Add(), value=List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
FunctionDef(name='compute_confidence_interval', args=arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='kind', annotation=Name(id='str', ctx=Load())), arg(arg='apply_post_processing', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='fisher'), NameConstant(value=False)]), body=[Expr(value=Str(s="Compute the `alpha` confidence interval using the method `kind`.\n\n        The confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n        'likelihood_ratio' and 'observed_fisher' with shorthand\n        notations 'fi', 'lr' and 'oi', respectively.\n\n        Args:\n            result: A maximum likelihood amplitude estimation result.\n            alpha: The confidence level.\n            kind: The method to compute the confidence interval. Defaults to 'fisher', which\n                computes the theoretical Fisher information.\n            apply_post_processing: If True, apply post-processing to the confidence interval.\n\n        Returns:\n            The specified confidence interval.\n\n        Raises:\n            AlgorithmError: If `run()` hasn't been called yet.\n            NotImplementedError: If the method `kind` is not supported.\n        ")), Assign(targets=[Name(id='interval', ctx=Store())], value=NameConstant(value=None)), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])])]), If(test=Compare(left=Name(id='interval', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[]), cause=None)], orelse=[]), If(test=Name(id='apply_post_processing', ctx=Load()), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), Return(value=Name(id='interval', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='compute_mle', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='circuit_results', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='return_counts', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the MLE via a grid-search.\n\n        This is a stable approach if sufficient gridpoints are used.\n\n        Args:\n            circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n            estimation_problem: The estimation problem containing the evaluation schedule and the\n                number of likelihood function evaluations used to find the minimum.\n            num_state_qubits: The number of state qubits, required for statevector simulations.\n            return_counts: If True, returns the good counts.\n\n        Returns:\n            The MLE for the provided result object.\n        ')), Assign(targets=[Tuple(elts=[Name(id='good_counts', ctx=Store()), Name(id='all_counts', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_get_counts', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15)), Assign(targets=[Name(id='search_range', ctx=Store())], value=List(elts=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))], ctx=Load())), FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load())))], decorator_list=[], returns=None), Assign(targets=[Name(id='est_theta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()), args=[Name(id='loglikelihood', ctx=Load()), List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='return_counts', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='est_theta', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='minimizer', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevectors', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='statevectors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))]), Assign(targets=[Name(id='num_state_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='theta', ctx=Store()), Name(id='good_counts', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load()), NameConstant(value=True)], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Store())], value=Name(id='good_counts', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load()), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='alpha', value=Num(n=0.05)), keyword(arg='kind', value=Str(s='fisher'))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='MaximumLikelihoodAmplitudeEstimationResult'))
Name(id='AmplitudeEstimatorResult', ctx=Load())
Expr(value=Str(s='The ``MaximumLikelihoodAmplitudeEstimation`` result object.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimate for the angle :math:`\\theta`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimate for the angle :math:`\\theta`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the minimizer used for the search of the likelihood function.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='callable', ctx=Load()))
FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='callable', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the number minimizer used for the search of the likelihood function.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='minimizer', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the percentage of good counts per circuit power.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='counts', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the percentage of good counts per circuit power.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=Name(id='counts', ctx=Load()))], decorator_list=[Attribute(value=Name(id='good_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the evaluation schedule for the powers of the Grover operator.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the evaluation schedule for the powers of the Grover operator.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))], decorator_list=[Attribute(value=Name(id='evaluation_schedule', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the Fisher information for the estimated amplitude.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the Fisher information for the estimated amplitude.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='fisher_information', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0)])
If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[])
Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='min', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))
arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))])
If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[])
Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='max', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))
arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='num_sum_terms', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)])
Expr(value=Str(s='Compute the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation result.\n        num_sum_terms: The number of sum terms to be included in the calculation of the\n            Fisher information. By default all values are included.\n        observed: If True, compute the observed Fisher information, otherwise the theoretical\n            one.\n\n    Returns:\n        The computed Fisher information, or np.inf if statevector simulation was used.\n\n    Raises:\n        KeyError: Call run() first!\n    '))
Assign(targets=[Name(id='a', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load()))
Assign(targets=[Name(id='theta_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='one_hits', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load()))
Assign(targets=[Name(id='all_hits', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()))
If(test=Compare(left=Name(id='num_sum_terms', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Subscript(value=Name(id='evaluation_schedule', ctx=Load()), slice=Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None), ctx=Load()))], orelse=[])
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None))
If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='d_loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='h_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='one_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='tan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))))], orelse=[]), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Div(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))], keywords=[])), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2)), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), AugAssign(target=Name(id='fisher_information', ctx=Store()), op=Div(), value=BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))))])
Return(value=Name(id='fisher_information', ctx=Load()))
Name(id='float', ctx=Load())
arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=False)])
Expr(value=Str(s='Compute the `alpha` confidence interval based on the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (must be <= 0.5), default to 0.05.\n        observed: If True, use observed Fisher information.\n\n    Returns:\n        float: The alpha confidence interval based on the Fisher information\n    Raises:\n        AssertionError: Call run() first!\n    '))
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None))
Try(body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])
If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])
Assign(targets=[Name(id='normal_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='norm', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))], keywords=[]))
Assign(targets=[Name(id='confint', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[]), op=Add(), right=BinOp(left=BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[]))))
Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Return(value=Name(id='mapped_confint', ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='nevals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=None)])
Expr(value=Str(s='Compute the likelihood-ratio confidence interval.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (< 0.5), defaults to 0.05.\n        nevals: The number of evaluations to find the intersection with the loglikelihood\n            function. Defaults to an adaptive value based on the maximal power of Q.\n\n    Returns:\n        The alpha-likelihood-ratio confidence interval.\n    '))
If(test=Compare(left=Name(id='nevals', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))], orelse=[])
FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None), arg(arg='one_counts', annotation=None), arg(arg='all_counts', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=Name(id='loglik', ctx=Load()))], decorator_list=[], returns=None)
Assign(targets=[Name(id='one_counts', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load()))
Assign(targets=[Name(id='all_counts', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15))
Assign(targets=[Name(id='thetas', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='linspace', ctx=Load()), args=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load())), Name(id='nevals', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])], keywords=[]))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='theta', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='values', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='loglik_mle', ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='chi2_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='chi2', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=Name(id='alpha', ctx=Load()))], keywords=[keyword(arg='df', value=Num(n=1))]))
Assign(targets=[Name(id='thres', ctx=Store())], value=BinOp(left=Name(id='loglik_mle', ctx=Load()), op=Sub(), right=BinOp(left=Name(id='chi2_quantile', ctx=Load()), op=Div(), right=Num(n=2))))
Assign(targets=[Name(id='above_thres', ctx=Store())], value=Subscript(value=Name(id='thetas', ctx=Load()), slice=Index(value=Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())])), ctx=Load()))
Assign(targets=[Name(id='confint', ctx=Store())], value=List(elts=[Call(func=Name(id='_safe_min', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=Num(n=0))]), Call(func=Name(id='_safe_max', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))])], ctx=Load()))
Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Return(value=Name(id='mapped_confint', ctx=Load()))
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='circuit_results', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the good and total counts.\n\n    Returns:\n        A pair of two lists, ([1-counts per experiment], [shots per experiment]).\n\n    Raises:\n        AlgorithmError: If self.run() has not been called yet.\n    '))
Assign(targets=[Name(id='one_hits', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='all_hits', ctx=Store())], value=List(elts=[], ctx=Load()))
If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='probabilities', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), For(target=Name(id='statevector', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Assign(targets=[Name(id='p_k', ctx=Store())], value=Num(n=0.0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])], orelse=[]), AugAssign(target=Name(id='probabilities', ctx=Store()), op=Add(), value=List(elts=[Name(id='p_k', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='one_hits', ctx=Store())], value=Name(id='probabilities', ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))], orelse=[For(target=Name(id='counts', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[]))], orelse=[])])
Return(value=Tuple(elts=[Name(id='one_hits', ctx=Load()), Name(id='all_hits', ctx=Load())], ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Store()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Load()
Str(s='The Maximum Likelihood Amplitude Estimation algorithm.\n\n    This class implements the quantum amplitude estimation (QAE) algorithm without phase\n    estimation, as introduced in [1]. In comparison to the original QAE algorithm [2],\n    this implementation relies solely on different powers of the Grover operator and does not\n    require additional evaluation qubits.\n    Finally, the estimate is determined via a maximum likelihood estimation, which is why this\n    class in named ``MaximumLikelihoodAmplitudeEstimation``.\n\n    References:\n        [1]: Suzuki, Y., Uno, S., Raymond, R., Tanaka, T., Onodera, T., & Yamamoto, N. (2019).\n             Amplitude Estimation without Phase Estimation.\n             `arXiv:1904.10246 <https://arxiv.org/abs/1904.10246>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='minimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='\n        Args:\n            evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n                element must be non-negative. If a non-negative integer, an exponential schedule is\n                used where the highest power is 2 to the integer minus 1:\n                `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n            minimizer: A minimizer used to find the minimum of the likelihood function.\n                Defaults to a brute search where the number of evaluation points is determined\n                according to ``evaluation_schedule``. The minimizer takes a function as first\n                argument and a list of (float, float) tuples (as bounds) as second argument and\n                returns a single float which is the found minimum.\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            ValueError: If the number of oracle circuits is smaller than 1.\n        '))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])))], orelse=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))])
If(test=Compare(left=Name(id='minimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), FunctionDef(name='default_minimizer', args=arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='default_minimizer', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='minimizer', ctx=Load()))])
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)])
Expr(value=Str(s='Construct the Amplitude Estimation w/o QPE quantum circuits.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\n        Returns:\n            A list with the QuantumCircuit objects for the algorithm.\n        '))
Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='num_qubits', ctx=Load()), Str(s='q')], keywords=[]))
Assign(targets=[Name(id='qc_0', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='qc_a'))]))
If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
For(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), body=[Assign(targets=[Name(id='qc_k', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Name(id='circuits', ctx=Store()), op=Add(), value=List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='circuits', ctx=Load()))
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='kind', annotation=Name(id='str', ctx=Load())), arg(arg='apply_post_processing', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='fisher'), NameConstant(value=False)])
Expr(value=Str(s="Compute the `alpha` confidence interval using the method `kind`.\n\n        The confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n        'likelihood_ratio' and 'observed_fisher' with shorthand\n        notations 'fi', 'lr' and 'oi', respectively.\n\n        Args:\n            result: A maximum likelihood amplitude estimation result.\n            alpha: The confidence level.\n            kind: The method to compute the confidence interval. Defaults to 'fisher', which\n                computes the theoretical Fisher information.\n            apply_post_processing: If True, apply post-processing to the confidence interval.\n\n        Returns:\n            The specified confidence interval.\n\n        Raises:\n            AlgorithmError: If `run()` hasn't been called yet.\n            NotImplementedError: If the method `kind` is not supported.\n        "))
Assign(targets=[Name(id='interval', ctx=Store())], value=NameConstant(value=None))
If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])])])
If(test=Compare(left=Name(id='interval', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[]), cause=None)], orelse=[])
If(test=Name(id='apply_post_processing', ctx=Load()), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[])
Return(value=Name(id='interval', ctx=Load()))
Name(id='staticmethod', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='circuit_results', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='return_counts', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)])
Expr(value=Str(s='Compute the MLE via a grid-search.\n\n        This is a stable approach if sufficient gridpoints are used.\n\n        Args:\n            circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n            estimation_problem: The estimation problem containing the evaluation schedule and the\n                number of likelihood function evaluations used to find the minimum.\n            num_state_qubits: The number of state qubits, required for statevector simulations.\n            return_counts: If True, returns the good counts.\n\n        Returns:\n            The MLE for the provided result object.\n        '))
Assign(targets=[Tuple(elts=[Name(id='good_counts', ctx=Store()), Name(id='all_counts', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_get_counts', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15))
Assign(targets=[Name(id='search_range', ctx=Store())], value=List(elts=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))], ctx=Load()))
FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load())))], decorator_list=[], returns=None)
Assign(targets=[Name(id='est_theta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()), args=[Name(id='loglikelihood', ctx=Load()), List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())], keywords=[]))
If(test=Name(id='return_counts', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='est_theta', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=Compare(left=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='minimizer', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevectors', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='statevectors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))])
Assign(targets=[Name(id='num_state_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load())))
Assign(targets=[Tuple(elts=[Name(id='theta', ctx=Store()), Name(id='good_counts', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load()), NameConstant(value=True)], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Store())], value=Name(id='theta', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Store())], value=Name(id='good_counts', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load()), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))
Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='alpha', value=Num(n=0.05)), keyword(arg='kind', value=Str(s='fisher'))]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Return(value=Name(id='result', ctx=Load()))
Str(s='MaximumLikelihoodAmplitudeEstimationResult')
Load()
Str(s='The ``MaximumLikelihoodAmplitudeEstimation`` result object.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the estimate for the angle :math:`\\theta`.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the estimate for the angle :math:`\\theta`.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='theta', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the minimizer used for the search of the likelihood function.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='callable', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='callable', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the number minimizer used for the search of the likelihood function.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='minimizer', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the percentage of good counts per circuit power.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='counts', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the percentage of good counts per circuit power.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=Name(id='counts', ctx=Load()))
Attribute(value=Name(id='good_counts', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the evaluation schedule for the powers of the Grover operator.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the evaluation schedule for the powers of the Grover operator.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))
Attribute(value=Name(id='evaluation_schedule', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the Fisher information for the estimated amplitude.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the Fisher information for the estimated amplitude.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='fisher_information', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arg(arg='array', annotation=None)
arg(arg='default', annotation=None)
Num(n=0)
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)])
Return(value=Name(id='default', ctx=Load()))
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='min', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[])
arg(arg='array', annotation=None)
arg(arg='default', annotation=None)
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)])
Return(value=Name(id='default', ctx=Load()))
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='max', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[])
arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult'))
arg(arg='num_sum_terms', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
arg(arg='observed', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=None)
NameConstant(value=False)
Str(s='Compute the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation result.\n        num_sum_terms: The number of sum terms to be included in the calculation of the\n            Fisher information. By default all values are included.\n        observed: If True, compute the observed Fisher information, otherwise the theoretical\n            one.\n\n    Returns:\n        The computed Fisher information, or np.inf if statevector simulation was used.\n\n    Raises:\n        KeyError: Call run() first!\n    ')
Name(id='a', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())
Name(id='theta_a', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='one_hits', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())
Name(id='all_hits', ctx=Store())
BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))
Name(id='evaluation_schedule', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())
Compare(left=Name(id='num_sum_terms', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Subscript(value=Name(id='evaluation_schedule', ctx=Load()), slice=Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None), ctx=Load()))
Name(id='fisher_information', ctx=Store())
NameConstant(value=None)
Name(id='observed', ctx=Load())
Assign(targets=[Name(id='d_loglik', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='h_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='one_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='tan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))))], orelse=[])
AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Div(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))], keywords=[]))
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2)), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))
AugAssign(target=Name(id='fisher_information', ctx=Store()), op=Div(), value=BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))))
Name(id='fisher_information', ctx=Load())
Load()
arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
arg(arg='observed', annotation=Name(id='bool', ctx=Load()))
Num(n=0.05)
NameConstant(value=False)
Str(s='Compute the `alpha` confidence interval based on the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (must be <= 0.5), default to 0.05.\n        observed: If True, use observed Fisher information.\n\n    Returns:\n        float: The alpha confidence interval based on the Fisher information\n    Raises:\n        AssertionError: Call run() first!\n    ')
Name(id='fisher_information', ctx=Store())
NameConstant(value=None)
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Load()))
ExceptHandler(type=Name(id='KeyError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[]), cause=Name(id='ex', ctx=Load()))])
Name(id='observed', ctx=Load())
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))
Name(id='normal_quantile', ctx=Store())
Call(func=Attribute(value=Name(id='norm', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))], keywords=[])
Name(id='confint', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[]), op=Add(), right=BinOp(left=BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[])))
Name(id='mapped_confint', ctx=Store())
Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Name(id='mapped_confint', ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
arg(arg='nevals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Num(n=0.05)
NameConstant(value=None)
Str(s='Compute the likelihood-ratio confidence interval.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (< 0.5), defaults to 0.05.\n        nevals: The number of evaluations to find the intersection with the loglikelihood\n            function. Defaults to an adaptive value based on the maximal power of Q.\n\n    Returns:\n        The alpha-likelihood-ratio confidence interval.\n    ')
Compare(left=Name(id='nevals', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))
arguments(args=[arg(arg='theta', annotation=None), arg(arg='one_counts', annotation=None), arg(arg='all_counts', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[])
Return(value=Name(id='loglik', ctx=Load()))
Name(id='one_counts', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())
Name(id='all_counts', ctx=Store())
BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]))
Name(id='eps', ctx=Store())
Num(n=1e-15)
Name(id='thetas', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='linspace', ctx=Load()), args=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load())), Name(id='nevals', ctx=Load())], keywords=[])
Name(id='values', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])], keywords=[])
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='theta', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])
Assign(targets=[Subscript(value=Name(id='values', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[]))
Name(id='loglik_mle', ctx=Store())
Call(func=Name(id='loglikelihood', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[])
Name(id='chi2_quantile', ctx=Store())
Call(func=Attribute(value=Name(id='chi2', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=Name(id='alpha', ctx=Load()))], keywords=[keyword(arg='df', value=Num(n=1))])
Name(id='thres', ctx=Store())
BinOp(left=Name(id='loglik_mle', ctx=Load()), op=Sub(), right=BinOp(left=Name(id='chi2_quantile', ctx=Load()), op=Div(), right=Num(n=2)))
Name(id='above_thres', ctx=Store())
Subscript(value=Name(id='thetas', ctx=Load()), slice=Index(value=Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())])), ctx=Load())
Name(id='confint', ctx=Store())
List(elts=[Call(func=Name(id='_safe_min', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=Num(n=0))]), Call(func=Name(id='_safe_max', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))])], ctx=Load())
Name(id='mapped_confint', ctx=Store())
Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Name(id='mapped_confint', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
arg(arg='circuit_results', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))
Str(s='Get the good and total counts.\n\n    Returns:\n        A pair of two lists, ([1-counts per experiment], [shots per experiment]).\n\n    Raises:\n        AlgorithmError: If self.run() has not been called yet.\n    ')
Name(id='one_hits', ctx=Store())
List(elts=[], ctx=Load())
Name(id='all_hits', ctx=Store())
List(elts=[], ctx=Load())
Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Assign(targets=[Name(id='probabilities', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
For(target=Name(id='statevector', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Assign(targets=[Name(id='p_k', ctx=Store())], value=Num(n=0.0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])], orelse=[]), AugAssign(target=Name(id='probabilities', ctx=Store()), op=Add(), value=List(elts=[Name(id='p_k', ctx=Load())], ctx=Load()))], orelse=[])
Assign(targets=[Name(id='one_hits', ctx=Store())], value=Name(id='probabilities', ctx=Load()))
Assign(targets=[Name(id='all_hits', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))
For(target=Name(id='counts', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[]))], orelse=[])
Tuple(elts=[Name(id='one_hits', ctx=Load()), Name(id='all_hits', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
arg(arg='self', annotation=None)
arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='minimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
Str(s='\n        Args:\n            evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n                element must be non-negative. If a non-negative integer, an exponential schedule is\n                used where the highest power is 2 to the integer minus 1:\n                `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n            minimizer: A minimizer used to find the minimum of the likelihood function.\n                Defaults to a brute search where the number of evaluation points is determined\n                according to ``evaluation_schedule``. The minimizer takes a function as first\n                argument and a list of (float, float) tuples (as bounds) as second argument and\n                returns a single float which is the found minimum.\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            ValueError: If the number of oracle circuits is smaller than 1.\n        ')
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load()), Name(id='int', ctx=Load())], keywords=[])
If(test=Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])))
If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))
Compare(left=Name(id='minimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))
FunctionDef(name='default_minimizer', args=arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))], decorator_list=[], returns=None)
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='default_minimizer', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='minimizer', ctx=Load()))
arg(arg='self', annotation=None)
Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=False)
Str(s='Construct the Amplitude Estimation w/o QPE quantum circuits.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\n        Returns:\n            A list with the QuantumCircuit objects for the algorithm.\n        ')
Name(id='circuits', ctx=Store())
List(elts=[], ctx=Load())
Name(id='num_qubits', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Name(id='q', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='num_qubits', ctx=Load()), Str(s='q')], keywords=[])
Name(id='qc_0', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='qc_a'))])
Name(id='measurement', ctx=Load())
Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Name(id='k', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())
Assign(targets=[Name(id='qc_k', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))]))
If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[])
If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[])
AugAssign(target=Name(id='circuits', ctx=Store()), op=Add(), value=List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load()))
Name(id='circuits', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult'))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
arg(arg='kind', annotation=Name(id='str', ctx=Load()))
arg(arg='apply_post_processing', annotation=Name(id='bool', ctx=Load()))
Str(s='fisher')
NameConstant(value=False)
Str(s="Compute the `alpha` confidence interval using the method `kind`.\n\n        The confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n        'likelihood_ratio' and 'observed_fisher' with shorthand\n        notations 'fi', 'lr' and 'oi', respectively.\n\n        Args:\n            result: A maximum likelihood amplitude estimation result.\n            alpha: The confidence level.\n            kind: The method to compute the confidence interval. Defaults to 'fisher', which\n                computes the theoretical Fisher information.\n            apply_post_processing: If True, apply post-processing to the confidence interval.\n\n        Returns:\n            The specified confidence interval.\n\n        Raises:\n            AlgorithmError: If `run()` hasn't been called yet.\n            NotImplementedError: If the method `kind` is not supported.\n        ")
Name(id='interval', ctx=Store())
NameConstant(value=None)
Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Assign(targets=[Name(id='interval', ctx=Store())], value=BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())))
If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])])
Compare(left=Name(id='interval', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[]), cause=None)
Name(id='apply_post_processing', ctx=Load())
Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Name(id='interval', ctx=Load())
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='circuit_results', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
arg(arg='num_state_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
arg(arg='return_counts', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=None)
NameConstant(value=False)
Str(s='Compute the MLE via a grid-search.\n\n        This is a stable approach if sufficient gridpoints are used.\n\n        Args:\n            circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n            estimation_problem: The estimation problem containing the evaluation schedule and the\n                number of likelihood function evaluations used to find the minimum.\n            num_state_qubits: The number of state qubits, required for statevector simulations.\n            return_counts: If True, returns the good counts.\n\n        Returns:\n            The MLE for the provided result object.\n        ')
Tuple(elts=[Name(id='good_counts', ctx=Store()), Name(id='all_counts', ctx=Store())], ctx=Store())
Call(func=Name(id='_get_counts', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load())], keywords=[])
Name(id='eps', ctx=Store())
Num(n=1e-15)
Name(id='search_range', ctx=Store())
List(elts=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))], ctx=Load())
arguments(args=[arg(arg='theta', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[])
Return(value=UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load())))
Name(id='est_theta', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()), args=[Name(id='loglikelihood', ctx=Load()), List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())], keywords=[])
Name(id='return_counts', ctx=Load())
Return(value=Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load()))
Name(id='est_theta', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
Compare(left=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[]), cause=None)
Name(id='result', ctx=Store())
Call(func=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='minimizer', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))]))
Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='statevectors', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='statevectors', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Num(n=1))
Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))]))
Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))
Name(id='num_state_qubits', ctx=Store())
BinOp(left=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load()))
Tuple(elts=[Name(id='theta', ctx=Store()), Name(id='good_counts', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load()), NameConstant(value=True)], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Store())
Name(id='theta', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Store())
Name(id='good_counts', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Store())
Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())
BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load()), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Name(id='confidence_interval', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='alpha', value=Num(n=0.05)), keyword(arg='kind', value=Str(s='fisher'))])
Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())
Name(id='confidence_interval', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())
Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Name(id='result', ctx=Load())
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='Return the estimate for the angle :math:`\\theta`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the estimate for the angle :math:`\\theta`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())
Name(id='value', ctx=Load())
Name(id='theta', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the minimizer used for the search of the likelihood function.')
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='callable', ctx=Load()))
Str(s='Set the number minimizer used for the search of the likelihood function.')
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())
Name(id='value', ctx=Load())
Name(id='minimizer', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the percentage of good counts per circuit power.')
Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='counts', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Str(s='Set the percentage of good counts per circuit power.')
Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())
Name(id='counts', ctx=Load())
Name(id='good_counts', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the evaluation schedule for the powers of the Grover operator.')
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Str(s='Set the evaluation schedule for the powers of the Grover operator.')
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())
Name(id='evaluation_schedule', ctx=Load())
Name(id='evaluation_schedule', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the Fisher information for the estimated amplitude.')
Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the Fisher information for the estimated amplitude.')
Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())
Name(id='value', ctx=Load())
Name(id='fisher_information', ctx=Load())
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[])
Eq()
Num(n=0)
Name(id='default', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='min', ctx=Load())
Name(id='array', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[])
Eq()
Num(n=0)
Name(id='default', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='max', ctx=Load())
Name(id='array', ctx=Load())
Str(s='MaximumLikelihoodAmplitudeEstimationResult')
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Store()
Name(id='result', ctx=Load())
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])
Store()
Name(id='result', ctx=Load())
Load()
Store()
List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load())
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[])
Store()
Name(id='result', ctx=Load())
Load()
Name(id='num_sum_terms', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='evaluation_schedule', ctx=Store())
Subscript(value=Name(id='evaluation_schedule', ctx=Load()), slice=Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None), ctx=Load())
Store()
Load()
Name(id='d_loglik', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='h_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='one_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[])
Assign(targets=[Name(id='tan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[]))
AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))))
Name(id='d_loglik', ctx=Store())
Div()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))], keywords=[])
Name(id='fisher_information', ctx=Store())
BinOp(left=BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2)), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[]))
Name(id='fisher_information', ctx=Store())
Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])
Name(id='fisher_information', ctx=Store())
Div()
BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))
Load()
Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())
Name(id='float', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Name(id='fisher_information', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Load())
Name(id='KeyError', ctx=Load())
Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[]), cause=Name(id='ex', ctx=Load()))
Load()
Name(id='fisher_information', ctx=Store())
Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))])
Store()
Attribute(value=Name(id='norm', ctx=Load()), attr='ppf', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[])
Add()
BinOp(left=BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[]))
Store()
Name(id='tuple', ctx=Load())
GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())
Name(id='float', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='nevals', ctx=Load())
Is()
NameConstant(value=None)
Name(id='nevals', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])
arg(arg='theta', annotation=None)
arg(arg='one_counts', annotation=None)
arg(arg='all_counts', annotation=None)
Name(id='loglik', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())], keywords=[])
AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())))
AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))
Name(id='loglik', ctx=Load())
Store()
Name(id='result', ctx=Load())
Load()
Store()
List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load())
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])
Store()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='linspace', ctx=Load())
BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load()))
BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))
Name(id='nevals', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])
Name(id='i', ctx=Store())
Name(id='theta', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='thetas', ctx=Load())
Subscript(value=Name(id='values', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())
Call(func=Name(id='loglikelihood', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[])
Store()
Name(id='loglikelihood', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())
Name(id='one_counts', ctx=Load())
Name(id='all_counts', ctx=Load())
Store()
Attribute(value=Name(id='chi2', ctx=Load()), attr='ppf', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=Name(id='alpha', ctx=Load()))
keyword(arg='df', value=Num(n=1))
Store()
Name(id='loglik_mle', ctx=Load())
Sub()
BinOp(left=Name(id='chi2_quantile', ctx=Load()), op=Div(), right=Num(n=2))
Store()
Name(id='thetas', ctx=Load())
Index(value=Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())]))
Load()
Store()
Call(func=Name(id='_safe_min', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=Num(n=0))])
Call(func=Name(id='_safe_max', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))])
Load()
Store()
Name(id='tuple', ctx=Load())
GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='EstimationProblem', ctx=Load())
Name(id='int', ctx=Load())
Store()
Load()
Store()
Load()
Name(id='all', ctx=Load())
GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)])
Name(id='probabilities', ctx=Store())
List(elts=[], ctx=Load())
Name(id='num_qubits', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='statevector', ctx=Store())
Name(id='circuit_results', ctx=Load())
Assign(targets=[Name(id='p_k', ctx=Store())], value=Num(n=0.0))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])], orelse=[])
AugAssign(target=Name(id='probabilities', ctx=Store()), op=Add(), value=List(elts=[Name(id='p_k', ctx=Load())], ctx=Load()))
Name(id='one_hits', ctx=Store())
Name(id='probabilities', ctx=Load())
Name(id='all_hits', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[])
Name(id='counts', ctx=Store())
Name(id='circuit_results', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[]))
Name(id='one_hits', ctx=Load())
Name(id='all_hits', ctx=Load())
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())], ctx=Load())
List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load())
Name(id='float', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='isinstance', ctx=Load())
Name(id='evaluation_schedule', ctx=Load())
Name(id='int', ctx=Load())
Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())
BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))
Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())
Name(id='evaluation_schedule', ctx=Load())
Name(id='minimizer', ctx=Load())
Is()
NameConstant(value=None)
Name(id='nevals', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])
arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())
Name(id='default_minimizer', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())
Name(id='minimizer', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='EstimationProblem', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Load()
Store()
Name(id='max', ctx=Load())
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load())
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='num_qubits', ctx=Load())
Str(s='q')
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='q', ctx=Load())
keyword(arg='name', value=Str(s='qc_a'))
Load()
Name(id='c', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])
Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())
keyword(arg='inplace', value=NameConstant(value=True))
Store()
Name(id='self', ctx=Load())
Load()
Name(id='qc_k', ctx=Store())
Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))])
Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
Name(id='measurement', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))
Name(id='circuits', ctx=Store())
Add()
List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Str(s='MaximumLikelihoodAmplitudeEstimationResult')
Name(id='float', ctx=Load())
Name(id='str', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Name(id='all', ctx=Load())
GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])
Name(id='interval', ctx=Store())
BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load()))
Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())])
Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])
Name(id='interval', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[])
Load()
Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Name(id='EstimationProblem', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Name(id='good_counts', ctx=Store())
Name(id='all_counts', ctx=Store())
Store()
Name(id='_get_counts', ctx=Load())
Name(id='circuit_results', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Name(id='num_state_qubits', ctx=Load())
Store()
Store()
BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load()))
BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))
Load()
arg(arg='theta', annotation=None)
Name(id='loglik', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[])
Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load())))
AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())))
AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))
UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load()))
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())
Name(id='loglikelihood', ctx=Load())
List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Name(id='EstimationProblem', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[])
Store()
Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())
Name(id='result', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Name(id='estimation_problem', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='circuits', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])
Name(id='ret', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])
  Found a method call call at line 276
Name(id='statevectors', ctx=Store())
ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])
Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())
Name(id='statevectors', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())
Num(n=1)
Name(id='circuits', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])
Name(id='ret', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])
  Found a method call call at line 288
Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())
ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])
Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())
Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())
Store()
Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load())
Sub()
Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load())
Name(id='theta', ctx=Store())
Name(id='good_counts', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Name(id='num_state_qubits', ctx=Load())
NameConstant(value=True)
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())
Name(id='result', ctx=Load())
Store()
Name(id='_compute_fisher_information', ctx=Load())
Name(id='result', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())
Mult()
Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load())
Name(id='result', ctx=Load())
keyword(arg='alpha', value=Num(n=0.05))
keyword(arg='kind', value=Str(s='fisher'))
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Name(id='tuple', ctx=Load())
GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])
Load()
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='callable', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='len', ctx=Load())
Name(id='array', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='array', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='one_hits', ctx=Load())
Load()
Load()
Store()
Name(id='evaluation_schedule', ctx=Load())
Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None)
Load()
Store()
Name(id='shots_k', ctx=Store())
Name(id='h_k', ctx=Store())
Name(id='m_k', ctx=Store())
Store()
Name(id='zip', ctx=Load())
Name(id='all_hits', ctx=Load())
Name(id='one_hits', ctx=Load())
Name(id='evaluation_schedule', ctx=Load())
Name(id='tan', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[])
Name(id='d_loglik', ctx=Store())
Add()
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load()))))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))
Store()
BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2))
Div()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[])
Store()
Name(id='sum', ctx=Load())
GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])
Store()
Name(id='a', ctx=Load())
Mult()
BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))
Load()
Load()
Load()
Store()
Name(id='result', ctx=Load())
Load()
Load()
Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[])
Name(id='ex', ctx=Load())
Store()
Name(id='_compute_fisher_information', ctx=Load())
Name(id='result', ctx=Load())
keyword(arg='observed', value=NameConstant(value=True))
Name(id='norm', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())
BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[]))
Mult()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[])
Load()
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[])
comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Store()
Name(id='max', ctx=Load())
Num(n=10000)
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])
Store()
Name(id='i', ctx=Store())
Name(id='k', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())
Name(id='loglik', ctx=Store())
Add()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Name(id='loglik', ctx=Store())
Add()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())))
Load()
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='one_counts', ctx=Load())
Name(id='np', ctx=Load())
Load()
Num(n=0)
Add()
Name(id='eps', ctx=Load())
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Sub()
Name(id='eps', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='thetas', ctx=Load())
Store()
Store()
Load()
Load()
Name(id='values', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Store()
Name(id='loglikelihood', ctx=Load())
Name(id='theta', ctx=Load())
Name(id='one_counts', ctx=Load())
Name(id='all_counts', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Name(id='chi2', ctx=Load())
Load()
Num(n=1)
Sub()
Name(id='alpha', ctx=Load())
Num(n=1)
Load()
Name(id='chi2_quantile', ctx=Load())
Div()
Num(n=2)
Load()
Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())])
Name(id='_safe_min', ctx=Load())
Name(id='above_thres', ctx=Load())
keyword(arg='default', value=Num(n=0))
Name(id='_safe_max', ctx=Load())
Name(id='above_thres', ctx=Load())
keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))
Load()
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[])
comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[])
comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)
Store()
Load()
Store()
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])
Store()
Load()
Name(id='p_k', ctx=Store())
Num(n=0.0)
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])
Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)))
Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)]))
If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])
Name(id='probabilities', ctx=Store())
Add()
List(elts=[Name(id='p_k', ctx=Load())], ctx=Load())
Store()
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load())
Name(id='one_hits', ctx=Load())
Store()
Load()
Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[])
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='MINIMIZER', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Name(id='evaluation_schedule', ctx=Load())
Lt()
Num(n=0)
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[])
Name(id='self', ctx=Load())
Store()
List(elts=[Num(n=0)], ctx=Load())
Add()
ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])
Name(id='any', ctx=Load())
GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Store()
Name(id='max', ctx=Load())
Num(n=10000)
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])
arg(arg='objective_fn', annotation=None)
arg(arg='bounds', annotation=None)
Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Str(s='qc_a')
Store()
Name(id='ClassicalRegister', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])
Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load())
Name(id='c', ctx=Load())
Name(id='qc_0', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
NameConstant(value=True)
Load()
Store()
Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load())
keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))
Name(id='k', ctx=Load())
NotEq()
Num(n=0)
Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Load()
Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])
Store()
Name(id='qc_k', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[])
comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)
Store()
Num(n=2)
Mult()
List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())
Name(id='kind', ctx=Load())
In()
List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())
Name(id='interval', ctx=Store())
Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[])
Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())])
Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))
If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])
Load()
Name(id='NotImplementedError', ctx=Load())
JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])
Name(id='tuple', ctx=Load())
GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Store()
Store()
Load()
Load()
Load()
Load()
Num(n=0)
Add()
Name(id='eps', ctx=Load())
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Sub()
Name(id='eps', ctx=Load())
Store()
Name(id='i', ctx=Store())
Name(id='k', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())
Name(id='angle', ctx=Store())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))
Name(id='loglik', ctx=Store())
Add()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Name(id='loglik', ctx=Store())
Add()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())))
USub()
Name(id='loglik', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Name(id='search_range', ctx=Load())
Load()
Name(id='est_theta', ctx=Load())
Name(id='good_counts', ctx=Load())
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load())
Name(id='estimation_problem', ctx=Load())
keyword(arg='measurement', value=NameConstant(value=False))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuits', ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[])
comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load())
Name(id='estimation_problem', ctx=Load())
keyword(arg='measurement', value=NameConstant(value=True))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuits', ctx=Load())
Name(id='result', ctx=Load())
Store()
Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)
Name(id='result', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load())
Load()
Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='result', ctx=Load())
Load()
Name(id='sum', ctx=Load())
GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])
Name(id='self', ctx=Load())
Load()
Load()
Num(n=0.05)
Str(s='fisher')
Load()
Load()
Load()
Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])
comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Name(id='a', ctx=Load())
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='num_sum_terms', ctx=Load())
Store()
Store()
Store()
Load()
Load()
Load()
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))
Store()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1))
Mult()
BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))
Name(id='np', ctx=Load())
Load()
Name(id='a', ctx=Load())
Mult()
BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))
Name(id='d_loglik', ctx=Load())
Pow()
Num(n=2)
Name(id='len', ctx=Load())
Name(id='all_hits', ctx=Load())
Load()
BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2)))
comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)
Load()
Num(n=1)
Sub()
Name(id='a', ctx=Load())
Load()
Name(id='AssertionError', ctx=Load())
Str(s='Call run() first!')
Load()
Load()
Load()
NameConstant(value=True)
Load()
Name(id='alpha', ctx=Load())
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Name(id='normal_quantile', ctx=Load())
Div()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='bound', ctx=Load())
Name(id='bound', ctx=Store())
Name(id='confint', ctx=Load())
Load()
Load()
Load()
Name(id='int', ctx=Load())
Load()
Name(id='int', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Store()
Store()
Load()
Name(id='result', ctx=Load())
Load()
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[])
Mult()
Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[])
Mult()
BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Load()
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='values', ctx=Load())
GtE()
Name(id='thres', ctx=Load())
Load()
Load()
Num(n=0)
Load()
Load()
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='bound', ctx=Store())
Name(id='confint', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='data', ctx=Load())
Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Name(id='data', ctx=Store())
Name(id='circuit_results', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Store()
Name(id='i', ctx=Store())
Name(id='amplitude', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='statevector', ctx=Load())
Name(id='probability', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='bitstr', ctx=Store())
Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Name(id='objectives', ctx=Store())
ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])
Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[])
AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))
Store()
Name(id='p_k', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load())
Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])
Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load())
Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
Name(id='MINIMIZER', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Load()
Name(id='ValueError', ctx=Load())
Str(s='The evaluation schedule cannot be < 0.')
Load()
Num(n=0)
Load()
BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load()))
comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)
Load()
Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)])
comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)
Name(id='ValueError', ctx=Load())
Str(s='The elements of the evaluation schedule cannot be < 0.')
Load()
Load()
Name(id='int', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))])
Index(value=Num(n=0))
Load()
Load()
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Name(id='len', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='qc_0', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='qc_0', ctx=Load())
Load()
BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load()))
Load()
Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])
keyword(arg='inplace', value=NameConstant(value=True))
Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load())
Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Load()
Name(id='isinstance', ctx=Load())
Name(id='data', ctx=Load())
Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Name(id='data', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())
Load()
Load()
Str(s='likelihood_ratio')
Str(s='lr')
Load()
Store()
Name(id='_likelihood_ratio_confint', ctx=Load())
Name(id='result', ctx=Load())
Name(id='alpha', ctx=Load())
Name(id='kind', ctx=Load())
In()
List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())
Name(id='interval', ctx=Store())
Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))])
Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())])
Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))
Load()
Str(s='CI `')
FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None)
Str(s='` is not implemented.')
Load()
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])
comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)
Load()
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Load()
Store()
Store()
Load()
Name(id='self', ctx=Load())
Load()
Store()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1))
Mult()
Name(id='theta', ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[])
Mult()
Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[])
Mult()
BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
NameConstant(value=False)
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load())
Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='circuit', ctx=Store())
Name(id='circuits', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load())
Name(id='circuit', ctx=Load())
Name(id='circuit', ctx=Store())
Name(id='circuits', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='circuits', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='circuits', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='k', ctx=Load())
comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='value', ctx=Load())
Name(id='value', ctx=Store())
Name(id='confidence_interval', ctx=Load())
Name(id='super', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1))
Mult()
Name(id='theta_a', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load()))
Add()
Num(n=1)
BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load()))
Add()
BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load()))
Load()
Load()
Num(n=1)
Sub()
Name(id='a', ctx=Load())
Load()
Load()
Load()
Name(id='shots_k', ctx=Load())
Mult()
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))
Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
Name(id='fisher_information', ctx=Load())
Name(id='np', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Num(n=1)
Load()
Name(id='result', ctx=Load())
Load()
Load()
Store()
Load()
Load()
Load()
BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2))
Mult()
Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='one_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))
Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Sub()
Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Name(id='result', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Store()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Name(id='list', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Store()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Store()
Store()
Load()
Load()
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Store()
Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load())
Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Store()
Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load())
comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load())
Name(id='objectives', ctx=Load())
Name(id='p_k', ctx=Store())
Add()
Name(id='probability', ctx=Load())
Load()
Load()
Name(id='all_hits', ctx=Load())
Load()
Name(id='sum', ctx=Load())
Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])
Name(id='one_hits', ctx=Load())
Load()
Name(id='sum', ctx=Load())
GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])
Load()
Name(id='float', ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Load()
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='int', ctx=Load())
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Num(n=2)
Pow()
Name(id='j', ctx=Load())
Name(id='j', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[])
Name(id='value', ctx=Load())
Lt()
Num(n=0)
Name(id='value', ctx=Store())
Name(id='evaluation_schedule', ctx=Load())
Load()
Load()
BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2))
Mult()
Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Name(id='brute', ctx=Load())
Name(id='objective_fn', ctx=Load())
Name(id='bounds', ctx=Load())
keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))
Num(n=0)
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Load()
Str(s='qc_a_q_%s')
Mod()
Name(id='k', ctx=Load())
Name(id='qc_k', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load())
Name(id='k', ctx=Load())
NameConstant(value=True)
Name(id='qc_k', ctx=Load())
Load()
Name(id='qc_k', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='c', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Load()
Name(id='list', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Store()
Name(id='result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Str(s='fisher')
Str(s='fi')
Load()
Store()
Name(id='_fisher_confint', ctx=Load())
Name(id='result', ctx=Load())
Name(id='alpha', ctx=Load())
keyword(arg='observed', value=NameConstant(value=False))
Name(id='kind', ctx=Load())
In()
List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())
Name(id='interval', ctx=Store())
Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))])
Name(id='kind', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='value', ctx=Load())
Name(id='value', ctx=Store())
Name(id='interval', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load()))
Add()
Num(n=1)
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='good_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Sub()
Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='ret', ctx=Load())
Load()
Load()
Store()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Num(n=0)
Load()
Num(n=0)
Load()
Load()
Load()
Name(id='k', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Store()
Load()
Load()
Load()
Load()
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load()))
Add()
Num(n=1)
Load()
Num(n=2)
Mult()
Name(id='m_k', ctx=Load())
Name(id='h_k', ctx=Load())
Div()
Name(id='tan', ctx=Load())
BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load()))
Mult()
Name(id='tan', ctx=Load())
Load()
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1))
Pow()
Num(n=2)
Name(id='shots_k', ctx=Store())
Name(id='m_k', ctx=Store())
Store()
Name(id='zip', ctx=Load())
Name(id='all_hits', ctx=Load())
Name(id='evaluation_schedule', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Load()
USub()
Num(n=1)
Load()
BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000))
Mult()
Num(n=2)
Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[])
Pow()
Num(n=2)
Load()
Name(id='i', ctx=Load())
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[])
Pow()
Num(n=2)
Name(id='all_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='one_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
Name(id='bound', ctx=Load())
Load()
Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='circuit_results', ctx=Load())
Index(value=Num(n=0))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Name(id='amplitude', ctx=Load())
Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[])
Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None)
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='bitstr', ctx=Load())
Index(value=Name(id='index', ctx=Load()))
Load()
Name(id='index', ctx=Store())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Store()
Load()
Load()
Load()
Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load())
Load()
Load()
Name(id='count', ctx=Load())
comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)
Load()
Load()
List(elts=[Name(id='float', ctx=Load())], ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Store()
Name(id='range', ctx=Load())
Name(id='evaluation_schedule', ctx=Load())
Load()
Store()
Load()
BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000))
Mult()
Num(n=2)
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Load()
Load()
Load()
Name(id='nevals', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
NameConstant(value=False)
Load()
Str(s='observed_fisher')
Str(s='observed_information')
Str(s='oi')
Load()
Store()
Name(id='_fisher_confint', ctx=Load())
Name(id='result', ctx=Load())
Name(id='alpha', ctx=Load())
keyword(arg='observed', value=NameConstant(value=True))
Load()
Name(id='result', ctx=Load())
Load()
Load()
Store()
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
Load()
Num(n=2)
Mult()
Name(id='k', ctx=Load())
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Load()
Name(id='i', ctx=Load())
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Name(id='all_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='good_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Load()
Load()
Name(id='ret', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Store()
Name(id='result', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Name(id='m_k', ctx=Load())
Load()
Load()
Load()
Name(id='shots_k', ctx=Load())
Sub()
Name(id='h_k', ctx=Load())
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load()))
Add()
Num(n=1)
Store()
Store()
Load()
Load()
Load()
Load()
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Mult()
Num(n=1000)
Name(id='result', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))
Load()
Name(id='i', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Num(n=0)
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load())
Name(id='num_qubits', ctx=Load())
UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load()))
USub()
Num(n=1)
Load()
Name(id='index', ctx=Load())
Store()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Name(id='counts', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])
Name(id='float', ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Mult()
Num(n=1000)
Name(id='self', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Load()
Load()
Load()
NameConstant(value=True)
Load()
Load()
Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
Name(id='angle', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load())
Name(id='angle', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='m_k', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Load()
USub()
Num(n=1)
Name(id='np', ctx=Load())
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1))
Mult()
Name(id='theta', ctx=Load())
Name(id='np', ctx=Load())
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1))
Mult()
Name(id='theta', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='Dict', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Load()
Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())
Load()
Load()
USub()
Name(id='num_state_qubits', ctx=Load())
Load()
Load()
Load()
Name(id='bitstr', ctx=Store())
Name(id='count', ctx=Store())
Store()
Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load())
Name(id='bitstr', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Load()
USub()
Num(n=1)
Load()
Name(id='Dict', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load()))
Add()
Num(n=1)
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load()))
Add()
Num(n=1)
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])
Slice(lower=Num(n=2), upper=None, step=None)
Load()
Load()
Store()
Store()
Name(id='counts', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='k', ctx=Load())
Num(n=2)
Mult()
Name(id='k', ctx=Load())
Load()
Name(id='str', ctx=Load())
Name(id='int', ctx=Load())
Load()
Name(id='bin', ctx=Load())
Name(id='i', ctx=Load())
Num(n=2)
Load()
Load()
Load()
Name(id='str', ctx=Load())
Name(id='int', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Module(body=[Expr(value=Str(s='The Maximum Likelihood Amplitude Estimation algorithm.')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Union', asname=None), alias(name='Tuple', asname=None), alias(name='Dict', asname=None), alias(name='Callable', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='scipy.optimize', names=[alias(name='brute', asname=None)], level=0), ImportFrom(module='scipy.stats', names=[alias(name='norm', asname=None), alias(name='chi2', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='amplitude_estimator', names=[alias(name='AmplitudeEstimator', asname=None), alias(name='AmplitudeEstimatorResult', asname=None)], level=1), ImportFrom(module='estimation_problem', names=[alias(name='EstimationProblem', asname=None)], level=1), ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2), Assign(targets=[Name(id='MINIMIZER', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ClassDef(name='MaximumLikelihoodAmplitudeEstimation', bases=[Name(id='AmplitudeEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Maximum Likelihood Amplitude Estimation algorithm.\n\n    This class implements the quantum amplitude estimation (QAE) algorithm without phase\n    estimation, as introduced in [1]. In comparison to the original QAE algorithm [2],\n    this implementation relies solely on different powers of the Grover operator and does not\n    require additional evaluation qubits.\n    Finally, the estimate is determined via a maximum likelihood estimation, which is why this\n    class in named ``MaximumLikelihoodAmplitudeEstimation``.\n\n    References:\n        [1]: Suzuki, Y., Uno, S., Raymond, R., Tanaka, T., Onodera, T., & Yamamoto, N. (2019).\n             Amplitude Estimation without Phase Estimation.\n             `arXiv:1904.10246 <https://arxiv.org/abs/1904.10246>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='minimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n                element must be non-negative. If a non-negative integer, an exponential schedule is\n                used where the highest power is 2 to the integer minus 1:\n                `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n            minimizer: A minimizer used to find the minimum of the likelihood function.\n                Defaults to a brute search where the number of evaluation points is determined\n                according to ``evaluation_schedule``. The minimizer takes a function as first\n                argument and a list of (float, float) tuples (as bounds) as second argument and\n                returns a single float which is the found minimum.\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            ValueError: If the number of oracle circuits is smaller than 1.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])))], orelse=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))]), If(test=Compare(left=Name(id='minimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), FunctionDef(name='default_minimizer', args=arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='default_minimizer', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='minimizer', ctx=Load()))])], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='construct_circuits', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the Amplitude Estimation w/o QPE quantum circuits.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\n        Returns:\n            A list with the QuantumCircuit objects for the algorithm.\n        ')), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='num_qubits', ctx=Load()), Str(s='q')], keywords=[])), Assign(targets=[Name(id='qc_0', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='qc_a'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), For(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), body=[Assign(targets=[Name(id='qc_k', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Name(id='circuits', ctx=Store()), op=Add(), value=List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='compute_confidence_interval', args=arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='kind', annotation=Name(id='str', ctx=Load())), arg(arg='apply_post_processing', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='fisher'), NameConstant(value=False)]), body=[Expr(value=Str(s="Compute the `alpha` confidence interval using the method `kind`.\n\n        The confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n        'likelihood_ratio' and 'observed_fisher' with shorthand\n        notations 'fi', 'lr' and 'oi', respectively.\n\n        Args:\n            result: A maximum likelihood amplitude estimation result.\n            alpha: The confidence level.\n            kind: The method to compute the confidence interval. Defaults to 'fisher', which\n                computes the theoretical Fisher information.\n            apply_post_processing: If True, apply post-processing to the confidence interval.\n\n        Returns:\n            The specified confidence interval.\n\n        Raises:\n            AlgorithmError: If `run()` hasn't been called yet.\n            NotImplementedError: If the method `kind` is not supported.\n        ")), Assign(targets=[Name(id='interval', ctx=Store())], value=NameConstant(value=None)), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])])]), If(test=Compare(left=Name(id='interval', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[]), cause=None)], orelse=[]), If(test=Name(id='apply_post_processing', ctx=Load()), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), Return(value=Name(id='interval', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='compute_mle', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='circuit_results', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='return_counts', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the MLE via a grid-search.\n\n        This is a stable approach if sufficient gridpoints are used.\n\n        Args:\n            circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n            estimation_problem: The estimation problem containing the evaluation schedule and the\n                number of likelihood function evaluations used to find the minimum.\n            num_state_qubits: The number of state qubits, required for statevector simulations.\n            return_counts: If True, returns the good counts.\n\n        Returns:\n            The MLE for the provided result object.\n        ')), Assign(targets=[Tuple(elts=[Name(id='good_counts', ctx=Store()), Name(id='all_counts', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_get_counts', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15)), Assign(targets=[Name(id='search_range', ctx=Store())], value=List(elts=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))], ctx=Load())), FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load())))], decorator_list=[], returns=None), Assign(targets=[Name(id='est_theta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()), args=[Name(id='loglikelihood', ctx=Load()), List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='return_counts', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='est_theta', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='minimizer', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevectors', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='statevectors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))]), Assign(targets=[Name(id='num_state_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='theta', ctx=Store()), Name(id='good_counts', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load()), NameConstant(value=True)], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Store())], value=Name(id='good_counts', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load()), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='alpha', value=Num(n=0.05)), keyword(arg='kind', value=Str(s='fisher'))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='MaximumLikelihoodAmplitudeEstimationResult'))], decorator_list=[]), ClassDef(name='MaximumLikelihoodAmplitudeEstimationResult', bases=[Name(id='AmplitudeEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The ``MaximumLikelihoodAmplitudeEstimation`` result object.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimate for the angle :math:`\\theta`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimate for the angle :math:`\\theta`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the minimizer used for the search of the likelihood function.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='callable', ctx=Load())), FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='callable', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the number minimizer used for the search of the likelihood function.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='minimizer', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the percentage of good counts per circuit power.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='counts', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the percentage of good counts per circuit power.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=Name(id='counts', ctx=Load()))], decorator_list=[Attribute(value=Name(id='good_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the evaluation schedule for the powers of the Grover operator.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the evaluation schedule for the powers of the Grover operator.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))], decorator_list=[Attribute(value=Name(id='evaluation_schedule', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the Fisher information for the estimated amplitude.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the Fisher information for the estimated amplitude.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='fisher_information', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[]), FunctionDef(name='_safe_min', args=arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='min', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))], decorator_list=[], returns=None), FunctionDef(name='_safe_max', args=arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='max', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))], decorator_list=[], returns=None), FunctionDef(name='_compute_fisher_information', args=arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='num_sum_terms', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation result.\n        num_sum_terms: The number of sum terms to be included in the calculation of the\n            Fisher information. By default all values are included.\n        observed: If True, compute the observed Fisher information, otherwise the theoretical\n            one.\n\n    Returns:\n        The computed Fisher information, or np.inf if statevector simulation was used.\n\n    Raises:\n        KeyError: Call run() first!\n    ')), Assign(targets=[Name(id='a', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())), Assign(targets=[Name(id='theta_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='one_hits', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())), If(test=Compare(left=Name(id='num_sum_terms', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Subscript(value=Name(id='evaluation_schedule', ctx=Load()), slice=Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None)), If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='d_loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='h_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='one_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='tan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))))], orelse=[]), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Div(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))], keywords=[])), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2)), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), AugAssign(target=Name(id='fisher_information', ctx=Store()), op=Div(), value=BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))))]), Return(value=Name(id='fisher_information', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='_fisher_confint', args=arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the `alpha` confidence interval based on the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (must be <= 0.5), default to 0.05.\n        observed: If True, use observed Fisher information.\n\n    Returns:\n        float: The alpha confidence interval based on the Fisher information\n    Raises:\n        AssertionError: Call run() first!\n    ')), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None)), Try(body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[]), If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[]), Assign(targets=[Name(id='normal_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='norm', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='confint', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[]), op=Add(), right=BinOp(left=BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[])))), Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='mapped_confint', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_likelihood_ratio_confint', args=arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='nevals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=None)]), body=[Expr(value=Str(s='Compute the likelihood-ratio confidence interval.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (< 0.5), defaults to 0.05.\n        nevals: The number of evaluations to find the intersection with the loglikelihood\n            function. Defaults to an adaptive value based on the maximal power of Q.\n\n    Returns:\n        The alpha-likelihood-ratio confidence interval.\n    ')), If(test=Compare(left=Name(id='nevals', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))], orelse=[]), FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None), arg(arg='one_counts', annotation=None), arg(arg='all_counts', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=Name(id='loglik', ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Name(id='one_counts', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())), Assign(targets=[Name(id='all_counts', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15)), Assign(targets=[Name(id='thetas', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='linspace', ctx=Load()), args=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load())), Name(id='nevals', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='theta', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='values', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='loglik_mle', ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[])), Assign(targets=[Name(id='chi2_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='chi2', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=Name(id='alpha', ctx=Load()))], keywords=[keyword(arg='df', value=Num(n=1))])), Assign(targets=[Name(id='thres', ctx=Store())], value=BinOp(left=Name(id='loglik_mle', ctx=Load()), op=Sub(), right=BinOp(left=Name(id='chi2_quantile', ctx=Load()), op=Div(), right=Num(n=2)))), Assign(targets=[Name(id='above_thres', ctx=Store())], value=Subscript(value=Name(id='thetas', ctx=Load()), slice=Index(value=Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())])), ctx=Load())), Assign(targets=[Name(id='confint', ctx=Store())], value=List(elts=[Call(func=Name(id='_safe_min', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=Num(n=0))]), Call(func=Name(id='_safe_max', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))])], ctx=Load())), Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='mapped_confint', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), FunctionDef(name='_get_counts', args=arguments(args=[arg(arg='circuit_results', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the good and total counts.\n\n    Returns:\n        A pair of two lists, ([1-counts per experiment], [shots per experiment]).\n\n    Raises:\n        AlgorithmError: If self.run() has not been called yet.\n    ')), Assign(targets=[Name(id='one_hits', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='probabilities', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), For(target=Name(id='statevector', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Assign(targets=[Name(id='p_k', ctx=Store())], value=Num(n=0.0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])], orelse=[]), AugAssign(target=Name(id='probabilities', ctx=Store()), op=Add(), value=List(elts=[Name(id='p_k', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='one_hits', ctx=Store())], value=Name(id='probabilities', ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))], orelse=[For(target=Name(id='counts', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[]))], orelse=[])]), Return(value=Tuple(elts=[Name(id='one_hits', ctx=Load()), Name(id='all_hits', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))])
Expr(value=Str(s='The Maximum Likelihood Amplitude Estimation algorithm.'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Union', asname=None), alias(name='Tuple', asname=None), alias(name='Dict', asname=None), alias(name='Callable', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='scipy.optimize', names=[alias(name='brute', asname=None)], level=0)
ImportFrom(module='scipy.stats', names=[alias(name='norm', asname=None), alias(name='chi2', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='amplitude_estimator', names=[alias(name='AmplitudeEstimator', asname=None), alias(name='AmplitudeEstimatorResult', asname=None)], level=1)
ImportFrom(module='estimation_problem', names=[alias(name='EstimationProblem', asname=None)], level=1)
ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2)
Assign(targets=[Name(id='MINIMIZER', ctx=Store())], value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
ClassDef(name='MaximumLikelihoodAmplitudeEstimation', bases=[Name(id='AmplitudeEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Maximum Likelihood Amplitude Estimation algorithm.\n\n    This class implements the quantum amplitude estimation (QAE) algorithm without phase\n    estimation, as introduced in [1]. In comparison to the original QAE algorithm [2],\n    this implementation relies solely on different powers of the Grover operator and does not\n    require additional evaluation qubits.\n    Finally, the estimate is determined via a maximum likelihood estimation, which is why this\n    class in named ``MaximumLikelihoodAmplitudeEstimation``.\n\n    References:\n        [1]: Suzuki, Y., Uno, S., Raymond, R., Tanaka, T., Onodera, T., & Yamamoto, N. (2019).\n             Amplitude Estimation without Phase Estimation.\n             `arXiv:1904.10246 <https://arxiv.org/abs/1904.10246>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='minimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n                element must be non-negative. If a non-negative integer, an exponential schedule is\n                used where the highest power is 2 to the integer minus 1:\n                `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n            minimizer: A minimizer used to find the minimum of the likelihood function.\n                Defaults to a brute search where the number of evaluation points is determined\n                according to ``evaluation_schedule``. The minimizer takes a function as first\n                argument and a list of (float, float) tuples (as bounds) as second argument and\n                returns a single float which is the found minimum.\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            ValueError: If the number of oracle circuits is smaller than 1.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])))], orelse=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))]), If(test=Compare(left=Name(id='minimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), FunctionDef(name='default_minimizer', args=arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='default_minimizer', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='minimizer', ctx=Load()))])], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='construct_circuits', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the Amplitude Estimation w/o QPE quantum circuits.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\n        Returns:\n            A list with the QuantumCircuit objects for the algorithm.\n        ')), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='num_qubits', ctx=Load()), Str(s='q')], keywords=[])), Assign(targets=[Name(id='qc_0', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='qc_a'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), For(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), body=[Assign(targets=[Name(id='qc_k', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Name(id='circuits', ctx=Store()), op=Add(), value=List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='compute_confidence_interval', args=arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='kind', annotation=Name(id='str', ctx=Load())), arg(arg='apply_post_processing', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='fisher'), NameConstant(value=False)]), body=[Expr(value=Str(s="Compute the `alpha` confidence interval using the method `kind`.\n\n        The confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n        'likelihood_ratio' and 'observed_fisher' with shorthand\n        notations 'fi', 'lr' and 'oi', respectively.\n\n        Args:\n            result: A maximum likelihood amplitude estimation result.\n            alpha: The confidence level.\n            kind: The method to compute the confidence interval. Defaults to 'fisher', which\n                computes the theoretical Fisher information.\n            apply_post_processing: If True, apply post-processing to the confidence interval.\n\n        Returns:\n            The specified confidence interval.\n\n        Raises:\n            AlgorithmError: If `run()` hasn't been called yet.\n            NotImplementedError: If the method `kind` is not supported.\n        ")), Assign(targets=[Name(id='interval', ctx=Store())], value=NameConstant(value=None)), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])])]), If(test=Compare(left=Name(id='interval', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[]), cause=None)], orelse=[]), If(test=Name(id='apply_post_processing', ctx=Load()), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), Return(value=Name(id='interval', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='compute_mle', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='circuit_results', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='return_counts', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the MLE via a grid-search.\n\n        This is a stable approach if sufficient gridpoints are used.\n\n        Args:\n            circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n            estimation_problem: The estimation problem containing the evaluation schedule and the\n                number of likelihood function evaluations used to find the minimum.\n            num_state_qubits: The number of state qubits, required for statevector simulations.\n            return_counts: If True, returns the good counts.\n\n        Returns:\n            The MLE for the provided result object.\n        ')), Assign(targets=[Tuple(elts=[Name(id='good_counts', ctx=Store()), Name(id='all_counts', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_get_counts', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15)), Assign(targets=[Name(id='search_range', ctx=Store())], value=List(elts=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))], ctx=Load())), FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load())))], decorator_list=[], returns=None), Assign(targets=[Name(id='est_theta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()), args=[Name(id='loglikelihood', ctx=Load()), List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='return_counts', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='est_theta', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='minimizer', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevectors', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='statevectors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))]), Assign(targets=[Name(id='num_state_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='theta', ctx=Store()), Name(id='good_counts', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load()), NameConstant(value=True)], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Store())], value=Name(id='good_counts', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load()), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='alpha', value=Num(n=0.05)), keyword(arg='kind', value=Str(s='fisher'))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='MaximumLikelihoodAmplitudeEstimationResult'))], decorator_list=[])
ClassDef(name='MaximumLikelihoodAmplitudeEstimationResult', bases=[Name(id='AmplitudeEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The ``MaximumLikelihoodAmplitudeEstimation`` result object.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimate for the angle :math:`\\theta`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimate for the angle :math:`\\theta`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the minimizer used for the search of the likelihood function.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='callable', ctx=Load())), FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='callable', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the number minimizer used for the search of the likelihood function.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='minimizer', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the percentage of good counts per circuit power.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='counts', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the percentage of good counts per circuit power.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=Name(id='counts', ctx=Load()))], decorator_list=[Attribute(value=Name(id='good_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the evaluation schedule for the powers of the Grover operator.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the evaluation schedule for the powers of the Grover operator.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))], decorator_list=[Attribute(value=Name(id='evaluation_schedule', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the Fisher information for the estimated amplitude.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the Fisher information for the estimated amplitude.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='fisher_information', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
FunctionDef(name='_safe_min', args=arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='min', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))], decorator_list=[], returns=None)
FunctionDef(name='_safe_max', args=arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='max', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))], decorator_list=[], returns=None)
FunctionDef(name='_compute_fisher_information', args=arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='num_sum_terms', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation result.\n        num_sum_terms: The number of sum terms to be included in the calculation of the\n            Fisher information. By default all values are included.\n        observed: If True, compute the observed Fisher information, otherwise the theoretical\n            one.\n\n    Returns:\n        The computed Fisher information, or np.inf if statevector simulation was used.\n\n    Raises:\n        KeyError: Call run() first!\n    ')), Assign(targets=[Name(id='a', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())), Assign(targets=[Name(id='theta_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='one_hits', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())), If(test=Compare(left=Name(id='num_sum_terms', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Subscript(value=Name(id='evaluation_schedule', ctx=Load()), slice=Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None)), If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='d_loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='h_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='one_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='tan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))))], orelse=[]), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Div(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))], keywords=[])), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2)), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), AugAssign(target=Name(id='fisher_information', ctx=Store()), op=Div(), value=BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))))]), Return(value=Name(id='fisher_information', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load()))
FunctionDef(name='_fisher_confint', args=arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the `alpha` confidence interval based on the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (must be <= 0.5), default to 0.05.\n        observed: If True, use observed Fisher information.\n\n    Returns:\n        float: The alpha confidence interval based on the Fisher information\n    Raises:\n        AssertionError: Call run() first!\n    ')), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None)), Try(body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[]), If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[]), Assign(targets=[Name(id='normal_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='norm', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='confint', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[]), op=Add(), right=BinOp(left=BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[])))), Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='mapped_confint', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='_likelihood_ratio_confint', args=arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='nevals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=None)]), body=[Expr(value=Str(s='Compute the likelihood-ratio confidence interval.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (< 0.5), defaults to 0.05.\n        nevals: The number of evaluations to find the intersection with the loglikelihood\n            function. Defaults to an adaptive value based on the maximal power of Q.\n\n    Returns:\n        The alpha-likelihood-ratio confidence interval.\n    ')), If(test=Compare(left=Name(id='nevals', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))], orelse=[]), FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None), arg(arg='one_counts', annotation=None), arg(arg='all_counts', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=Name(id='loglik', ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Name(id='one_counts', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())), Assign(targets=[Name(id='all_counts', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15)), Assign(targets=[Name(id='thetas', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='linspace', ctx=Load()), args=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load())), Name(id='nevals', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='theta', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='values', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='loglik_mle', ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[])), Assign(targets=[Name(id='chi2_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='chi2', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=Name(id='alpha', ctx=Load()))], keywords=[keyword(arg='df', value=Num(n=1))])), Assign(targets=[Name(id='thres', ctx=Store())], value=BinOp(left=Name(id='loglik_mle', ctx=Load()), op=Sub(), right=BinOp(left=Name(id='chi2_quantile', ctx=Load()), op=Div(), right=Num(n=2)))), Assign(targets=[Name(id='above_thres', ctx=Store())], value=Subscript(value=Name(id='thetas', ctx=Load()), slice=Index(value=Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())])), ctx=Load())), Assign(targets=[Name(id='confint', ctx=Store())], value=List(elts=[Call(func=Name(id='_safe_min', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=Num(n=0))]), Call(func=Name(id='_safe_max', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))])], ctx=Load())), Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='mapped_confint', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
FunctionDef(name='_get_counts', args=arguments(args=[arg(arg='circuit_results', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the good and total counts.\n\n    Returns:\n        A pair of two lists, ([1-counts per experiment], [shots per experiment]).\n\n    Raises:\n        AlgorithmError: If self.run() has not been called yet.\n    ')), Assign(targets=[Name(id='one_hits', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='probabilities', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), For(target=Name(id='statevector', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Assign(targets=[Name(id='p_k', ctx=Store())], value=Num(n=0.0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])], orelse=[]), AugAssign(target=Name(id='probabilities', ctx=Store()), op=Add(), value=List(elts=[Name(id='p_k', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='one_hits', ctx=Store())], value=Name(id='probabilities', ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))], orelse=[For(target=Name(id='counts', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[]))], orelse=[])]), Return(value=Tuple(elts=[Name(id='one_hits', ctx=Load()), Name(id='all_hits', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='The Maximum Likelihood Amplitude Estimation algorithm.')
alias(name='Optional', asname=None)
alias(name='List', asname=None)
alias(name='Union', asname=None)
alias(name='Tuple', asname=None)
alias(name='Dict', asname=None)
alias(name='Callable', asname=None)
alias(name='numpy', asname='np')
alias(name='brute', asname=None)
alias(name='norm', asname=None)
alias(name='chi2', asname=None)
alias(name='Backend', asname=None)
alias(name='ClassicalRegister', asname=None)
alias(name='QuantumRegister', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='AmplitudeEstimator', asname=None)
alias(name='AmplitudeEstimatorResult', asname=None)
alias(name='EstimationProblem', asname=None)
alias(name='AlgorithmError', asname=None)
Name(id='MINIMIZER', ctx=Store())
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='AmplitudeEstimator', ctx=Load())
Expr(value=Str(s='The Maximum Likelihood Amplitude Estimation algorithm.\n\n    This class implements the quantum amplitude estimation (QAE) algorithm without phase\n    estimation, as introduced in [1]. In comparison to the original QAE algorithm [2],\n    this implementation relies solely on different powers of the Grover operator and does not\n    require additional evaluation qubits.\n    Finally, the estimate is determined via a maximum likelihood estimation, which is why this\n    class in named ``MaximumLikelihoodAmplitudeEstimation``.\n\n    References:\n        [1]: Suzuki, Y., Uno, S., Raymond, R., Tanaka, T., Onodera, T., & Yamamoto, N. (2019).\n             Amplitude Estimation without Phase Estimation.\n             `arXiv:1904.10246 <https://arxiv.org/abs/1904.10246>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='minimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n                element must be non-negative. If a non-negative integer, an exponential schedule is\n                used where the highest power is 2 to the integer minus 1:\n                `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n            minimizer: A minimizer used to find the minimum of the likelihood function.\n                Defaults to a brute search where the number of evaluation points is determined\n                according to ``evaluation_schedule``. The minimizer takes a function as first\n                argument and a list of (float, float) tuples (as bounds) as second argument and\n                returns a single float which is the found minimum.\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            ValueError: If the number of oracle circuits is smaller than 1.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])))], orelse=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))]), If(test=Compare(left=Name(id='minimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), FunctionDef(name='default_minimizer', args=arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='default_minimizer', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='minimizer', ctx=Load()))])], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='construct_circuits', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the Amplitude Estimation w/o QPE quantum circuits.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\n        Returns:\n            A list with the QuantumCircuit objects for the algorithm.\n        ')), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='num_qubits', ctx=Load()), Str(s='q')], keywords=[])), Assign(targets=[Name(id='qc_0', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='qc_a'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), For(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), body=[Assign(targets=[Name(id='qc_k', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Name(id='circuits', ctx=Store()), op=Add(), value=List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
FunctionDef(name='compute_confidence_interval', args=arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='kind', annotation=Name(id='str', ctx=Load())), arg(arg='apply_post_processing', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='fisher'), NameConstant(value=False)]), body=[Expr(value=Str(s="Compute the `alpha` confidence interval using the method `kind`.\n\n        The confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n        'likelihood_ratio' and 'observed_fisher' with shorthand\n        notations 'fi', 'lr' and 'oi', respectively.\n\n        Args:\n            result: A maximum likelihood amplitude estimation result.\n            alpha: The confidence level.\n            kind: The method to compute the confidence interval. Defaults to 'fisher', which\n                computes the theoretical Fisher information.\n            apply_post_processing: If True, apply post-processing to the confidence interval.\n\n        Returns:\n            The specified confidence interval.\n\n        Raises:\n            AlgorithmError: If `run()` hasn't been called yet.\n            NotImplementedError: If the method `kind` is not supported.\n        ")), Assign(targets=[Name(id='interval', ctx=Store())], value=NameConstant(value=None)), If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])])]), If(test=Compare(left=Name(id='interval', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[]), cause=None)], orelse=[]), If(test=Name(id='apply_post_processing', ctx=Load()), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[]), Return(value=Name(id='interval', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='compute_mle', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='circuit_results', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='return_counts', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s='Compute the MLE via a grid-search.\n\n        This is a stable approach if sufficient gridpoints are used.\n\n        Args:\n            circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n            estimation_problem: The estimation problem containing the evaluation schedule and the\n                number of likelihood function evaluations used to find the minimum.\n            num_state_qubits: The number of state qubits, required for statevector simulations.\n            return_counts: If True, returns the good counts.\n\n        Returns:\n            The MLE for the provided result object.\n        ')), Assign(targets=[Tuple(elts=[Name(id='good_counts', ctx=Store()), Name(id='all_counts', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_get_counts', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15)), Assign(targets=[Name(id='search_range', ctx=Store())], value=List(elts=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))], ctx=Load())), FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load())))], decorator_list=[], returns=None), Assign(targets=[Name(id='est_theta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()), args=[Name(id='loglikelihood', ctx=Load()), List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())], keywords=[])), If(test=Name(id='return_counts', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='est_theta', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='minimizer', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevectors', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='statevectors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))]), Assign(targets=[Name(id='num_state_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='theta', ctx=Store()), Name(id='good_counts', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load()), NameConstant(value=True)], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Store())], value=Name(id='good_counts', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load()), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='alpha', value=Num(n=0.05)), keyword(arg='kind', value=Str(s='fisher'))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='MaximumLikelihoodAmplitudeEstimationResult'))
Name(id='AmplitudeEstimatorResult', ctx=Load())
Expr(value=Str(s='The ``MaximumLikelihoodAmplitudeEstimation`` result object.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimate for the angle :math:`\\theta`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='theta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimate for the angle :math:`\\theta`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the minimizer used for the search of the likelihood function.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='callable', ctx=Load()))
FunctionDef(name='minimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='callable', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the number minimizer used for the search of the likelihood function.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='minimizer', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the percentage of good counts per circuit power.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
FunctionDef(name='good_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='counts', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the percentage of good counts per circuit power.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=Name(id='counts', ctx=Load()))], decorator_list=[Attribute(value=Name(id='good_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the evaluation schedule for the powers of the Grover operator.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
FunctionDef(name='evaluation_schedule', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the evaluation schedule for the powers of the Grover operator.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))], decorator_list=[Attribute(value=Name(id='evaluation_schedule', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the Fisher information for the estimated amplitude.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='fisher_information', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the Fisher information for the estimated amplitude.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='fisher_information', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0)])
If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[])
Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='min', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))
arguments(args=[arg(arg='array', annotation=None), arg(arg='default', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))])
If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Name(id='default', ctx=Load()))], orelse=[])
Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='max', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]))
arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='num_sum_terms', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)])
Expr(value=Str(s='Compute the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation result.\n        num_sum_terms: The number of sum terms to be included in the calculation of the\n            Fisher information. By default all values are included.\n        observed: If True, compute the observed Fisher information, otherwise the theoretical\n            one.\n\n    Returns:\n        The computed Fisher information, or np.inf if statevector simulation was used.\n\n    Raises:\n        KeyError: Call run() first!\n    '))
Assign(targets=[Name(id='a', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load()))
Assign(targets=[Name(id='theta_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='one_hits', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load()))
Assign(targets=[Name(id='all_hits', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()))
If(test=Compare(left=Name(id='num_sum_terms', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Subscript(value=Name(id='evaluation_schedule', ctx=Load()), slice=Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None), ctx=Load()))], orelse=[])
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None))
If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='d_loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='h_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='one_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='tan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))))], orelse=[]), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Div(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))], keywords=[])), Assign(targets=[Name(id='fisher_information', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2)), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])), AugAssign(target=Name(id='fisher_information', ctx=Store()), op=Div(), value=BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))))])
Return(value=Name(id='fisher_information', ctx=Load()))
Name(id='float', ctx=Load())
arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='observed', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=False)])
Expr(value=Str(s='Compute the `alpha` confidence interval based on the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (must be <= 0.5), default to 0.05.\n        observed: If True, use observed Fisher information.\n\n    Returns:\n        float: The alpha confidence interval based on the Fisher information\n    Raises:\n        AssertionError: Call run() first!\n    '))
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=NameConstant(value=None))
Try(body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])
If(test=Name(id='observed', ctx=Load()), body=[Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])
Assign(targets=[Name(id='normal_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='norm', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))], keywords=[]))
Assign(targets=[Name(id='confint', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[]), op=Add(), right=BinOp(left=BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[]))))
Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Return(value=Name(id='mapped_confint', ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='nevals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.05), NameConstant(value=None)])
Expr(value=Str(s='Compute the likelihood-ratio confidence interval.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (< 0.5), defaults to 0.05.\n        nevals: The number of evaluations to find the intersection with the loglikelihood\n            function. Defaults to an adaptive value based on the maximal power of Q.\n\n    Returns:\n        The alpha-likelihood-ratio confidence interval.\n    '))
If(test=Compare(left=Name(id='nevals', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))], orelse=[])
FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None), arg(arg='one_counts', annotation=None), arg(arg='all_counts', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=Name(id='loglik', ctx=Load()))], decorator_list=[], returns=None)
Assign(targets=[Name(id='one_counts', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load()))
Assign(targets=[Name(id='all_counts', ctx=Store())], value=BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15))
Assign(targets=[Name(id='thetas', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='linspace', ctx=Load()), args=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load())), Name(id='nevals', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])], keywords=[]))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='theta', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[]), body=[Assign(targets=[Subscript(value=Name(id='values', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='loglik_mle', ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='chi2_quantile', ctx=Store())], value=Call(func=Attribute(value=Name(id='chi2', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=Name(id='alpha', ctx=Load()))], keywords=[keyword(arg='df', value=Num(n=1))]))
Assign(targets=[Name(id='thres', ctx=Store())], value=BinOp(left=Name(id='loglik_mle', ctx=Load()), op=Sub(), right=BinOp(left=Name(id='chi2_quantile', ctx=Load()), op=Div(), right=Num(n=2))))
Assign(targets=[Name(id='above_thres', ctx=Store())], value=Subscript(value=Name(id='thetas', ctx=Load()), slice=Index(value=Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())])), ctx=Load()))
Assign(targets=[Name(id='confint', ctx=Store())], value=List(elts=[Call(func=Name(id='_safe_min', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=Num(n=0))]), Call(func=Name(id='_safe_max', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))])], ctx=Load()))
Assign(targets=[Name(id='mapped_confint', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Return(value=Name(id='mapped_confint', ctx=Load()))
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='circuit_results', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the good and total counts.\n\n    Returns:\n        A pair of two lists, ([1-counts per experiment], [shots per experiment]).\n\n    Raises:\n        AlgorithmError: If self.run() has not been called yet.\n    '))
Assign(targets=[Name(id='one_hits', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='all_hits', ctx=Store())], value=List(elts=[], ctx=Load()))
If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='probabilities', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), For(target=Name(id='statevector', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Assign(targets=[Name(id='p_k', ctx=Store())], value=Num(n=0.0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])], orelse=[]), AugAssign(target=Name(id='probabilities', ctx=Store()), op=Add(), value=List(elts=[Name(id='p_k', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='one_hits', ctx=Store())], value=Name(id='probabilities', ctx=Load())), Assign(targets=[Name(id='all_hits', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))], orelse=[For(target=Name(id='counts', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[]))], orelse=[])])
Return(value=Tuple(elts=[Name(id='one_hits', ctx=Load()), Name(id='all_hits', ctx=Load())], ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Store()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Load()
Str(s='The Maximum Likelihood Amplitude Estimation algorithm.\n\n    This class implements the quantum amplitude estimation (QAE) algorithm without phase\n    estimation, as introduced in [1]. In comparison to the original QAE algorithm [2],\n    this implementation relies solely on different powers of the Grover operator and does not\n    require additional evaluation qubits.\n    Finally, the estimate is determined via a maximum likelihood estimation, which is why this\n    class in named ``MaximumLikelihoodAmplitudeEstimation``.\n\n    References:\n        [1]: Suzuki, Y., Uno, S., Raymond, R., Tanaka, T., Onodera, T., & Yamamoto, N. (2019).\n             Amplitude Estimation without Phase Estimation.\n             `arXiv:1904.10246 <https://arxiv.org/abs/1904.10246>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='minimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='\n        Args:\n            evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n                element must be non-negative. If a non-negative integer, an exponential schedule is\n                used where the highest power is 2 to the integer minus 1:\n                `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n            minimizer: A minimizer used to find the minimum of the likelihood function.\n                Defaults to a brute search where the number of evaluation points is determined\n                according to ``evaluation_schedule``. The minimizer takes a function as first\n                argument and a list of (float, float) tuples (as bounds) as second argument and\n                returns a single float which is the found minimum.\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            ValueError: If the number of oracle circuits is smaller than 1.\n        '))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])))], orelse=[If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))])
If(test=Compare(left=Name(id='minimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), FunctionDef(name='default_minimizer', args=arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))], decorator_list=[], returns=None), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='default_minimizer', ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='minimizer', ctx=Load()))])
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)])
Expr(value=Str(s='Construct the Amplitude Estimation w/o QPE quantum circuits.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\n        Returns:\n            A list with the QuantumCircuit objects for the algorithm.\n        '))
Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='q', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='num_qubits', ctx=Load()), Str(s='q')], keywords=[]))
Assign(targets=[Name(id='qc_0', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='qc_a'))]))
If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
For(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), body=[Assign(targets=[Name(id='qc_k', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), AugAssign(target=Name(id='circuits', ctx=Store()), op=Add(), value=List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='circuits', ctx=Load()))
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult')), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='kind', annotation=Name(id='str', ctx=Load())), arg(arg='apply_post_processing', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='fisher'), NameConstant(value=False)])
Expr(value=Str(s="Compute the `alpha` confidence interval using the method `kind`.\n\n        The confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n        'likelihood_ratio' and 'observed_fisher' with shorthand\n        notations 'fi', 'lr' and 'oi', respectively.\n\n        Args:\n            result: A maximum likelihood amplitude estimation result.\n            alpha: The confidence level.\n            kind: The method to compute the confidence interval. Defaults to 'fisher', which\n                computes the theoretical Fisher information.\n            apply_post_processing: If True, apply post-processing to the confidence interval.\n\n        Returns:\n            The specified confidence interval.\n\n        Raises:\n            AlgorithmError: If `run()` hasn't been called yet.\n            NotImplementedError: If the method `kind` is not supported.\n        "))
Assign(targets=[Name(id='interval', ctx=Store())], value=NameConstant(value=None))
If(test=Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])])])
If(test=Compare(left=Name(id='interval', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[]), cause=None)], orelse=[])
If(test=Name(id='apply_post_processing', ctx=Load()), body=[Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))], orelse=[])
Return(value=Name(id='interval', ctx=Load()))
Name(id='staticmethod', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='circuit_results', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='num_state_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='return_counts', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)])
Expr(value=Str(s='Compute the MLE via a grid-search.\n\n        This is a stable approach if sufficient gridpoints are used.\n\n        Args:\n            circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n            estimation_problem: The estimation problem containing the evaluation schedule and the\n                number of likelihood function evaluations used to find the minimum.\n            num_state_qubits: The number of state qubits, required for statevector simulations.\n            return_counts: If True, returns the good counts.\n\n        Returns:\n            The MLE for the provided result object.\n        '))
Assign(targets=[Tuple(elts=[Name(id='good_counts', ctx=Store()), Name(id='all_counts', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_get_counts', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='eps', ctx=Store())], value=Num(n=1e-15))
Assign(targets=[Name(id='search_range', ctx=Store())], value=List(elts=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))], ctx=Load()))
FunctionDef(name='loglikelihood', args=arguments(args=[arg(arg='theta', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[]), Return(value=UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load())))], decorator_list=[], returns=None)
Assign(targets=[Name(id='est_theta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()), args=[Name(id='loglikelihood', ctx=Load()), List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())], keywords=[]))
If(test=Name(id='return_counts', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='est_theta', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=Compare(left=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='minimizer', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevectors', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='statevectors', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))])
Assign(targets=[Name(id='num_state_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load())))
Assign(targets=[Tuple(elts=[Name(id='theta', ctx=Store()), Name(id='good_counts', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load()), NameConstant(value=True)], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Store())], value=Name(id='theta', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Store())], value=Name(id='good_counts', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load()), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))
Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='alpha', value=Num(n=0.05)), keyword(arg='kind', value=Str(s='fisher'))]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Return(value=Name(id='result', ctx=Load()))
Str(s='MaximumLikelihoodAmplitudeEstimationResult')
Load()
Str(s='The ``MaximumLikelihoodAmplitudeEstimation`` result object.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the estimate for the angle :math:`\\theta`.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the estimate for the angle :math:`\\theta`.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='theta', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the minimizer used for the search of the likelihood function.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='callable', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='callable', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the number minimizer used for the search of the likelihood function.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='minimizer', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the percentage of good counts per circuit power.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='counts', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the percentage of good counts per circuit power.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())], value=Name(id='counts', ctx=Load()))
Attribute(value=Name(id='good_counts', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the evaluation schedule for the powers of the Grover operator.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the evaluation schedule for the powers of the Grover operator.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))
Attribute(value=Name(id='evaluation_schedule', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the Fisher information for the estimated amplitude.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the Fisher information for the estimated amplitude.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='fisher_information', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arg(arg='array', annotation=None)
arg(arg='default', annotation=None)
Num(n=0)
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)])
Return(value=Name(id='default', ctx=Load()))
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='min', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[])
arg(arg='array', annotation=None)
arg(arg='default', annotation=None)
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Num(n=0)])
Return(value=Name(id='default', ctx=Load()))
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='max', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[])
arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult'))
arg(arg='num_sum_terms', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
arg(arg='observed', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=None)
NameConstant(value=False)
Str(s='Compute the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation result.\n        num_sum_terms: The number of sum terms to be included in the calculation of the\n            Fisher information. By default all values are included.\n        observed: If True, compute the observed Fisher information, otherwise the theoretical\n            one.\n\n    Returns:\n        The computed Fisher information, or np.inf if statevector simulation was used.\n\n    Raises:\n        KeyError: Call run() first!\n    ')
Name(id='a', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())
Name(id='theta_a', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='one_hits', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())
Name(id='all_hits', ctx=Store())
BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))
Name(id='evaluation_schedule', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())
Compare(left=Name(id='num_sum_terms', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='evaluation_schedule', ctx=Store())], value=Subscript(value=Name(id='evaluation_schedule', ctx=Load()), slice=Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None), ctx=Load()))
Name(id='fisher_information', ctx=Store())
NameConstant(value=None)
Name(id='observed', ctx=Load())
Assign(targets=[Name(id='d_loglik', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='h_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='one_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='tan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[])), AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))))], orelse=[])
AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Div(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))], keywords=[]))
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2)), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[]))
AugAssign(target=Name(id='fisher_information', ctx=Store()), op=Div(), value=BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))))
Name(id='fisher_information', ctx=Load())
Load()
arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
arg(arg='observed', annotation=Name(id='bool', ctx=Load()))
Num(n=0.05)
NameConstant(value=False)
Str(s='Compute the `alpha` confidence interval based on the Fisher information.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (must be <= 0.5), default to 0.05.\n        observed: If True, use observed Fisher information.\n\n    Returns:\n        float: The alpha confidence interval based on the Fisher information\n    Raises:\n        AssertionError: Call run() first!\n    ')
Name(id='fisher_information', ctx=Store())
NameConstant(value=None)
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Load()))
ExceptHandler(type=Name(id='KeyError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[]), cause=Name(id='ex', ctx=Load()))])
Name(id='observed', ctx=Load())
Assign(targets=[Name(id='fisher_information', ctx=Store())], value=Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))
Name(id='normal_quantile', ctx=Store())
Call(func=Attribute(value=Name(id='norm', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))], keywords=[])
Name(id='confint', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[]), op=Add(), right=BinOp(left=BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[])))
Name(id='mapped_confint', ctx=Store())
Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Name(id='mapped_confint', ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='result', annotation=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
arg(arg='nevals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Num(n=0.05)
NameConstant(value=None)
Str(s='Compute the likelihood-ratio confidence interval.\n\n    Args:\n        result: A maximum likelihood amplitude estimation results object.\n        alpha: The level of the confidence interval (< 0.5), defaults to 0.05.\n        nevals: The number of evaluations to find the intersection with the loglikelihood\n            function. Defaults to an adaptive value based on the maximal power of Q.\n\n    Returns:\n        The alpha-likelihood-ratio confidence interval.\n    ')
Compare(left=Name(id='nevals', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))
arguments(args=[arg(arg='theta', annotation=None), arg(arg='one_counts', annotation=None), arg(arg='all_counts', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[])
Return(value=Name(id='loglik', ctx=Load()))
Name(id='one_counts', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Load())
Name(id='all_counts', ctx=Store())
BinOp(left=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]))
Name(id='eps', ctx=Store())
Num(n=1e-15)
Name(id='thetas', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='linspace', ctx=Load()), args=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load())), Name(id='nevals', ctx=Load())], keywords=[])
Name(id='values', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])], keywords=[])
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='theta', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])
Assign(targets=[Subscript(value=Name(id='values', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())], value=Call(func=Name(id='loglikelihood', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[]))
Name(id='loglik_mle', ctx=Store())
Call(func=Name(id='loglikelihood', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[])
Name(id='chi2_quantile', ctx=Store())
Call(func=Attribute(value=Name(id='chi2', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=Name(id='alpha', ctx=Load()))], keywords=[keyword(arg='df', value=Num(n=1))])
Name(id='thres', ctx=Store())
BinOp(left=Name(id='loglik_mle', ctx=Load()), op=Sub(), right=BinOp(left=Name(id='chi2_quantile', ctx=Load()), op=Div(), right=Num(n=2)))
Name(id='above_thres', ctx=Store())
Subscript(value=Name(id='thetas', ctx=Load()), slice=Index(value=Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())])), ctx=Load())
Name(id='confint', ctx=Store())
List(elts=[Call(func=Name(id='_safe_min', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=Num(n=0))]), Call(func=Name(id='_safe_max', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))])], ctx=Load())
Name(id='mapped_confint', ctx=Store())
Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Name(id='mapped_confint', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
arg(arg='circuit_results', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))
Str(s='Get the good and total counts.\n\n    Returns:\n        A pair of two lists, ([1-counts per experiment], [shots per experiment]).\n\n    Raises:\n        AlgorithmError: If self.run() has not been called yet.\n    ')
Name(id='one_hits', ctx=Store())
List(elts=[], ctx=Load())
Name(id='all_hits', ctx=Store())
List(elts=[], ctx=Load())
Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Assign(targets=[Name(id='probabilities', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
For(target=Name(id='statevector', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Assign(targets=[Name(id='p_k', ctx=Store())], value=Num(n=0.0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])], orelse=[]), AugAssign(target=Name(id='probabilities', ctx=Store()), op=Add(), value=List(elts=[Name(id='p_k', ctx=Load())], ctx=Load()))], orelse=[])
Assign(targets=[Name(id='one_hits', ctx=Store())], value=Name(id='probabilities', ctx=Load()))
Assign(targets=[Name(id='all_hits', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[]))
For(target=Name(id='counts', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[]))], orelse=[])
Tuple(elts=[Name(id='one_hits', ctx=Load()), Name(id='all_hits', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
arg(arg='self', annotation=None)
arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='minimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
Str(s='\n        Args:\n            evaluation_schedule: If a list, the powers applied to the Grover operator. The list\n                element must be non-negative. If a non-negative integer, an exponential schedule is\n                used where the highest power is 2 to the integer minus 1:\n                `[id, Q^2^0, ..., Q^2^(evaluation_schedule-1)]`.\n            minimizer: A minimizer used to find the minimum of the likelihood function.\n                Defaults to a brute search where the number of evaluation points is determined\n                according to ``evaluation_schedule``. The minimizer takes a function as first\n                argument and a list of (float, float) tuples (as bounds) as second argument and\n                returns a single float which is the found minimum.\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            ValueError: If the number of oracle circuits is smaller than 1.\n        ')
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load()), Name(id='int', ctx=Load())], keywords=[])
If(test=Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])))
If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())], value=Name(id='evaluation_schedule', ctx=Load()))
Compare(left=Name(id='minimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='nevals', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))
FunctionDef(name='default_minimizer', args=arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))], decorator_list=[], returns=None)
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='default_minimizer', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())], value=Name(id='minimizer', ctx=Load()))
arg(arg='self', annotation=None)
Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=False)
Str(s='Construct the Amplitude Estimation w/o QPE quantum circuits.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            measurement: Boolean flag to indicate if measurement should be included in the circuits.\n\n        Returns:\n            A list with the QuantumCircuit objects for the algorithm.\n        ')
Name(id='circuits', ctx=Store())
List(elts=[], ctx=Load())
Name(id='num_qubits', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Name(id='q', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='num_qubits', ctx=Load()), Str(s='q')], keywords=[])
Name(id='qc_0', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='q', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='qc_a'))])
Name(id='measurement', ctx=Load())
Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Name(id='k', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())
Assign(targets=[Name(id='qc_k', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))]))
If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[])
If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[])
AugAssign(target=Name(id='circuits', ctx=Store()), op=Add(), value=List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load()))
Name(id='circuits', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
arg(arg='result', annotation=Str(s='MaximumLikelihoodAmplitudeEstimationResult'))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
arg(arg='kind', annotation=Name(id='str', ctx=Load()))
arg(arg='apply_post_processing', annotation=Name(id='bool', ctx=Load()))
Str(s='fisher')
NameConstant(value=False)
Str(s="Compute the `alpha` confidence interval using the method `kind`.\n\n        The confidence level is (1 - `alpha`) and supported kinds are 'fisher',\n        'likelihood_ratio' and 'observed_fisher' with shorthand\n        notations 'fi', 'lr' and 'oi', respectively.\n\n        Args:\n            result: A maximum likelihood amplitude estimation result.\n            alpha: The confidence level.\n            kind: The method to compute the confidence interval. Defaults to 'fisher', which\n                computes the theoretical Fisher information.\n            apply_post_processing: If True, apply post-processing to the confidence interval.\n\n        Returns:\n            The specified confidence interval.\n\n        Raises:\n            AlgorithmError: If `run()` hasn't been called yet.\n            NotImplementedError: If the method `kind` is not supported.\n        ")
Name(id='interval', ctx=Store())
NameConstant(value=None)
Call(func=Name(id='all', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Assign(targets=[Name(id='interval', ctx=Store())], value=BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())))
If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])])
Compare(left=Name(id='interval', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[]), cause=None)
Name(id='apply_post_processing', ctx=Load())
Return(value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Name(id='interval', ctx=Load())
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='circuit_results', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
arg(arg='num_state_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
arg(arg='return_counts', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=None)
NameConstant(value=False)
Str(s='Compute the MLE via a grid-search.\n\n        This is a stable approach if sufficient gridpoints are used.\n\n        Args:\n            circuit_results: A list of circuit outcomes. Can be counts or statevectors.\n            estimation_problem: The estimation problem containing the evaluation schedule and the\n                number of likelihood function evaluations used to find the minimum.\n            num_state_qubits: The number of state qubits, required for statevector simulations.\n            return_counts: If True, returns the good counts.\n\n        Returns:\n            The MLE for the provided result object.\n        ')
Tuple(elts=[Name(id='good_counts', ctx=Store()), Name(id='all_counts', ctx=Store())], ctx=Store())
Call(func=Name(id='_get_counts', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load())], keywords=[])
Name(id='eps', ctx=Store())
Num(n=1e-15)
Name(id='search_range', ctx=Store())
List(elts=[BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load())), BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))], ctx=Load())
arguments(args=[arg(arg='theta', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='loglik', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))), AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))], orelse=[])
Return(value=UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load())))
Name(id='est_theta', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load()), args=[Name(id='loglikelihood', ctx=Load()), List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())], keywords=[])
Name(id='return_counts', ctx=Load())
Return(value=Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load()))
Name(id='est_theta', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
Compare(left=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[]), cause=None)
Name(id='result', ctx=Store())
Call(func=Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='minimizer', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))]))
Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='statevectors', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='statevectors', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Num(n=1))
Assign(targets=[Name(id='circuits', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))]))
Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))
Name(id='num_state_qubits', ctx=Store())
BinOp(left=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load()))
Tuple(elts=[Name(id='theta', ctx=Store()), Name(id='good_counts', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), Name(id='estimation_problem', ctx=Load()), Name(id='num_state_qubits', ctx=Load()), NameConstant(value=True)], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Store())
Name(id='theta', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='good_counts', ctx=Store())
Name(id='good_counts', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Store())
Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())
BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load()), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Name(id='confidence_interval', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='alpha', value=Num(n=0.05)), keyword(arg='kind', value=Str(s='fisher'))])
Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())
Name(id='confidence_interval', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())
Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Name(id='result', ctx=Load())
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='Return the estimate for the angle :math:`\\theta`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the estimate for the angle :math:`\\theta`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_theta', ctx=Store())
Name(id='value', ctx=Load())
Name(id='theta', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the minimizer used for the search of the likelihood function.')
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='callable', ctx=Load()))
Str(s='Set the number minimizer used for the search of the likelihood function.')
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())
Name(id='value', ctx=Load())
Name(id='minimizer', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the percentage of good counts per circuit power.')
Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='counts', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Str(s='Set the percentage of good counts per circuit power.')
Attribute(value=Name(id='self', ctx=Load()), attr='_good_counts', ctx=Store())
Name(id='counts', ctx=Load())
Name(id='good_counts', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the evaluation schedule for the powers of the Grover operator.')
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='evaluation_schedule', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Str(s='Set the evaluation schedule for the powers of the Grover operator.')
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())
Name(id='evaluation_schedule', ctx=Load())
Name(id='evaluation_schedule', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the Fisher information for the estimated amplitude.')
Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the Fisher information for the estimated amplitude.')
Attribute(value=Name(id='self', ctx=Load()), attr='_fisher_information', ctx=Store())
Name(id='value', ctx=Load())
Name(id='fisher_information', ctx=Load())
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[])
Eq()
Num(n=0)
Name(id='default', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='min', ctx=Load())
Name(id='array', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Call(func=Name(id='len', ctx=Load()), args=[Name(id='array', ctx=Load())], keywords=[])
Eq()
Num(n=0)
Name(id='default', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='max', ctx=Load())
Name(id='array', ctx=Load())
Str(s='MaximumLikelihoodAmplitudeEstimationResult')
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Store()
Name(id='result', ctx=Load())
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])
Store()
Name(id='result', ctx=Load())
Load()
Store()
List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load())
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[])
Store()
Name(id='result', ctx=Load())
Load()
Name(id='num_sum_terms', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='evaluation_schedule', ctx=Store())
Subscript(value=Name(id='evaluation_schedule', ctx=Load()), slice=Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None), ctx=Load())
Store()
Load()
Name(id='d_loglik', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='h_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='one_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[])
Assign(targets=[Name(id='tan', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[]))
AugAssign(target=Name(id='d_loglik', ctx=Store()), op=Add(), value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))))
Name(id='d_loglik', ctx=Store())
Div()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))], keywords=[])
Name(id='fisher_information', ctx=Store())
BinOp(left=BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2)), op=Div(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[]))
Name(id='fisher_information', ctx=Store())
Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])], keywords=[])
Name(id='fisher_information', ctx=Store())
Div()
BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))
Load()
Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())
Name(id='float', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Name(id='fisher_information', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='fisher_information', ctx=Load())
Name(id='KeyError', ctx=Load())
Raise(exc=Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[]), cause=Name(id='ex', ctx=Load()))
Load()
Name(id='fisher_information', ctx=Store())
Call(func=Name(id='_compute_fisher_information', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))])
Store()
Attribute(value=Name(id='norm', ctx=Load()), attr='ppf', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], keywords=[])
Add()
BinOp(left=BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[]))
Store()
Name(id='tuple', ctx=Load())
GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())
Name(id='float', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='nevals', ctx=Load())
Is()
NameConstant(value=None)
Name(id='nevals', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])
arg(arg='theta', annotation=None)
arg(arg='one_counts', annotation=None)
arg(arg='all_counts', annotation=None)
Name(id='loglik', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())], keywords=[])
AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())))
AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))
Name(id='loglik', ctx=Load())
Store()
Name(id='result', ctx=Load())
Load()
Store()
List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())], ctx=Load())
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])
Store()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='linspace', ctx=Load())
BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load()))
BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))
Name(id='nevals', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='thetas', ctx=Load())], keywords=[])
Name(id='i', ctx=Store())
Name(id='theta', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='thetas', ctx=Load())
Subscript(value=Name(id='values', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())
Call(func=Name(id='loglikelihood', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='one_counts', ctx=Load()), Name(id='all_counts', ctx=Load())], keywords=[])
Store()
Name(id='loglikelihood', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())
Name(id='one_counts', ctx=Load())
Name(id='all_counts', ctx=Load())
Store()
Attribute(value=Name(id='chi2', ctx=Load()), attr='ppf', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=Name(id='alpha', ctx=Load()))
keyword(arg='df', value=Num(n=1))
Store()
Name(id='loglik_mle', ctx=Load())
Sub()
BinOp(left=Name(id='chi2_quantile', ctx=Load()), op=Div(), right=Num(n=2))
Store()
Name(id='thetas', ctx=Load())
Index(value=Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())]))
Load()
Store()
Call(func=Name(id='_safe_min', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=Num(n=0))])
Call(func=Name(id='_safe_max', ctx=Load()), args=[Name(id='above_thres', ctx=Load())], keywords=[keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))])
Load()
Store()
Name(id='tuple', ctx=Load())
GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), generators=[comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)])
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='EstimationProblem', ctx=Load())
Name(id='int', ctx=Load())
Store()
Load()
Store()
Load()
Name(id='all', ctx=Load())
GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)])
Name(id='probabilities', ctx=Store())
List(elts=[], ctx=Load())
Name(id='num_qubits', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='statevector', ctx=Store())
Name(id='circuit_results', ctx=Load())
Assign(targets=[Name(id='p_k', ctx=Store())], value=Num(n=0.0))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])], orelse=[])
AugAssign(target=Name(id='probabilities', ctx=Store()), op=Add(), value=List(elts=[Name(id='p_k', ctx=Load())], ctx=Load()))
Name(id='one_hits', ctx=Store())
Name(id='probabilities', ctx=Load())
Name(id='all_hits', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load()), args=[Name(id='one_hits', ctx=Load())], keywords=[])
Name(id='counts', ctx=Store())
Name(id='circuit_results', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[]))
Name(id='one_hits', ctx=Load())
Name(id='all_hits', ctx=Load())
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())], ctx=Load())
List(elts=[Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())], ctx=Load())
Name(id='float', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='MINIMIZER', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='isinstance', ctx=Load())
Name(id='evaluation_schedule', ctx=Load())
Name(id='int', ctx=Load())
Compare(left=Name(id='evaluation_schedule', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[]), cause=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())
BinOp(left=List(elts=[Num(n=0)], ctx=Load()), op=Add(), right=ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))
Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[]), cause=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Store())
Name(id='evaluation_schedule', ctx=Load())
Name(id='minimizer', ctx=Load())
Is()
NameConstant(value=None)
Name(id='nevals', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Num(n=10000), Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])
arguments(args=[arg(arg='objective_fn', annotation=None), arg(arg='bounds', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Return(value=Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())
Name(id='default_minimizer', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Store())
Name(id='minimizer', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='EstimationProblem', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Load()
Store()
Name(id='max', ctx=Load())
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load())
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='num_qubits', ctx=Load())
Str(s='q')
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='q', ctx=Load())
keyword(arg='name', value=Str(s='qc_a'))
Load()
Name(id='c', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])
Attribute(value=Name(id='qc_0', ctx=Load()), attr='compose', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())
keyword(arg='inplace', value=NameConstant(value=True))
Store()
Name(id='self', ctx=Load())
Load()
Name(id='qc_k', ctx=Store())
Call(func=Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load()), args=[], keywords=[keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))])
Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
Name(id='measurement', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))
Name(id='circuits', ctx=Store())
Add()
List(elts=[Name(id='qc_k', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Str(s='MaximumLikelihoodAmplitudeEstimationResult')
Name(id='float', ctx=Load())
Name(id='str', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Name(id='all', ctx=Load())
GeneratorExp(elt=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)])
Name(id='interval', ctx=Store())
BinOp(left=Num(n=2), op=Mult(), right=List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load()))
Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())])
Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))], orelse=[If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])])
Name(id='interval', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])], keywords=[])
Load()
Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Name(id='EstimationProblem', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Name(id='good_counts', ctx=Store())
Name(id='all_counts', ctx=Store())
Store()
Name(id='_get_counts', ctx=Load())
Name(id='circuit_results', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Name(id='num_state_qubits', ctx=Load())
Store()
Store()
BinOp(left=Num(n=0), op=Add(), right=Name(id='eps', ctx=Load()))
BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Sub(), right=Name(id='eps', ctx=Load()))
Load()
arg(arg='theta', annotation=None)
Name(id='loglik', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='k', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())], keywords=[])
Assign(targets=[Name(id='angle', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load())))
AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())))
AugAssign(target=Name(id='loglik', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))))
UnaryOp(op=USub(), operand=Name(id='loglik', ctx=Load()))
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_minimizer', ctx=Load())
Name(id='loglikelihood', ctx=Load())
List(elts=[Name(id='search_range', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='est_theta', ctx=Load()), Name(id='good_counts', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Name(id='EstimationProblem', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')], keywords=[])
Store()
Name(id='MaximumLikelihoodAmplitudeEstimationResult', ctx=Load())
Name(id='result', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Name(id='estimation_problem', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='circuits', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])
Name(id='ret', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])
Name(id='statevectors', ctx=Store())
ListComp(elt=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])
Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())
Name(id='statevectors', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())
Num(n=1)
Name(id='circuits', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])
Name(id='ret', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuits', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())
ListComp(elt=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)])
Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Store())
Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())
Store()
Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_qubits', ctx=Load())
Sub()
Attribute(value=Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='num_ancillas', ctx=Load())
Name(id='theta', ctx=Store())
Name(id='good_counts', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='compute_mle', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Name(id='num_state_qubits', ctx=Load())
NameConstant(value=True)
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())
Name(id='result', ctx=Load())
Store()
Name(id='_compute_fisher_information', ctx=Load())
Name(id='result', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())
Mult()
Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='compute_confidence_interval', ctx=Load())
Name(id='result', ctx=Load())
keyword(arg='alpha', value=Num(n=0.05))
keyword(arg='kind', value=Str(s='fisher'))
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Name(id='tuple', ctx=Load())
GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])
Load()
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='callable', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='len', ctx=Load())
Name(id='array', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='array', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='one_hits', ctx=Load())
Load()
Load()
Store()
Name(id='evaluation_schedule', ctx=Load())
Slice(lower=None, upper=Name(id='num_sum_terms', ctx=Load()), step=None)
Load()
Store()
Name(id='shots_k', ctx=Store())
Name(id='h_k', ctx=Store())
Name(id='m_k', ctx=Store())
Store()
Name(id='zip', ctx=Load())
Name(id='all_hits', ctx=Load())
Name(id='one_hits', ctx=Load())
Name(id='evaluation_schedule', ctx=Load())
Name(id='tan', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))], keywords=[])
Name(id='d_loglik', ctx=Store())
Add()
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load()))))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load())))
Store()
BinOp(left=Name(id='d_loglik', ctx=Load()), op=Pow(), right=Num(n=2))
Div()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='all_hits', ctx=Load())], keywords=[])
Store()
Name(id='sum', ctx=Load())
GeneratorExp(elt=BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))), generators=[comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])
Store()
Name(id='a', ctx=Load())
Mult()
BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))
Load()
Load()
Load()
Store()
Name(id='result', ctx=Load())
Load()
Load()
Call(func=Name(id='AssertionError', ctx=Load()), args=[Str(s='Call run() first!')], keywords=[])
Name(id='ex', ctx=Load())
Store()
Name(id='_compute_fisher_information', ctx=Load())
Name(id='result', ctx=Load())
keyword(arg='observed', value=NameConstant(value=True))
Name(id='norm', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())
BinOp(left=Name(id='normal_quantile', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[]))
Mult()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())], keywords=[])
Load()
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[])
comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Store()
Name(id='max', ctx=Load())
Num(n=10000)
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])
Store()
Name(id='i', ctx=Store())
Name(id='k', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())
Name(id='loglik', ctx=Store())
Add()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Name(id='loglik', ctx=Store())
Add()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())))
Load()
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='shots', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='one_counts', ctx=Load())
Name(id='np', ctx=Load())
Load()
Num(n=0)
Add()
Name(id='eps', ctx=Load())
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Sub()
Name(id='eps', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='thetas', ctx=Load())
Store()
Store()
Load()
Load()
Name(id='values', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Store()
Name(id='loglikelihood', ctx=Load())
Name(id='theta', ctx=Load())
Name(id='one_counts', ctx=Load())
Name(id='all_counts', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Name(id='chi2', ctx=Load())
Load()
Num(n=1)
Sub()
Name(id='alpha', ctx=Load())
Num(n=1)
Load()
Name(id='chi2_quantile', ctx=Load())
Div()
Num(n=2)
Load()
Compare(left=Name(id='values', ctx=Load()), ops=[GtE()], comparators=[Name(id='thres', ctx=Load())])
Name(id='_safe_min', ctx=Load())
Name(id='above_thres', ctx=Load())
keyword(arg='default', value=Num(n=0))
Name(id='_safe_max', ctx=Load())
Name(id='above_thres', ctx=Load())
keyword(arg='default', value=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)))
Load()
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[])
comprehension(target=Name(id='bound', ctx=Store()), iter=Name(id='confint', ctx=Load()), ifs=[], is_async=0)
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[])
comprehension(target=Name(id='data', ctx=Store()), iter=Name(id='circuit_results', ctx=Load()), ifs=[], is_async=0)
Store()
Load()
Store()
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])
Store()
Load()
Name(id='p_k', ctx=Store())
Num(n=0.0)
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])
Assign(targets=[Name(id='probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)))
Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)]))
If(test=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))], orelse=[])
Name(id='probabilities', ctx=Store())
Add()
List(elts=[Name(id='p_k', ctx=Load())], ctx=Load())
Store()
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='ones_like', ctx=Load())
Name(id='one_hits', ctx=Load())
Store()
Load()
Call(func=Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])], keywords=[])
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='MINIMIZER', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Name(id='evaluation_schedule', ctx=Load())
Lt()
Num(n=0)
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The evaluation schedule cannot be < 0.')], keywords=[])
Name(id='self', ctx=Load())
Store()
List(elts=[Num(n=0)], ctx=Load())
Add()
ListComp(elt=BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load())), generators=[comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)])
Name(id='any', ctx=Load())
GeneratorExp(elt=Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The elements of the evaluation schedule cannot be < 0.')], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Store()
Name(id='max', ctx=Load())
Num(n=10000)
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))], keywords=[])
arg(arg='objective_fn', annotation=None)
arg(arg='bounds', annotation=None)
Subscript(value=Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))]), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Str(s='qc_a')
Store()
Name(id='ClassicalRegister', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])
Attribute(value=Name(id='qc_0', ctx=Load()), attr='add_register', ctx=Load())
Name(id='c', ctx=Load())
Name(id='qc_0', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
NameConstant(value=True)
Load()
Store()
Attribute(value=Name(id='qc_0', ctx=Load()), attr='copy', ctx=Load())
keyword(arg='name', value=BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load())))
Name(id='k', ctx=Load())
NotEq()
Num(n=0)
Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Load()
Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])
Store()
Name(id='qc_k', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='data', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[])
comprehension(target=Name(id='data', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load()), ifs=[], is_async=0)
Store()
Num(n=2)
Mult()
List(elts=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())], ctx=Load())
Name(id='kind', ctx=Load())
In()
List(elts=[Str(s='likelihood_ratio'), Str(s='lr')], ctx=Load())
Name(id='interval', ctx=Store())
Call(func=Name(id='_likelihood_ratio_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[])
Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())])
Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))]))
If(test=Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())]), body=[Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))], orelse=[])
Load()
Name(id='NotImplementedError', ctx=Load())
JoinedStr(values=[Str(s='CI `'), FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None), Str(s='` is not implemented.')])
Name(id='tuple', ctx=Load())
GeneratorExp(elt=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)])
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Store()
Store()
Load()
Load()
Load()
Load()
Num(n=0)
Add()
Name(id='eps', ctx=Load())
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Sub()
Name(id='eps', ctx=Load())
Store()
Name(id='i', ctx=Store())
Name(id='k', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())
Name(id='angle', ctx=Store())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))
Name(id='loglik', ctx=Store())
Add()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Name(id='loglik', ctx=Store())
Add()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[]), op=Mult(), right=BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())))
USub()
Name(id='loglik', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Name(id='search_range', ctx=Load())
Load()
Name(id='est_theta', ctx=Load())
Name(id='good_counts', ctx=Load())
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='Either the state_preparation variable or the a_factory (deprecated) must be set to run the algorithm.')
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load())
Name(id='estimation_problem', ctx=Load())
keyword(arg='measurement', value=NameConstant(value=False))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuits', ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[])
comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuits', ctx=Load())
Name(id='estimation_problem', ctx=Load())
keyword(arg='measurement', value=NameConstant(value=True))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuits', ctx=Load())
Name(id='result', ctx=Load())
Store()
Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
comprehension(target=Name(id='circuit', ctx=Store()), iter=Name(id='circuits', ctx=Load()), ifs=[], is_async=0)
Name(id='result', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load())
Load()
Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Subscript(value=Name(id='circuits', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='theta', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='result', ctx=Load())
Load()
Name(id='sum', ctx=Load())
GeneratorExp(elt=Name(id='k', ctx=Load()), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)])
Name(id='self', ctx=Load())
Load()
Load()
Num(n=0.05)
Str(s='fisher')
Load()
Load()
Load()
Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])
comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Name(id='a', ctx=Load())
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='num_sum_terms', ctx=Load())
Store()
Store()
Store()
Load()
Load()
Load()
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='tan', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta_a', ctx=Load()))
Store()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1))
Mult()
BinOp(left=BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load())), op=Add(), right=BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load())))
Name(id='np', ctx=Load())
Load()
Name(id='a', ctx=Load())
Mult()
BinOp(left=Num(n=1), op=Sub(), right=Name(id='a', ctx=Load()))
Name(id='d_loglik', ctx=Load())
Pow()
Num(n=2)
Name(id='len', ctx=Load())
Name(id='all_hits', ctx=Load())
Load()
BinOp(left=Name(id='shots_k', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2)))
comprehension(target=Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)
Load()
Num(n=1)
Sub()
Name(id='a', ctx=Load())
Load()
Name(id='AssertionError', ctx=Load())
Str(s='Call run() first!')
Load()
Load()
Load()
NameConstant(value=True)
Load()
Name(id='alpha', ctx=Load())
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Name(id='normal_quantile', ctx=Load())
Div()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='fisher_information', ctx=Load())], keywords=[])
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
List(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Num(n=1)], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='bound', ctx=Load())
Name(id='bound', ctx=Store())
Name(id='confint', ctx=Load())
Load()
Load()
Load()
Name(id='int', ctx=Load())
Load()
Name(id='int', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Store()
Store()
Load()
Name(id='result', ctx=Load())
Load()
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[])
Mult()
Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[])
Mult()
BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Load()
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='values', ctx=Load())
GtE()
Name(id='thres', ctx=Load())
Load()
Load()
Num(n=0)
Load()
Load()
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='bound', ctx=Store())
Name(id='confint', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='data', ctx=Load())
Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Name(id='data', ctx=Store())
Name(id='circuit_results', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Store()
Name(id='i', ctx=Store())
Name(id='amplitude', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='statevector', ctx=Load())
Name(id='probability', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='bitstr', ctx=Store())
Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Name(id='objectives', ctx=Store())
ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])
Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[])
AugAssign(target=Name(id='p_k', ctx=Store()), op=Add(), value=Name(id='probability', ctx=Load()))
Store()
Name(id='p_k', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Name(id='all_hits', ctx=Load()), attr='append', ctx=Load())
Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])
Attribute(value=Name(id='one_hits', ctx=Load()), attr='append', ctx=Load())
Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])], keywords=[])
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
Name(id='MINIMIZER', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Load()
Name(id='ValueError', ctx=Load())
Str(s='The evaluation schedule cannot be < 0.')
Load()
Num(n=0)
Load()
BinOp(left=Num(n=2), op=Pow(), right=Name(id='j', ctx=Load()))
comprehension(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[]), ifs=[], is_async=0)
Load()
Compare(left=Name(id='value', ctx=Load()), ops=[Lt()], comparators=[Num(n=0)])
comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)
Name(id='ValueError', ctx=Load())
Str(s='The elements of the evaluation schedule cannot be < 0.')
Load()
Load()
Name(id='int', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2)), op=Mult(), right=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Call(func=Name(id='brute', ctx=Load()), args=[Name(id='objective_fn', ctx=Load()), Name(id='bounds', ctx=Load())], keywords=[keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))])
Index(value=Num(n=0))
Load()
Load()
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Name(id='len', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='qc_0', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='qc_0', ctx=Load())
Load()
BinOp(left=Str(s='qc_a_q_%s'), op=Mod(), right=Name(id='k', ctx=Load()))
Load()
Attribute(value=Name(id='qc_k', ctx=Load()), attr='compose', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])
keyword(arg='inplace', value=NameConstant(value=True))
Attribute(value=Name(id='qc_k', ctx=Load()), attr='barrier', ctx=Load())
Attribute(value=Name(id='qc_k', ctx=Load()), attr='measure', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Load()
Name(id='isinstance', ctx=Load())
Name(id='data', ctx=Load())
Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Name(id='data', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Load())
Load()
Load()
Str(s='likelihood_ratio')
Str(s='lr')
Load()
Store()
Name(id='_likelihood_ratio_confint', ctx=Load())
Name(id='result', ctx=Load())
Name(id='alpha', ctx=Load())
Name(id='kind', ctx=Load())
In()
List(elts=[Str(s='fisher'), Str(s='fi')], ctx=Load())
Name(id='interval', ctx=Store())
Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=False))])
Compare(left=Name(id='kind', ctx=Load()), ops=[In()], comparators=[List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())])
Assign(targets=[Name(id='interval', ctx=Store())], value=Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))]))
Load()
Str(s='CI `')
FormattedValue(value=Name(id='kind', ctx=Load()), conversion=-1, format_spec=None)
Str(s='` is not implemented.')
Load()
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='value', ctx=Load())], keywords=[])
comprehension(target=Name(id='value', ctx=Store()), iter=Name(id='interval', ctx=Load()), ifs=[], is_async=0)
Load()
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Load()
Store()
Store()
Load()
Name(id='self', ctx=Load())
Load()
Store()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1))
Mult()
Name(id='theta', ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[])
Mult()
Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))], keywords=[])
Mult()
BinOp(left=Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
NameConstant(value=False)
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='asarray', ctx=Load())
Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='circuit', ctx=Store())
Name(id='circuits', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load())
Name(id='circuit', ctx=Load())
Name(id='circuit', ctx=Store())
Name(id='circuits', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='circuits', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='circuits', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='k', ctx=Load())
comprehension(target=Name(id='k', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), ifs=[], is_async=0)
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='value', ctx=Load())
Name(id='value', ctx=Store())
Name(id='confidence_interval', ctx=Load())
Name(id='super', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1))
Mult()
Name(id='theta_a', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load()))
Add()
Num(n=1)
BinOp(left=Name(id='h_k', ctx=Load()), op=Div(), right=Name(id='tan', ctx=Load()))
Add()
BinOp(left=BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load())), op=Mult(), right=Name(id='tan', ctx=Load()))
Load()
Load()
Num(n=1)
Sub()
Name(id='a', ctx=Load())
Load()
Load()
Load()
Name(id='shots_k', ctx=Load())
Mult()
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1)), op=Pow(), right=Num(n=2))
Tuple(elts=[Name(id='shots_k', ctx=Store()), Name(id='m_k', ctx=Store())], ctx=Store())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='all_hits', ctx=Load()), Name(id='evaluation_schedule', ctx=Load())], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
Name(id='fisher_information', ctx=Load())
Name(id='np', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Num(n=1)
Load()
Name(id='result', ctx=Load())
Load()
Load()
Store()
Load()
Load()
Load()
BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2))
Mult()
Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='one_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))
Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Sub()
Subscript(value=Name(id='one_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Name(id='result', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='bound', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Store()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Name(id='list', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Store()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Subscript(value=Name(id='circuit_results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Store()
Store()
Load()
Load()
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Store()
Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load())
Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Store()
Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load())
comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load())
Name(id='objectives', ctx=Load())
Name(id='p_k', ctx=Store())
Add()
Name(id='probability', ctx=Load())
Load()
Load()
Name(id='all_hits', ctx=Load())
Load()
Name(id='sum', ctx=Load())
Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])
Name(id='one_hits', ctx=Load())
Load()
Name(id='sum', ctx=Load())
GeneratorExp(elt=Name(id='count', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)])
Load()
Name(id='float', ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Tuple(elts=[List(elts=[Name(id='float', ctx=Load())], ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Load()
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='int', ctx=Load())
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Num(n=2)
Pow()
Name(id='j', ctx=Load())
Name(id='j', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='evaluation_schedule', ctx=Load())], keywords=[])
Name(id='value', ctx=Load())
Lt()
Num(n=0)
Name(id='value', ctx=Store())
Name(id='evaluation_schedule', ctx=Load())
Load()
Load()
BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000)), op=Mult(), right=Num(n=2))
Mult()
Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Name(id='brute', ctx=Load())
Name(id='objective_fn', ctx=Load())
Name(id='bounds', ctx=Load())
keyword(arg='Ns', value=Name(id='nevals', ctx=Load()))
Num(n=0)
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Load()
Str(s='qc_a_q_%s')
Mod()
Name(id='k', ctx=Load())
Name(id='qc_k', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load())
Name(id='k', ctx=Load())
NameConstant(value=True)
Name(id='qc_k', ctx=Load())
Load()
Name(id='qc_k', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='c', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Load()
Name(id='list', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Store()
Name(id='result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Str(s='fisher')
Str(s='fi')
Load()
Store()
Name(id='_fisher_confint', ctx=Load())
Name(id='result', ctx=Load())
Name(id='alpha', ctx=Load())
keyword(arg='observed', value=NameConstant(value=False))
Name(id='kind', ctx=Load())
In()
List(elts=[Str(s='observed_fisher'), Str(s='observed_information'), Str(s='oi')], ctx=Load())
Name(id='interval', ctx=Store())
Call(func=Name(id='_fisher_confint', ctx=Load()), args=[Name(id='result', ctx=Load()), Name(id='alpha', ctx=Load())], keywords=[keyword(arg='observed', value=NameConstant(value=True))])
Name(id='kind', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='value', ctx=Load())
Name(id='value', ctx=Store())
Name(id='interval', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load()))
Add()
Num(n=1)
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='good_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Subscript(value=Name(id='all_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Sub()
Subscript(value=Name(id='good_counts', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='ret', ctx=Load())
Load()
Load()
Store()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Num(n=0)
Load()
Num(n=0)
Load()
Load()
Load()
Name(id='k', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Store()
Load()
Load()
Load()
Load()
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load()))
Add()
Num(n=1)
Load()
Num(n=2)
Mult()
Name(id='m_k', ctx=Load())
Name(id='h_k', ctx=Load())
Div()
Name(id='tan', ctx=Load())
BinOp(left=Name(id='shots_k', ctx=Load()), op=Sub(), right=Name(id='h_k', ctx=Load()))
Mult()
Name(id='tan', ctx=Load())
Load()
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load())), op=Add(), right=Num(n=1))
Pow()
Num(n=2)
Name(id='shots_k', ctx=Store())
Name(id='m_k', ctx=Store())
Store()
Name(id='zip', ctx=Load())
Name(id='all_hits', ctx=Load())
Name(id='evaluation_schedule', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Load()
USub()
Num(n=1)
Load()
BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000))
Mult()
Num(n=2)
Attribute(value=Name(id='result', ctx=Load()), attr='evaluation_schedule', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[])
Pow()
Num(n=2)
Load()
Name(id='i', ctx=Load())
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))], keywords=[])
Pow()
Num(n=2)
Name(id='all_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='one_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
Name(id='bound', ctx=Load())
Load()
Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='circuit_results', ctx=Load())
Index(value=Num(n=0))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Name(id='amplitude', ctx=Load())
Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[])
Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None)
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='bitstr', ctx=Load())
Index(value=Name(id='index', ctx=Load()))
Load()
Name(id='index', ctx=Store())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Store()
Load()
Load()
Load()
Attribute(value=Name(id='counts', ctx=Load()), attr='values', ctx=Load())
Load()
Load()
Name(id='count', ctx=Load())
comprehension(target=Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])], is_async=0)
Load()
Load()
List(elts=[Name(id='float', ctx=Load())], ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Store()
Name(id='range', ctx=Load())
Name(id='evaluation_schedule', ctx=Load())
Load()
Store()
Load()
BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Mult(), right=Num(n=1000))
Mult()
Num(n=2)
Attribute(value=Name(id='self', ctx=Load()), attr='_evaluation_schedule', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Load()
Load()
Load()
Name(id='nevals', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
NameConstant(value=False)
Load()
Str(s='observed_fisher')
Str(s='observed_information')
Str(s='oi')
Load()
Store()
Name(id='_fisher_confint', ctx=Load())
Name(id='result', ctx=Load())
Name(id='alpha', ctx=Load())
keyword(arg='observed', value=NameConstant(value=True))
Load()
Name(id='result', ctx=Load())
Load()
Load()
Store()
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
Load()
Num(n=2)
Mult()
Name(id='k', ctx=Load())
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Load()
Name(id='i', ctx=Load())
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load()), args=[Name(id='angle', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Name(id='all_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='good_counts', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Load()
Load()
Name(id='ret', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Store()
Name(id='result', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Name(id='m_k', ctx=Load())
Load()
Load()
Load()
Name(id='shots_k', ctx=Load())
Sub()
Name(id='h_k', ctx=Load())
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='m_k', ctx=Load()))
Add()
Num(n=1)
Store()
Store()
Load()
Load()
Load()
Load()
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Mult()
Num(n=1000)
Name(id='result', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1)), op=Mult(), right=Name(id='theta', ctx=Load()))
Load()
Name(id='i', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Num(n=0)
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load())
Name(id='num_qubits', ctx=Load())
UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load()))
USub()
Num(n=1)
Load()
Name(id='index', ctx=Load())
Store()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Name(id='counts', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='bitstr', ctx=Store()), Name(id='count', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='bitstr', ctx=Load())], keywords=[])
Name(id='float', ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Mult()
Num(n=1000)
Name(id='self', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Load()
Load()
Load()
NameConstant(value=True)
Load()
Load()
Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
Name(id='angle', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='cos', ctx=Load())
Name(id='angle', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='m_k', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Load()
USub()
Num(n=1)
Name(id='np', ctx=Load())
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1))
Mult()
Name(id='theta', ctx=Load())
Name(id='np', ctx=Load())
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=1))
Mult()
Name(id='theta', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='Dict', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Load()
Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())
Load()
Load()
USub()
Name(id='num_state_qubits', ctx=Load())
Load()
Load()
Load()
Name(id='bitstr', ctx=Store())
Name(id='count', ctx=Store())
Store()
Attribute(value=Name(id='counts', ctx=Load()), attr='items', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='is_good_state', ctx=Load())
Name(id='bitstr', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Load()
USub()
Num(n=1)
Load()
Name(id='Dict', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load()))
Add()
Num(n=1)
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='k', ctx=Load()))
Add()
Num(n=1)
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])
Slice(lower=Num(n=2), upper=None, step=None)
Load()
Load()
Store()
Store()
Name(id='counts', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='k', ctx=Load())
Num(n=2)
Mult()
Name(id='k', ctx=Load())
Load()
Name(id='str', ctx=Load())
Name(id='int', ctx=Load())
Load()
Name(id='bin', ctx=Load())
Name(id='i', ctx=Load())
Num(n=2)
Load()
Load()
Load()
Name(id='str', ctx=Load())
Name(id='int', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
  metric  value
0     NC      2
DONE!
