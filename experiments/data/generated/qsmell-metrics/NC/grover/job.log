Python 3.7.8
Module(body=[Expr(value=Str(s="Grover's search algorithm.")), Import(names=[alias(name='itertools', asname=None)]), Import(names=[alias(name='operator', asname=None)]), ImportFrom(module='typing', names=[alias(name='Iterator', asname=None), alias(name='List', asname=None), alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.quantum_info', names=[alias(name='partial_trace', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='amplification_problem', names=[alias(name='AmplificationProblem', asname=None)], level=1), ImportFrom(module='amplitude_amplifier', names=[alias(name='AmplitudeAmplifier', asname=None), alias(name='AmplitudeAmplifierResult', asname=None)], level=1), ClassDef(name='Grover', bases=[Name(id='AmplitudeAmplifier', ctx=Load())], keywords=[], body=[Expr(value=Str(s="Grover's Search algorithm.\n\n    .. note::\n\n        If you want to learn more about the theory behind Grover's Search algorithm, check\n        out the `Qiskit Textbook <https://qiskit.org/textbook/ch-algorithms/grover.html>`_.\n        or the `Qiskit Tutorials\n        <https://qiskit.org/documentation/tutorials/algorithms/07_grover_examples.html>`_\n        for more concrete how-to examples.\n\n    Grover's Search [1, 2] is a well known quantum algorithm that can be used for\n    searching through unstructured collections of records for particular targets\n    with quadratic speedup compared to classical algorithms.\n\n    Given a set :math:`X` of :math:`N` elements :math:`X=\\{x_1,x_2,\\ldots,x_N\\}`\n    and a boolean function :math:`f : X \\rightarrow \\{0,1\\}`, the goal of an\n    unstructured-search problem is to find an element :math:`x^* \\in X` such\n    that :math:`f(x^*)=1`.\n\n    The search is called *unstructured* because there are no guarantees as to how\n    the database is ordered.  On a sorted database, for instance, one could perform\n    binary search to find an element in :math:`\\mathbb{O}(\\log N)` worst-case time.\n    Instead, in an unstructured-search problem, there is no prior knowledge about\n    the contents of the database. With classical circuits, there is no alternative\n    but to perform a linear number of queries to find the target element.\n    Conversely, Grover's Search algorithm allows to solve the unstructured-search\n    problem on a quantum computer in :math:`\\mathcal{O}(\\sqrt{N})` queries.\n\n    To carry out this search a so-called oracle is required, that flags a good element/state.\n    The action of the oracle :math:`\\mathcal{S}_f` is\n\n    .. math::\n\n        \\mathcal{S}_f |x\\rangle = (-1)^{f(x)} |x\\rangle,\n\n    i.e. it flips the phase of the state :math:`|x\\rangle` if :math:`x` is a hit.\n    The details of how :math:`S_f` works are unimportant to the algorithm; Grover's\n    search algorithm treats the oracle as a black box.\n\n    This class supports oracles in form of a :class:`~qiskit.circuit.QuantumCircuit`.\n\n    With the given oracle, Grover's Search constructs the Grover operator to amplify the\n    amplitudes of the good states:\n\n    .. math::\n\n        \\mathcal{Q} = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n} \\mathcal{S}_f\n                    = D \\mathcal{S}_f,\n\n    where :math:`\\mathcal{S}_0` flips the phase of the all-zero state and acts as identity\n    on all other states. Sometimes the first three operands are summarized as diffusion operator,\n    which implements a reflection over the equal superposition state.\n\n    If the number of solutions is known, we can calculate how often :math:`\\mathcal{Q}` should be\n    applied to find a solution with very high probability, see the method\n    `optimal_num_iterations`. If the number of solutions is unknown, the algorithm tries different\n    powers of Grover's operator, see the `iterations` argument, and after each iteration checks\n    if a good state has been measured using `good_state`.\n\n    The generalization of Grover's Search, Quantum Amplitude Amplification [3], uses a modified\n    version of :math:`\\mathcal{Q}` where the diffusion operator does not reflect about the\n    equal superposition state, but another state specified via an operator :math:`\\mathcal{A}`:\n\n    .. math::\n\n        \\mathcal{Q} = \\mathcal{A} \\mathcal{S}_0 \\mathcal{A}^\\dagger \\mathcal{S}_f.\n\n    For more information, see the :class:`~qiskit.circuit.library.GroverOperator` in the\n    circuit library.\n\n    References:\n        [1]: L. K. Grover (1996), A fast quantum mechanical algorithm for database search,\n            `arXiv:quant-ph/9605043 <https://arxiv.org/abs/quant-ph/9605043>`_.\n        [2]: I. Chuang & M. Nielsen, Quantum Computation and Quantum Information,\n            Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.\n        [3]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n            Quantum Amplitude Amplification and Estimation.\n            `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='growth_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='sample_from_iterations', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            iterations: Specify the number of iterations/power of Grover's operator to be checked.\n                * If an int, only one circuit is run with that power of the Grover operator.\n                If the number of solutions is known, this option should be used with the optimal\n                power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n                * If a list, all the powers in the list are run in the specified order.\n                * If an iterator, the powers yielded by the iterator are checked, until a maximum\n                number of iterations or maximum power is reached.\n                * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n                and circuits are run until that good state is reached.\n            growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n                i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n                number of iterations is reached.\n            sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n                powers of the Grover operator, a random integer sample between 0 and smaller value\n                than the iteration is used as a power, see [1], Section 4.\n            quantum_instance: A Quantum Instance or Backend to run the circuits.\n\n        Raises:\n            ValueError: If ``growth_rate`` is a float but not larger than 1.\n            ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\n        References:\n            [1]: Boyer et al., Tight bounds on quantum searching\n                 `<https://arxiv.org/abs/quant-ph/9605034>`_\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='growth_rate', ctx=Store())], value=Num(n=1.2))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Store())], value=Name(id='sample_from_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Store())], value=Name(id='iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='amplify', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='amplification_problem', annotation=Name(id='AmplificationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the Grover algorithm.\n\n        Args:\n            amplification_problem: The amplification problem.\n\n        Returns:\n            The result as a ``GroverResult``, where e.g. the most likely state can be queried\n            as ``result.top_measurement``.\n\n        Raises:\n            TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n            is ``None`` or a ``list``)\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load())), Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='iterator', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='GroverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iterations', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=BinOp(left=Str(s='0'), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='all_circuit_results', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_probability', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=0)), For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='max_iterations', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())]), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load()), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))]), Expr(value=Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None)), Break()], orelse=[]), If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)]), body=[Break()], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='top_measurement', ctx=Store())], value=Name(id='top_measurement', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='assignment', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='oracle_evaluation', ctx=Store())], value=Name(id='oracle_evaluation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='all_circuit_results', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='max_probability', ctx=Store())], value=Name(id='max_probability', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='GroverResult')), FunctionDef(name='optimal_num_iterations', args=arguments(args=[arg(arg='num_solutions', annotation=Name(id='int', ctx=Load())), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Return the optimal number of iterations, if the number of solutions is known.\n\n        Args:\n            num_solutions: The number of solutions.\n            num_qubits: The number of qubits used to encode the states.\n\n        Returns:\n            The optimal number of iterations for Grover's algorithm to succeed.\n        ")), Assign(targets=[Name(id='amplitude', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))], keywords=[])), Return(value=Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='AmplificationProblem', ctx=Load())), arg(arg='power', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s="Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\n        Args:\n            problem: The amplification problem for the algorithm.\n            power: The number of times the Grover operator is repeated. If None, this argument\n                is set to the first item in ``iterations``.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\n        Raises:\n            ValueError: If no power is passed and the iterations are not an integer.\n        ")), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='power', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='Grover circuit'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='measurement_cr', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))], decorator_list=[]), ClassDef(name='GroverResult', bases=[Name(id='AmplitudeAmplifierResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Grover Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_results', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_shots', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='All the powers of the Grover operator that have been tried.\n\n        Returns:\n            The powers of the Grover operator tested.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator that have been tried.\n\n        Args:\n            value: A new value for the powers.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])])
Expr(value=Str(s="Grover's search algorithm."))
Import(names=[alias(name='itertools', asname=None)])
Import(names=[alias(name='operator', asname=None)])
ImportFrom(module='typing', names=[alias(name='Iterator', asname=None), alias(name='List', asname=None), alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.quantum_info', names=[alias(name='partial_trace', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='amplification_problem', names=[alias(name='AmplificationProblem', asname=None)], level=1)
ImportFrom(module='amplitude_amplifier', names=[alias(name='AmplitudeAmplifier', asname=None), alias(name='AmplitudeAmplifierResult', asname=None)], level=1)
ClassDef(name='Grover', bases=[Name(id='AmplitudeAmplifier', ctx=Load())], keywords=[], body=[Expr(value=Str(s="Grover's Search algorithm.\n\n    .. note::\n\n        If you want to learn more about the theory behind Grover's Search algorithm, check\n        out the `Qiskit Textbook <https://qiskit.org/textbook/ch-algorithms/grover.html>`_.\n        or the `Qiskit Tutorials\n        <https://qiskit.org/documentation/tutorials/algorithms/07_grover_examples.html>`_\n        for more concrete how-to examples.\n\n    Grover's Search [1, 2] is a well known quantum algorithm that can be used for\n    searching through unstructured collections of records for particular targets\n    with quadratic speedup compared to classical algorithms.\n\n    Given a set :math:`X` of :math:`N` elements :math:`X=\\{x_1,x_2,\\ldots,x_N\\}`\n    and a boolean function :math:`f : X \\rightarrow \\{0,1\\}`, the goal of an\n    unstructured-search problem is to find an element :math:`x^* \\in X` such\n    that :math:`f(x^*)=1`.\n\n    The search is called *unstructured* because there are no guarantees as to how\n    the database is ordered.  On a sorted database, for instance, one could perform\n    binary search to find an element in :math:`\\mathbb{O}(\\log N)` worst-case time.\n    Instead, in an unstructured-search problem, there is no prior knowledge about\n    the contents of the database. With classical circuits, there is no alternative\n    but to perform a linear number of queries to find the target element.\n    Conversely, Grover's Search algorithm allows to solve the unstructured-search\n    problem on a quantum computer in :math:`\\mathcal{O}(\\sqrt{N})` queries.\n\n    To carry out this search a so-called oracle is required, that flags a good element/state.\n    The action of the oracle :math:`\\mathcal{S}_f` is\n\n    .. math::\n\n        \\mathcal{S}_f |x\\rangle = (-1)^{f(x)} |x\\rangle,\n\n    i.e. it flips the phase of the state :math:`|x\\rangle` if :math:`x` is a hit.\n    The details of how :math:`S_f` works are unimportant to the algorithm; Grover's\n    search algorithm treats the oracle as a black box.\n\n    This class supports oracles in form of a :class:`~qiskit.circuit.QuantumCircuit`.\n\n    With the given oracle, Grover's Search constructs the Grover operator to amplify the\n    amplitudes of the good states:\n\n    .. math::\n\n        \\mathcal{Q} = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n} \\mathcal{S}_f\n                    = D \\mathcal{S}_f,\n\n    where :math:`\\mathcal{S}_0` flips the phase of the all-zero state and acts as identity\n    on all other states. Sometimes the first three operands are summarized as diffusion operator,\n    which implements a reflection over the equal superposition state.\n\n    If the number of solutions is known, we can calculate how often :math:`\\mathcal{Q}` should be\n    applied to find a solution with very high probability, see the method\n    `optimal_num_iterations`. If the number of solutions is unknown, the algorithm tries different\n    powers of Grover's operator, see the `iterations` argument, and after each iteration checks\n    if a good state has been measured using `good_state`.\n\n    The generalization of Grover's Search, Quantum Amplitude Amplification [3], uses a modified\n    version of :math:`\\mathcal{Q}` where the diffusion operator does not reflect about the\n    equal superposition state, but another state specified via an operator :math:`\\mathcal{A}`:\n\n    .. math::\n\n        \\mathcal{Q} = \\mathcal{A} \\mathcal{S}_0 \\mathcal{A}^\\dagger \\mathcal{S}_f.\n\n    For more information, see the :class:`~qiskit.circuit.library.GroverOperator` in the\n    circuit library.\n\n    References:\n        [1]: L. K. Grover (1996), A fast quantum mechanical algorithm for database search,\n            `arXiv:quant-ph/9605043 <https://arxiv.org/abs/quant-ph/9605043>`_.\n        [2]: I. Chuang & M. Nielsen, Quantum Computation and Quantum Information,\n            Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.\n        [3]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n            Quantum Amplitude Amplification and Estimation.\n            `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='growth_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='sample_from_iterations', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            iterations: Specify the number of iterations/power of Grover's operator to be checked.\n                * If an int, only one circuit is run with that power of the Grover operator.\n                If the number of solutions is known, this option should be used with the optimal\n                power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n                * If a list, all the powers in the list are run in the specified order.\n                * If an iterator, the powers yielded by the iterator are checked, until a maximum\n                number of iterations or maximum power is reached.\n                * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n                and circuits are run until that good state is reached.\n            growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n                i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n                number of iterations is reached.\n            sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n                powers of the Grover operator, a random integer sample between 0 and smaller value\n                than the iteration is used as a power, see [1], Section 4.\n            quantum_instance: A Quantum Instance or Backend to run the circuits.\n\n        Raises:\n            ValueError: If ``growth_rate`` is a float but not larger than 1.\n            ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\n        References:\n            [1]: Boyer et al., Tight bounds on quantum searching\n                 `<https://arxiv.org/abs/quant-ph/9605034>`_\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='growth_rate', ctx=Store())], value=Num(n=1.2))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Store())], value=Name(id='sample_from_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Store())], value=Name(id='iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='amplify', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='amplification_problem', annotation=Name(id='AmplificationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the Grover algorithm.\n\n        Args:\n            amplification_problem: The amplification problem.\n\n        Returns:\n            The result as a ``GroverResult``, where e.g. the most likely state can be queried\n            as ``result.top_measurement``.\n\n        Raises:\n            TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n            is ``None`` or a ``list``)\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load())), Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='iterator', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='GroverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iterations', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=BinOp(left=Str(s='0'), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='all_circuit_results', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_probability', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=0)), For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='max_iterations', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())]), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load()), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))]), Expr(value=Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None)), Break()], orelse=[]), If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)]), body=[Break()], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='top_measurement', ctx=Store())], value=Name(id='top_measurement', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='assignment', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='oracle_evaluation', ctx=Store())], value=Name(id='oracle_evaluation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='all_circuit_results', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='max_probability', ctx=Store())], value=Name(id='max_probability', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='GroverResult')), FunctionDef(name='optimal_num_iterations', args=arguments(args=[arg(arg='num_solutions', annotation=Name(id='int', ctx=Load())), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Return the optimal number of iterations, if the number of solutions is known.\n\n        Args:\n            num_solutions: The number of solutions.\n            num_qubits: The number of qubits used to encode the states.\n\n        Returns:\n            The optimal number of iterations for Grover's algorithm to succeed.\n        ")), Assign(targets=[Name(id='amplitude', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))], keywords=[])), Return(value=Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='AmplificationProblem', ctx=Load())), arg(arg='power', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s="Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\n        Args:\n            problem: The amplification problem for the algorithm.\n            power: The number of times the Grover operator is repeated. If None, this argument\n                is set to the first item in ``iterations``.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\n        Raises:\n            ValueError: If no power is passed and the iterations are not an integer.\n        ")), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='power', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='Grover circuit'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='measurement_cr', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))], decorator_list=[])
ClassDef(name='GroverResult', bases=[Name(id='AmplitudeAmplifierResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Grover Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_results', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_shots', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='All the powers of the Grover operator that have been tried.\n\n        Returns:\n            The powers of the Grover operator tested.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator that have been tried.\n\n        Args:\n            value: A new value for the powers.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
Str(s="Grover's search algorithm.")
alias(name='itertools', asname=None)
alias(name='operator', asname=None)
alias(name='Iterator', asname=None)
alias(name='List', asname=None)
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='numpy', asname='np')
alias(name='ClassicalRegister', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='Backend', asname=None)
alias(name='partial_trace', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='AmplificationProblem', asname=None)
alias(name='AmplitudeAmplifier', asname=None)
alias(name='AmplitudeAmplifierResult', asname=None)
Name(id='AmplitudeAmplifier', ctx=Load())
Expr(value=Str(s="Grover's Search algorithm.\n\n    .. note::\n\n        If you want to learn more about the theory behind Grover's Search algorithm, check\n        out the `Qiskit Textbook <https://qiskit.org/textbook/ch-algorithms/grover.html>`_.\n        or the `Qiskit Tutorials\n        <https://qiskit.org/documentation/tutorials/algorithms/07_grover_examples.html>`_\n        for more concrete how-to examples.\n\n    Grover's Search [1, 2] is a well known quantum algorithm that can be used for\n    searching through unstructured collections of records for particular targets\n    with quadratic speedup compared to classical algorithms.\n\n    Given a set :math:`X` of :math:`N` elements :math:`X=\\{x_1,x_2,\\ldots,x_N\\}`\n    and a boolean function :math:`f : X \\rightarrow \\{0,1\\}`, the goal of an\n    unstructured-search problem is to find an element :math:`x^* \\in X` such\n    that :math:`f(x^*)=1`.\n\n    The search is called *unstructured* because there are no guarantees as to how\n    the database is ordered.  On a sorted database, for instance, one could perform\n    binary search to find an element in :math:`\\mathbb{O}(\\log N)` worst-case time.\n    Instead, in an unstructured-search problem, there is no prior knowledge about\n    the contents of the database. With classical circuits, there is no alternative\n    but to perform a linear number of queries to find the target element.\n    Conversely, Grover's Search algorithm allows to solve the unstructured-search\n    problem on a quantum computer in :math:`\\mathcal{O}(\\sqrt{N})` queries.\n\n    To carry out this search a so-called oracle is required, that flags a good element/state.\n    The action of the oracle :math:`\\mathcal{S}_f` is\n\n    .. math::\n\n        \\mathcal{S}_f |x\\rangle = (-1)^{f(x)} |x\\rangle,\n\n    i.e. it flips the phase of the state :math:`|x\\rangle` if :math:`x` is a hit.\n    The details of how :math:`S_f` works are unimportant to the algorithm; Grover's\n    search algorithm treats the oracle as a black box.\n\n    This class supports oracles in form of a :class:`~qiskit.circuit.QuantumCircuit`.\n\n    With the given oracle, Grover's Search constructs the Grover operator to amplify the\n    amplitudes of the good states:\n\n    .. math::\n\n        \\mathcal{Q} = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n} \\mathcal{S}_f\n                    = D \\mathcal{S}_f,\n\n    where :math:`\\mathcal{S}_0` flips the phase of the all-zero state and acts as identity\n    on all other states. Sometimes the first three operands are summarized as diffusion operator,\n    which implements a reflection over the equal superposition state.\n\n    If the number of solutions is known, we can calculate how often :math:`\\mathcal{Q}` should be\n    applied to find a solution with very high probability, see the method\n    `optimal_num_iterations`. If the number of solutions is unknown, the algorithm tries different\n    powers of Grover's operator, see the `iterations` argument, and after each iteration checks\n    if a good state has been measured using `good_state`.\n\n    The generalization of Grover's Search, Quantum Amplitude Amplification [3], uses a modified\n    version of :math:`\\mathcal{Q}` where the diffusion operator does not reflect about the\n    equal superposition state, but another state specified via an operator :math:`\\mathcal{A}`:\n\n    .. math::\n\n        \\mathcal{Q} = \\mathcal{A} \\mathcal{S}_0 \\mathcal{A}^\\dagger \\mathcal{S}_f.\n\n    For more information, see the :class:`~qiskit.circuit.library.GroverOperator` in the\n    circuit library.\n\n    References:\n        [1]: L. K. Grover (1996), A fast quantum mechanical algorithm for database search,\n            `arXiv:quant-ph/9605043 <https://arxiv.org/abs/quant-ph/9605043>`_.\n        [2]: I. Chuang & M. Nielsen, Quantum Computation and Quantum Information,\n            Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.\n        [3]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n            Quantum Amplitude Amplification and Estimation.\n            `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    "))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='growth_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='sample_from_iterations', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            iterations: Specify the number of iterations/power of Grover's operator to be checked.\n                * If an int, only one circuit is run with that power of the Grover operator.\n                If the number of solutions is known, this option should be used with the optimal\n                power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n                * If a list, all the powers in the list are run in the specified order.\n                * If an iterator, the powers yielded by the iterator are checked, until a maximum\n                number of iterations or maximum power is reached.\n                * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n                and circuits are run until that good state is reached.\n            growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n                i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n                number of iterations is reached.\n            sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n                powers of the Grover operator, a random integer sample between 0 and smaller value\n                than the iteration is used as a power, see [1], Section 4.\n            quantum_instance: A Quantum Instance or Backend to run the circuits.\n\n        Raises:\n            ValueError: If ``growth_rate`` is a float but not larger than 1.\n            ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\n        References:\n            [1]: Boyer et al., Tight bounds on quantum searching\n                 `<https://arxiv.org/abs/quant-ph/9605034>`_\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='growth_rate', ctx=Store())], value=Num(n=1.2))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Store())], value=Name(id='sample_from_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Store())], value=Name(id='iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='amplify', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='amplification_problem', annotation=Name(id='AmplificationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the Grover algorithm.\n\n        Args:\n            amplification_problem: The amplification problem.\n\n        Returns:\n            The result as a ``GroverResult``, where e.g. the most likely state can be queried\n            as ``result.top_measurement``.\n\n        Raises:\n            TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n            is ``None`` or a ``list``)\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load())), Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='iterator', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='GroverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iterations', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=BinOp(left=Str(s='0'), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='all_circuit_results', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_probability', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=0)), For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='max_iterations', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())]), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load()), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))]), Expr(value=Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None)), Break()], orelse=[]), If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)]), body=[Break()], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='top_measurement', ctx=Store())], value=Name(id='top_measurement', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='assignment', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='oracle_evaluation', ctx=Store())], value=Name(id='oracle_evaluation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='all_circuit_results', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='max_probability', ctx=Store())], value=Name(id='max_probability', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='GroverResult'))
FunctionDef(name='optimal_num_iterations', args=arguments(args=[arg(arg='num_solutions', annotation=Name(id='int', ctx=Load())), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Return the optimal number of iterations, if the number of solutions is known.\n\n        Args:\n            num_solutions: The number of solutions.\n            num_qubits: The number of qubits used to encode the states.\n\n        Returns:\n            The optimal number of iterations for Grover's algorithm to succeed.\n        ")), Assign(targets=[Name(id='amplitude', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))], keywords=[])), Return(value=Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='AmplificationProblem', ctx=Load())), arg(arg='power', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s="Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\n        Args:\n            problem: The amplification problem for the algorithm.\n            power: The number of times the Grover operator is repeated. If None, this argument\n                is set to the first item in ``iterations``.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\n        Raises:\n            ValueError: If no power is passed and the iterations are not an integer.\n        ")), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='power', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='Grover circuit'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='measurement_cr', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
Name(id='AmplitudeAmplifierResult', ctx=Load())
Expr(value=Str(s='Grover Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_results', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_shots', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='All the powers of the Grover operator that have been tried.\n\n        Returns:\n            The powers of the Grover operator tested.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator that have been tried.\n\n        Args:\n            value: A new value for the powers.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
Load()
Str(s="Grover's Search algorithm.\n\n    .. note::\n\n        If you want to learn more about the theory behind Grover's Search algorithm, check\n        out the `Qiskit Textbook <https://qiskit.org/textbook/ch-algorithms/grover.html>`_.\n        or the `Qiskit Tutorials\n        <https://qiskit.org/documentation/tutorials/algorithms/07_grover_examples.html>`_\n        for more concrete how-to examples.\n\n    Grover's Search [1, 2] is a well known quantum algorithm that can be used for\n    searching through unstructured collections of records for particular targets\n    with quadratic speedup compared to classical algorithms.\n\n    Given a set :math:`X` of :math:`N` elements :math:`X=\\{x_1,x_2,\\ldots,x_N\\}`\n    and a boolean function :math:`f : X \\rightarrow \\{0,1\\}`, the goal of an\n    unstructured-search problem is to find an element :math:`x^* \\in X` such\n    that :math:`f(x^*)=1`.\n\n    The search is called *unstructured* because there are no guarantees as to how\n    the database is ordered.  On a sorted database, for instance, one could perform\n    binary search to find an element in :math:`\\mathbb{O}(\\log N)` worst-case time.\n    Instead, in an unstructured-search problem, there is no prior knowledge about\n    the contents of the database. With classical circuits, there is no alternative\n    but to perform a linear number of queries to find the target element.\n    Conversely, Grover's Search algorithm allows to solve the unstructured-search\n    problem on a quantum computer in :math:`\\mathcal{O}(\\sqrt{N})` queries.\n\n    To carry out this search a so-called oracle is required, that flags a good element/state.\n    The action of the oracle :math:`\\mathcal{S}_f` is\n\n    .. math::\n\n        \\mathcal{S}_f |x\\rangle = (-1)^{f(x)} |x\\rangle,\n\n    i.e. it flips the phase of the state :math:`|x\\rangle` if :math:`x` is a hit.\n    The details of how :math:`S_f` works are unimportant to the algorithm; Grover's\n    search algorithm treats the oracle as a black box.\n\n    This class supports oracles in form of a :class:`~qiskit.circuit.QuantumCircuit`.\n\n    With the given oracle, Grover's Search constructs the Grover operator to amplify the\n    amplitudes of the good states:\n\n    .. math::\n\n        \\mathcal{Q} = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n} \\mathcal{S}_f\n                    = D \\mathcal{S}_f,\n\n    where :math:`\\mathcal{S}_0` flips the phase of the all-zero state and acts as identity\n    on all other states. Sometimes the first three operands are summarized as diffusion operator,\n    which implements a reflection over the equal superposition state.\n\n    If the number of solutions is known, we can calculate how often :math:`\\mathcal{Q}` should be\n    applied to find a solution with very high probability, see the method\n    `optimal_num_iterations`. If the number of solutions is unknown, the algorithm tries different\n    powers of Grover's operator, see the `iterations` argument, and after each iteration checks\n    if a good state has been measured using `good_state`.\n\n    The generalization of Grover's Search, Quantum Amplitude Amplification [3], uses a modified\n    version of :math:`\\mathcal{Q}` where the diffusion operator does not reflect about the\n    equal superposition state, but another state specified via an operator :math:`\\mathcal{A}`:\n\n    .. math::\n\n        \\mathcal{Q} = \\mathcal{A} \\mathcal{S}_0 \\mathcal{A}^\\dagger \\mathcal{S}_f.\n\n    For more information, see the :class:`~qiskit.circuit.library.GroverOperator` in the\n    circuit library.\n\n    References:\n        [1]: L. K. Grover (1996), A fast quantum mechanical algorithm for database search,\n            `arXiv:quant-ph/9605043 <https://arxiv.org/abs/quant-ph/9605043>`_.\n        [2]: I. Chuang & M. Nielsen, Quantum Computation and Quantum Information,\n            Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.\n        [3]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n            Quantum Amplitude Amplification and Estimation.\n            `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")
arguments(args=[arg(arg='self', annotation=None), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='growth_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='sample_from_iterations', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None)])
Expr(value=Str(s="\n        Args:\n            iterations: Specify the number of iterations/power of Grover's operator to be checked.\n                * If an int, only one circuit is run with that power of the Grover operator.\n                If the number of solutions is known, this option should be used with the optimal\n                power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n                * If a list, all the powers in the list are run in the specified order.\n                * If an iterator, the powers yielded by the iterator are checked, until a maximum\n                number of iterations or maximum power is reached.\n                * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n                and circuits are run until that good state is reached.\n            growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n                i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n                number of iterations is reached.\n            sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n                powers of the Grover operator, a random integer sample between 0 and smaller value\n                than the iteration is used as a power, see [1], Section 4.\n            quantum_instance: A Quantum Instance or Backend to run the circuits.\n\n        Raises:\n            ValueError: If ``growth_rate`` is a float but not larger than 1.\n            ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\n        References:\n            [1]: Boyer et al., Tight bounds on quantum searching\n                 `<https://arxiv.org/abs/quant-ph/9605034>`_\n        "))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='growth_rate', ctx=Store())], value=Num(n=1.2))], orelse=[])
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[]), cause=None)], orelse=[])
If(test=Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))])])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None))
If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Store())], value=Name(id='sample_from_iterations', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Store())], value=Name(id='iterations', ctx=Load()))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the quantum instance.\n        Returns:\n            The quantum instance used to run this algorithm.\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set quantum instance.\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='amplification_problem', annotation=Name(id='AmplificationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Run the Grover algorithm.\n\n        Args:\n            amplification_problem: The amplification problem.\n\n        Returns:\n            The result as a ``GroverResult``, where e.g. the most likely state can be queried\n            as ``result.top_measurement``.\n\n        Raises:\n            TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n            is ``None`` or a ``list``)\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load())), Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='iterator', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))])
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='GroverResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='iterations', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='top_measurement', ctx=Store())], value=BinOp(left=Str(s='0'), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=False))
Assign(targets=[Name(id='all_circuit_results', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='max_probability', ctx=Store())], value=Num(n=0))
Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=0))
For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='max_iterations', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())]), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load()), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))]), Expr(value=Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None)), Break()], orelse=[]), If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)]), body=[Break()], orelse=[])], orelse=[])
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='top_measurement', ctx=Store())], value=Name(id='top_measurement', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='assignment', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='oracle_evaluation', ctx=Store())], value=Name(id='oracle_evaluation', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='all_circuit_results', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='max_probability', ctx=Store())], value=Name(id='max_probability', ctx=Load()))
Return(value=Name(id='result', ctx=Load()))
Str(s='GroverResult')
arguments(args=[arg(arg='num_solutions', annotation=Name(id='int', ctx=Load())), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s="Return the optimal number of iterations, if the number of solutions is known.\n\n        Args:\n            num_solutions: The number of solutions.\n            num_qubits: The number of qubits used to encode the states.\n\n        Returns:\n            The optimal number of iterations for Grover's algorithm to succeed.\n        "))
Assign(targets=[Name(id='amplitude', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))], keywords=[]))
Return(value=Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))], keywords=[]))
Name(id='staticmethod', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='AmplificationProblem', ctx=Load())), arg(arg='power', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)])
Expr(value=Str(s="Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\n        Args:\n            problem: The amplification problem for the algorithm.\n            power: The number of times the Grover operator is repeated. If None, this argument\n                is set to the first item in ``iterations``.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\n        Raises:\n            ValueError: If no power is passed and the iterations are not an integer.\n        "))
If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='power', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[])
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='Grover circuit'))]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[])
If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='measurement_cr', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[]))], orelse=[])
Return(value=Name(id='qc', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
Load()
Str(s='Grover Result.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_results', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_shots', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='All the powers of the Grover operator that have been tried.\n\n        Returns:\n            The powers of the Grover operator tested.\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the powers of the Grover operator that have been tried.\n\n        Args:\n            value: A new value for the powers.\n        '))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='iterations', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arg(arg='self', annotation=None)
arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='growth_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
arg(arg='sample_from_iterations', annotation=Name(id='bool', ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=False)
NameConstant(value=None)
Str(s="\n        Args:\n            iterations: Specify the number of iterations/power of Grover's operator to be checked.\n                * If an int, only one circuit is run with that power of the Grover operator.\n                If the number of solutions is known, this option should be used with the optimal\n                power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n                * If a list, all the powers in the list are run in the specified order.\n                * If an iterator, the powers yielded by the iterator are checked, until a maximum\n                number of iterations or maximum power is reached.\n                * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n                and circuits are run until that good state is reached.\n            growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n                i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n                number of iterations is reached.\n            sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n                powers of the Grover operator, a random integer sample between 0 and smaller value\n                than the iteration is used as a power, see [1], Section 4.\n            quantum_instance: A Quantum Instance or Backend to run the circuits.\n\n        Raises:\n            ValueError: If ``growth_rate`` is a float but not larger than 1.\n            ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\n        References:\n            [1]: Boyer et al., Tight bounds on quantum searching\n                 `<https://arxiv.org/abs/quant-ph/9605034>`_\n        ")
BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
Assign(targets=[Name(id='growth_rate', ctx=Store())], value=Num(n=1.2))
BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[]), cause=None)
Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))])
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
NameConstant(value=None)
Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Store())
Name(id='sample_from_iterations', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Store())
Name(id='iterations', ctx=Load())
arg(arg='self', annotation=None)
Str(s='Get the quantum instance.\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Set quantum instance.\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='amplification_problem', annotation=Name(id='AmplificationProblem', ctx=Load()))
Str(s='Run the Grover algorithm.\n\n        Args:\n            amplification_problem: The amplification problem.\n\n        Returns:\n            The result as a ``GroverResult``, where e.g. the most likely state can be queried\n            as ``result.top_measurement``.\n\n        Raises:\n            TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n            is ``None`` or a ``list``)\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='max_power', ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load()))
Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[]))
Assign(targets=[Name(id='max_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[]))
Assign(targets=[Name(id='iterator', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))
Name(id='result', ctx=Store())
Call(func=Name(id='GroverResult', ctx=Load()), args=[], keywords=[])
Name(id='iterations', ctx=Store())
List(elts=[], ctx=Load())
Name(id='top_measurement', ctx=Store())
BinOp(left=Str(s='0'), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[]))
Name(id='oracle_evaluation', ctx=Store())
NameConstant(value=False)
Name(id='all_circuit_results', ctx=Store())
List(elts=[], ctx=Load())
Name(id='max_probability', ctx=Store())
Num(n=0)
Name(id='shots', ctx=Store())
Num(n=0)
Name(id='_', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='max_iterations', ctx=Load())], keywords=[])
Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())]), body=[Break()], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))
If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load()), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))], orelse=[])
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))])
Expr(value=Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[]))
If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None)), Break()], orelse=[])
If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)]), body=[Break()], orelse=[])
Attribute(value=Name(id='result', ctx=Load()), attr='iterations', ctx=Store())
Name(id='iterations', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='top_measurement', ctx=Store())
Name(id='top_measurement', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='assignment', ctx=Store())
Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='oracle_evaluation', ctx=Store())
Name(id='oracle_evaluation', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())
Name(id='all_circuit_results', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='max_probability', ctx=Store())
Name(id='max_probability', ctx=Load())
Name(id='result', ctx=Load())
arg(arg='num_solutions', annotation=Name(id='int', ctx=Load()))
arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))
Str(s="Return the optimal number of iterations, if the number of solutions is known.\n\n        Args:\n            num_solutions: The number of solutions.\n            num_qubits: The number of qubits used to encode the states.\n\n        Returns:\n            The optimal number of iterations for Grover's algorithm to succeed.\n        ")
Name(id='amplitude', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))], keywords=[])
Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))], keywords=[])
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='problem', annotation=Name(id='AmplificationProblem', ctx=Load()))
arg(arg='power', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=None)
NameConstant(value=False)
Str(s="Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\n        Args:\n            problem: The amplification problem for the algorithm.\n            power: The number of times the Grover operator is repeated. If None, this argument\n                is set to the first item in ``iterations``.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\n        Raises:\n            ValueError: If no power is passed and the iterations are not an integer.\n        ")
Compare(left=Name(id='power', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='power', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Name(id='qc', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='Grover circuit'))])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
Name(id='measurement', ctx=Load())
Assign(targets=[Name(id='measurement_cr', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[]))
Name(id='qc', ctx=Load())
Load()
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_results', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_shots', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='All the powers of the Grover operator that have been tried.\n\n        Returns:\n            The powers of the Grover operator tested.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Str(s='Set the powers of the Grover operator that have been tried.\n\n        Args:\n            value: A new value for the powers.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())
Name(id='value', ctx=Load())
Name(id='iterations', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
And()
Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Name(id='growth_rate', ctx=Store())
Num(n=1.2)
And()
Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[])
Name(id='growth_rate', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())
Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))
Name(id='self', ctx=Load())
Store()
Name(id='quantum_instance', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='AmplificationProblem', ctx=Load())
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Name(id='list', ctx=Load())
Name(id='max_iterations', ctx=Store())
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])
Name(id='max_power', ctx=Store())
Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load())
Name(id='iterator', ctx=Store())
Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])
Name(id='max_iterations', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[])
Name(id='max_power', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[])
Name(id='iterator', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Store()
Name(id='GroverResult', ctx=Load())
Store()
Load()
Store()
Str(s='0')
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])
Store()
Store()
Load()
Store()
Store()
Store()
Name(id='range', ctx=Load())
Name(id='max_iterations', ctx=Load())
Name(id='power', ctx=Store())
Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[])
Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())])
Break()
Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load())
Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))]))
Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[]))
If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))]))
Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)))
Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))]))
Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))
Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))
Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[])
BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None))
Break()
BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)
Name(id='oracle_evaluation', ctx=Store())
Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])
Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)])
Break()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='top_measurement', ctx=Load())
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))
Name(id='round', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))
Name(id='AmplificationProblem', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Name(id='power', ctx=Load())
Is()
NameConstant(value=None)
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)
Name(id='power', ctx=Store())
Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Store()
Name(id='QuantumCircuit', ctx=Load())
Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())
keyword(arg='name', value=Str(s='Grover circuit'))
Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load())
Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())
keyword(arg='inplace', value=NameConstant(value=True))
Name(id='power', ctx=Load())
Gt()
Num(n=0)
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Load()
Name(id='measurement_cr', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[])
Load()
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='growth_rate', ctx=Load())
Is()
NameConstant(value=None)
Name(id='iterations', ctx=Load())
Is()
NameConstant(value=None)
Store()
Name(id='growth_rate', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='iterations', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='ValueError', ctx=Load())
Str(s='Pass either a value for iterations or growth_rate, not both.')
Load()
Name(id='self', ctx=Load())
Store()
Name(id='map', ctx=Load())
Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[]))
Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])
Name(id='isinstance', ctx=Load())
Name(id='iterations', ctx=Load())
Name(id='int', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())
List(elts=[Name(id='iterations', ctx=Load())], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())
Name(id='iterations', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Name(id='len', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Store()
Name(id='np', ctx=Load())
Load()
Store()
Name(id='iter', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Store()
Name(id='max', ctx=Load())
Num(n=10)
BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load())
BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))
Store()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='len', ctx=Load())
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Load()
Load()
Store()
Name(id='next', ctx=Load())
Name(id='iterator', ctx=Load())
Name(id='power', ctx=Load())
Gt()
Name(id='max_power', ctx=Load())
Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load())
Name(id='power', ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='power', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='qc', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])
Name(id='circuit_results', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])
Name(id='num_bits', ctx=Store())
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])
Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())])
Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)]))
Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))
Name(id='max_amplitude', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])
Name(id='max_amplitude_idx', ctx=Store())
Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='top_measurement', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])
Name(id='max_probability', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='shots', ctx=Store())
Num(n=1)
Name(id='qc', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])
Name(id='circuit_results', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Name(id='top_measurement', ctx=Store())
Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='shots', ctx=Store())
Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])
Name(id='max_probability', ctx=Store())
BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load()))
Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load())
Name(id='circuit_results', ctx=Load())
And()
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Name(id='oracle_evaluation', ctx=Store())
NameConstant(value=None)
And()
BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])])
Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[])
Store()
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load())
Name(id='top_measurement', ctx=Load())
Name(id='oracle_evaluation', ctx=Load())
Is()
NameConstant(value=True)
Load()
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='num_solutions', ctx=Load())
Div()
BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load()))
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])
Div()
BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])
Gt()
Num(n=1)
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load())
Load()
Str(s='Grover circuit')
Name(id='qc', ctx=Load())
Load()
Name(id='problem', ctx=Load())
Load()
NameConstant(value=True)
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])
keyword(arg='inplace', value=NameConstant(value=True))
Store()
Name(id='ClassicalRegister', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])
Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load())
Name(id='measurement_cr', ctx=Load())
Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load())
Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='measurement_cr', ctx=Load())
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])
Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load())
Num(n=1)
Load()
Load()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='iterations', ctx=Load())
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Num(n=2)
Pow()
Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='np', ctx=Load())
Load()
Num(n=2)
Pow()
BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2))
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='iterations', ctx=Load())
Load()
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load())
Name(id='power', ctx=Load())
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='amplification_problem', ctx=Load())
Name(id='power', ctx=Load())
keyword(arg='measurement', value=NameConstant(value=False))
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load())
Store()
Name(id='len', ctx=Load())
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[])
NotEq()
Name(id='num_bits', ctx=Load())
Name(id='indices', ctx=Store())
ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])
Name(id='rho', ctx=Store())
Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])
Name(id='circuit_results', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[])
Store()
Name(id='max', ctx=Load())
Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])
keyword(arg='key', value=Name(id='abs', ctx=Load()))
Store()
Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load())
Name(id='max_amplitude_idx', ctx=Load())
Name(id='num_bits', ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Store()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='amplification_problem', ctx=Load())
Name(id='power', ctx=Load())
keyword(arg='measurement', value=NameConstant(value=True))
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load())
Name(id='qc', ctx=Load())
Store()
Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))])
Index(value=Num(n=0))
Load()
Store()
Name(id='sum', ctx=Load())
Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])
Store()
Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load())
Div()
Name(id='shots', ctx=Load())
Name(id='all_circuit_results', ctx=Load())
Load()
Load()
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load())
Name(id='int', ctx=Load())
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load())
Is()
NameConstant(value=None)
Store()
Or()
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load())
Is()
NameConstant(value=None)
Name(id='TypeError', ctx=Load())
Str(s='An is_good_state function is required with the provided oracle')
Name(id='amplification_problem', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Num(n=2)
Pow()
Name(id='num_qubits', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
Name(id='amplitude', ctx=Load())
Num(n=2)
Mult()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])
Load()
Name(id='int', ctx=Load())
Name(id='len', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Name(id='ValueError', ctx=Load())
Str(s='Please pass ``power`` if the iterations are not an integer.')
Name(id='self', ctx=Load())
Load()
Num(n=0)
Name(id='problem', ctx=Load())
Load()
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load())
Name(id='power', ctx=Load())
NameConstant(value=True)
Load()
Name(id='len', ctx=Load())
Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Name(id='problem', ctx=Load())
Load()
Load()
Name(id='super', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
arg(arg='x', annotation=None)
Name(id='int', ctx=Load())
BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))
Name(id='itertools', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load())
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[])
Div()
Num(n=2)
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=False)
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
  Found a method call call at line 233
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load())
Load()
Store()
Name(id='i', ctx=Load())
comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)
Store()
Name(id='partial_trace', ctx=Load())
Name(id='circuit_results', ctx=Load())
Name(id='indices', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load())
Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())
Load()
Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load())
Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load())
Name(id='abs', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[])
Index(value=Num(n=0))
Load()
Num(n=0)
Name(id='np', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Name(id='max_amplitude', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
  Found a method call call at line 253
Load()
Load()
Name(id='max', ctx=Load())
Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))
Num(n=0)
Load()
Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load())
Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))])
Index(value=Num(n=1))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load())
Is()
NameConstant(value=None)
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load())
Name(id='list', ctx=Load())
Name(id='amplification_problem', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load())
Name(id='amplitude', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Load()
Name(id='problem', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Name(id='growth_rate', ctx=Load())
Pow()
Name(id='x', ctx=Load())
Load()
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Name(id='len', ctx=Load())
Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='qc', ctx=Load())
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='rho', ctx=Load())
Load()
Name(id='circuit_results', ctx=Load())
Load()
Name(id='circuit_results', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load())
Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])
Num(n=0)
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='qc', ctx=Load())
Load()
Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load())
Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[])
Name(id='circuit_results', ctx=Load())
Load()
Name(id='max', ctx=Load())
Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))
Num(n=1)
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='problem', ctx=Load())
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='int', ctx=Load())
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='range', ctx=Load())
Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='i', ctx=Load())
NotIn()
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='circuit_results', ctx=Load())
Eq()
Name(id='max_amplitude', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='circuit_results', ctx=Load())
Load()
Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load())
Num(n=1)
Load()
Load()
Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load())
Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[])
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='Iterator', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='operator', ctx=Load())
Load()
Name(id='circuit_results', ctx=Load())
Load()
Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load())
Num(n=1)
Load()
Name(id='int', ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='operator', ctx=Load())
Load()
Load()
Load()
Load()
Module(body=[Expr(value=Str(s="Grover's search algorithm.")), Import(names=[alias(name='itertools', asname=None)]), Import(names=[alias(name='operator', asname=None)]), ImportFrom(module='typing', names=[alias(name='Iterator', asname=None), alias(name='List', asname=None), alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.quantum_info', names=[alias(name='partial_trace', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='amplification_problem', names=[alias(name='AmplificationProblem', asname=None)], level=1), ImportFrom(module='amplitude_amplifier', names=[alias(name='AmplitudeAmplifier', asname=None), alias(name='AmplitudeAmplifierResult', asname=None)], level=1), ClassDef(name='Grover', bases=[Name(id='AmplitudeAmplifier', ctx=Load())], keywords=[], body=[Expr(value=Str(s="Grover's Search algorithm.\n\n    .. note::\n\n        If you want to learn more about the theory behind Grover's Search algorithm, check\n        out the `Qiskit Textbook <https://qiskit.org/textbook/ch-algorithms/grover.html>`_.\n        or the `Qiskit Tutorials\n        <https://qiskit.org/documentation/tutorials/algorithms/07_grover_examples.html>`_\n        for more concrete how-to examples.\n\n    Grover's Search [1, 2] is a well known quantum algorithm that can be used for\n    searching through unstructured collections of records for particular targets\n    with quadratic speedup compared to classical algorithms.\n\n    Given a set :math:`X` of :math:`N` elements :math:`X=\\{x_1,x_2,\\ldots,x_N\\}`\n    and a boolean function :math:`f : X \\rightarrow \\{0,1\\}`, the goal of an\n    unstructured-search problem is to find an element :math:`x^* \\in X` such\n    that :math:`f(x^*)=1`.\n\n    The search is called *unstructured* because there are no guarantees as to how\n    the database is ordered.  On a sorted database, for instance, one could perform\n    binary search to find an element in :math:`\\mathbb{O}(\\log N)` worst-case time.\n    Instead, in an unstructured-search problem, there is no prior knowledge about\n    the contents of the database. With classical circuits, there is no alternative\n    but to perform a linear number of queries to find the target element.\n    Conversely, Grover's Search algorithm allows to solve the unstructured-search\n    problem on a quantum computer in :math:`\\mathcal{O}(\\sqrt{N})` queries.\n\n    To carry out this search a so-called oracle is required, that flags a good element/state.\n    The action of the oracle :math:`\\mathcal{S}_f` is\n\n    .. math::\n\n        \\mathcal{S}_f |x\\rangle = (-1)^{f(x)} |x\\rangle,\n\n    i.e. it flips the phase of the state :math:`|x\\rangle` if :math:`x` is a hit.\n    The details of how :math:`S_f` works are unimportant to the algorithm; Grover's\n    search algorithm treats the oracle as a black box.\n\n    This class supports oracles in form of a :class:`~qiskit.circuit.QuantumCircuit`.\n\n    With the given oracle, Grover's Search constructs the Grover operator to amplify the\n    amplitudes of the good states:\n\n    .. math::\n\n        \\mathcal{Q} = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n} \\mathcal{S}_f\n                    = D \\mathcal{S}_f,\n\n    where :math:`\\mathcal{S}_0` flips the phase of the all-zero state and acts as identity\n    on all other states. Sometimes the first three operands are summarized as diffusion operator,\n    which implements a reflection over the equal superposition state.\n\n    If the number of solutions is known, we can calculate how often :math:`\\mathcal{Q}` should be\n    applied to find a solution with very high probability, see the method\n    `optimal_num_iterations`. If the number of solutions is unknown, the algorithm tries different\n    powers of Grover's operator, see the `iterations` argument, and after each iteration checks\n    if a good state has been measured using `good_state`.\n\n    The generalization of Grover's Search, Quantum Amplitude Amplification [3], uses a modified\n    version of :math:`\\mathcal{Q}` where the diffusion operator does not reflect about the\n    equal superposition state, but another state specified via an operator :math:`\\mathcal{A}`:\n\n    .. math::\n\n        \\mathcal{Q} = \\mathcal{A} \\mathcal{S}_0 \\mathcal{A}^\\dagger \\mathcal{S}_f.\n\n    For more information, see the :class:`~qiskit.circuit.library.GroverOperator` in the\n    circuit library.\n\n    References:\n        [1]: L. K. Grover (1996), A fast quantum mechanical algorithm for database search,\n            `arXiv:quant-ph/9605043 <https://arxiv.org/abs/quant-ph/9605043>`_.\n        [2]: I. Chuang & M. Nielsen, Quantum Computation and Quantum Information,\n            Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.\n        [3]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n            Quantum Amplitude Amplification and Estimation.\n            `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='growth_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='sample_from_iterations', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            iterations: Specify the number of iterations/power of Grover's operator to be checked.\n                * If an int, only one circuit is run with that power of the Grover operator.\n                If the number of solutions is known, this option should be used with the optimal\n                power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n                * If a list, all the powers in the list are run in the specified order.\n                * If an iterator, the powers yielded by the iterator are checked, until a maximum\n                number of iterations or maximum power is reached.\n                * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n                and circuits are run until that good state is reached.\n            growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n                i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n                number of iterations is reached.\n            sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n                powers of the Grover operator, a random integer sample between 0 and smaller value\n                than the iteration is used as a power, see [1], Section 4.\n            quantum_instance: A Quantum Instance or Backend to run the circuits.\n\n        Raises:\n            ValueError: If ``growth_rate`` is a float but not larger than 1.\n            ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\n        References:\n            [1]: Boyer et al., Tight bounds on quantum searching\n                 `<https://arxiv.org/abs/quant-ph/9605034>`_\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='growth_rate', ctx=Store())], value=Num(n=1.2))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Store())], value=Name(id='sample_from_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Store())], value=Name(id='iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='amplify', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='amplification_problem', annotation=Name(id='AmplificationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the Grover algorithm.\n\n        Args:\n            amplification_problem: The amplification problem.\n\n        Returns:\n            The result as a ``GroverResult``, where e.g. the most likely state can be queried\n            as ``result.top_measurement``.\n\n        Raises:\n            TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n            is ``None`` or a ``list``)\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load())), Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='iterator', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='GroverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iterations', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=BinOp(left=Str(s='0'), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='all_circuit_results', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_probability', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=0)), For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='max_iterations', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())]), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load()), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))]), Expr(value=Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None)), Break()], orelse=[]), If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)]), body=[Break()], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='top_measurement', ctx=Store())], value=Name(id='top_measurement', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='assignment', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='oracle_evaluation', ctx=Store())], value=Name(id='oracle_evaluation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='all_circuit_results', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='max_probability', ctx=Store())], value=Name(id='max_probability', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='GroverResult')), FunctionDef(name='optimal_num_iterations', args=arguments(args=[arg(arg='num_solutions', annotation=Name(id='int', ctx=Load())), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Return the optimal number of iterations, if the number of solutions is known.\n\n        Args:\n            num_solutions: The number of solutions.\n            num_qubits: The number of qubits used to encode the states.\n\n        Returns:\n            The optimal number of iterations for Grover's algorithm to succeed.\n        ")), Assign(targets=[Name(id='amplitude', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))], keywords=[])), Return(value=Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='AmplificationProblem', ctx=Load())), arg(arg='power', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s="Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\n        Args:\n            problem: The amplification problem for the algorithm.\n            power: The number of times the Grover operator is repeated. If None, this argument\n                is set to the first item in ``iterations``.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\n        Raises:\n            ValueError: If no power is passed and the iterations are not an integer.\n        ")), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='power', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='Grover circuit'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='measurement_cr', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))], decorator_list=[]), ClassDef(name='GroverResult', bases=[Name(id='AmplitudeAmplifierResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Grover Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_results', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_shots', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='All the powers of the Grover operator that have been tried.\n\n        Returns:\n            The powers of the Grover operator tested.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator that have been tried.\n\n        Args:\n            value: A new value for the powers.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])])
Expr(value=Str(s="Grover's search algorithm."))
Import(names=[alias(name='itertools', asname=None)])
Import(names=[alias(name='operator', asname=None)])
ImportFrom(module='typing', names=[alias(name='Iterator', asname=None), alias(name='List', asname=None), alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.quantum_info', names=[alias(name='partial_trace', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='amplification_problem', names=[alias(name='AmplificationProblem', asname=None)], level=1)
ImportFrom(module='amplitude_amplifier', names=[alias(name='AmplitudeAmplifier', asname=None), alias(name='AmplitudeAmplifierResult', asname=None)], level=1)
ClassDef(name='Grover', bases=[Name(id='AmplitudeAmplifier', ctx=Load())], keywords=[], body=[Expr(value=Str(s="Grover's Search algorithm.\n\n    .. note::\n\n        If you want to learn more about the theory behind Grover's Search algorithm, check\n        out the `Qiskit Textbook <https://qiskit.org/textbook/ch-algorithms/grover.html>`_.\n        or the `Qiskit Tutorials\n        <https://qiskit.org/documentation/tutorials/algorithms/07_grover_examples.html>`_\n        for more concrete how-to examples.\n\n    Grover's Search [1, 2] is a well known quantum algorithm that can be used for\n    searching through unstructured collections of records for particular targets\n    with quadratic speedup compared to classical algorithms.\n\n    Given a set :math:`X` of :math:`N` elements :math:`X=\\{x_1,x_2,\\ldots,x_N\\}`\n    and a boolean function :math:`f : X \\rightarrow \\{0,1\\}`, the goal of an\n    unstructured-search problem is to find an element :math:`x^* \\in X` such\n    that :math:`f(x^*)=1`.\n\n    The search is called *unstructured* because there are no guarantees as to how\n    the database is ordered.  On a sorted database, for instance, one could perform\n    binary search to find an element in :math:`\\mathbb{O}(\\log N)` worst-case time.\n    Instead, in an unstructured-search problem, there is no prior knowledge about\n    the contents of the database. With classical circuits, there is no alternative\n    but to perform a linear number of queries to find the target element.\n    Conversely, Grover's Search algorithm allows to solve the unstructured-search\n    problem on a quantum computer in :math:`\\mathcal{O}(\\sqrt{N})` queries.\n\n    To carry out this search a so-called oracle is required, that flags a good element/state.\n    The action of the oracle :math:`\\mathcal{S}_f` is\n\n    .. math::\n\n        \\mathcal{S}_f |x\\rangle = (-1)^{f(x)} |x\\rangle,\n\n    i.e. it flips the phase of the state :math:`|x\\rangle` if :math:`x` is a hit.\n    The details of how :math:`S_f` works are unimportant to the algorithm; Grover's\n    search algorithm treats the oracle as a black box.\n\n    This class supports oracles in form of a :class:`~qiskit.circuit.QuantumCircuit`.\n\n    With the given oracle, Grover's Search constructs the Grover operator to amplify the\n    amplitudes of the good states:\n\n    .. math::\n\n        \\mathcal{Q} = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n} \\mathcal{S}_f\n                    = D \\mathcal{S}_f,\n\n    where :math:`\\mathcal{S}_0` flips the phase of the all-zero state and acts as identity\n    on all other states. Sometimes the first three operands are summarized as diffusion operator,\n    which implements a reflection over the equal superposition state.\n\n    If the number of solutions is known, we can calculate how often :math:`\\mathcal{Q}` should be\n    applied to find a solution with very high probability, see the method\n    `optimal_num_iterations`. If the number of solutions is unknown, the algorithm tries different\n    powers of Grover's operator, see the `iterations` argument, and after each iteration checks\n    if a good state has been measured using `good_state`.\n\n    The generalization of Grover's Search, Quantum Amplitude Amplification [3], uses a modified\n    version of :math:`\\mathcal{Q}` where the diffusion operator does not reflect about the\n    equal superposition state, but another state specified via an operator :math:`\\mathcal{A}`:\n\n    .. math::\n\n        \\mathcal{Q} = \\mathcal{A} \\mathcal{S}_0 \\mathcal{A}^\\dagger \\mathcal{S}_f.\n\n    For more information, see the :class:`~qiskit.circuit.library.GroverOperator` in the\n    circuit library.\n\n    References:\n        [1]: L. K. Grover (1996), A fast quantum mechanical algorithm for database search,\n            `arXiv:quant-ph/9605043 <https://arxiv.org/abs/quant-ph/9605043>`_.\n        [2]: I. Chuang & M. Nielsen, Quantum Computation and Quantum Information,\n            Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.\n        [3]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n            Quantum Amplitude Amplification and Estimation.\n            `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='growth_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='sample_from_iterations', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            iterations: Specify the number of iterations/power of Grover's operator to be checked.\n                * If an int, only one circuit is run with that power of the Grover operator.\n                If the number of solutions is known, this option should be used with the optimal\n                power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n                * If a list, all the powers in the list are run in the specified order.\n                * If an iterator, the powers yielded by the iterator are checked, until a maximum\n                number of iterations or maximum power is reached.\n                * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n                and circuits are run until that good state is reached.\n            growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n                i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n                number of iterations is reached.\n            sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n                powers of the Grover operator, a random integer sample between 0 and smaller value\n                than the iteration is used as a power, see [1], Section 4.\n            quantum_instance: A Quantum Instance or Backend to run the circuits.\n\n        Raises:\n            ValueError: If ``growth_rate`` is a float but not larger than 1.\n            ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\n        References:\n            [1]: Boyer et al., Tight bounds on quantum searching\n                 `<https://arxiv.org/abs/quant-ph/9605034>`_\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='growth_rate', ctx=Store())], value=Num(n=1.2))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Store())], value=Name(id='sample_from_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Store())], value=Name(id='iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='amplify', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='amplification_problem', annotation=Name(id='AmplificationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the Grover algorithm.\n\n        Args:\n            amplification_problem: The amplification problem.\n\n        Returns:\n            The result as a ``GroverResult``, where e.g. the most likely state can be queried\n            as ``result.top_measurement``.\n\n        Raises:\n            TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n            is ``None`` or a ``list``)\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load())), Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='iterator', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='GroverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iterations', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=BinOp(left=Str(s='0'), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='all_circuit_results', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_probability', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=0)), For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='max_iterations', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())]), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load()), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))]), Expr(value=Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None)), Break()], orelse=[]), If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)]), body=[Break()], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='top_measurement', ctx=Store())], value=Name(id='top_measurement', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='assignment', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='oracle_evaluation', ctx=Store())], value=Name(id='oracle_evaluation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='all_circuit_results', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='max_probability', ctx=Store())], value=Name(id='max_probability', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='GroverResult')), FunctionDef(name='optimal_num_iterations', args=arguments(args=[arg(arg='num_solutions', annotation=Name(id='int', ctx=Load())), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Return the optimal number of iterations, if the number of solutions is known.\n\n        Args:\n            num_solutions: The number of solutions.\n            num_qubits: The number of qubits used to encode the states.\n\n        Returns:\n            The optimal number of iterations for Grover's algorithm to succeed.\n        ")), Assign(targets=[Name(id='amplitude', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))], keywords=[])), Return(value=Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='AmplificationProblem', ctx=Load())), arg(arg='power', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s="Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\n        Args:\n            problem: The amplification problem for the algorithm.\n            power: The number of times the Grover operator is repeated. If None, this argument\n                is set to the first item in ``iterations``.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\n        Raises:\n            ValueError: If no power is passed and the iterations are not an integer.\n        ")), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='power', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='Grover circuit'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='measurement_cr', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))], decorator_list=[])
ClassDef(name='GroverResult', bases=[Name(id='AmplitudeAmplifierResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Grover Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_results', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_shots', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='All the powers of the Grover operator that have been tried.\n\n        Returns:\n            The powers of the Grover operator tested.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator that have been tried.\n\n        Args:\n            value: A new value for the powers.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
Str(s="Grover's search algorithm.")
alias(name='itertools', asname=None)
alias(name='operator', asname=None)
alias(name='Iterator', asname=None)
alias(name='List', asname=None)
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='numpy', asname='np')
alias(name='ClassicalRegister', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='Backend', asname=None)
alias(name='partial_trace', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='AmplificationProblem', asname=None)
alias(name='AmplitudeAmplifier', asname=None)
alias(name='AmplitudeAmplifierResult', asname=None)
Name(id='AmplitudeAmplifier', ctx=Load())
Expr(value=Str(s="Grover's Search algorithm.\n\n    .. note::\n\n        If you want to learn more about the theory behind Grover's Search algorithm, check\n        out the `Qiskit Textbook <https://qiskit.org/textbook/ch-algorithms/grover.html>`_.\n        or the `Qiskit Tutorials\n        <https://qiskit.org/documentation/tutorials/algorithms/07_grover_examples.html>`_\n        for more concrete how-to examples.\n\n    Grover's Search [1, 2] is a well known quantum algorithm that can be used for\n    searching through unstructured collections of records for particular targets\n    with quadratic speedup compared to classical algorithms.\n\n    Given a set :math:`X` of :math:`N` elements :math:`X=\\{x_1,x_2,\\ldots,x_N\\}`\n    and a boolean function :math:`f : X \\rightarrow \\{0,1\\}`, the goal of an\n    unstructured-search problem is to find an element :math:`x^* \\in X` such\n    that :math:`f(x^*)=1`.\n\n    The search is called *unstructured* because there are no guarantees as to how\n    the database is ordered.  On a sorted database, for instance, one could perform\n    binary search to find an element in :math:`\\mathbb{O}(\\log N)` worst-case time.\n    Instead, in an unstructured-search problem, there is no prior knowledge about\n    the contents of the database. With classical circuits, there is no alternative\n    but to perform a linear number of queries to find the target element.\n    Conversely, Grover's Search algorithm allows to solve the unstructured-search\n    problem on a quantum computer in :math:`\\mathcal{O}(\\sqrt{N})` queries.\n\n    To carry out this search a so-called oracle is required, that flags a good element/state.\n    The action of the oracle :math:`\\mathcal{S}_f` is\n\n    .. math::\n\n        \\mathcal{S}_f |x\\rangle = (-1)^{f(x)} |x\\rangle,\n\n    i.e. it flips the phase of the state :math:`|x\\rangle` if :math:`x` is a hit.\n    The details of how :math:`S_f` works are unimportant to the algorithm; Grover's\n    search algorithm treats the oracle as a black box.\n\n    This class supports oracles in form of a :class:`~qiskit.circuit.QuantumCircuit`.\n\n    With the given oracle, Grover's Search constructs the Grover operator to amplify the\n    amplitudes of the good states:\n\n    .. math::\n\n        \\mathcal{Q} = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n} \\mathcal{S}_f\n                    = D \\mathcal{S}_f,\n\n    where :math:`\\mathcal{S}_0` flips the phase of the all-zero state and acts as identity\n    on all other states. Sometimes the first three operands are summarized as diffusion operator,\n    which implements a reflection over the equal superposition state.\n\n    If the number of solutions is known, we can calculate how often :math:`\\mathcal{Q}` should be\n    applied to find a solution with very high probability, see the method\n    `optimal_num_iterations`. If the number of solutions is unknown, the algorithm tries different\n    powers of Grover's operator, see the `iterations` argument, and after each iteration checks\n    if a good state has been measured using `good_state`.\n\n    The generalization of Grover's Search, Quantum Amplitude Amplification [3], uses a modified\n    version of :math:`\\mathcal{Q}` where the diffusion operator does not reflect about the\n    equal superposition state, but another state specified via an operator :math:`\\mathcal{A}`:\n\n    .. math::\n\n        \\mathcal{Q} = \\mathcal{A} \\mathcal{S}_0 \\mathcal{A}^\\dagger \\mathcal{S}_f.\n\n    For more information, see the :class:`~qiskit.circuit.library.GroverOperator` in the\n    circuit library.\n\n    References:\n        [1]: L. K. Grover (1996), A fast quantum mechanical algorithm for database search,\n            `arXiv:quant-ph/9605043 <https://arxiv.org/abs/quant-ph/9605043>`_.\n        [2]: I. Chuang & M. Nielsen, Quantum Computation and Quantum Information,\n            Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.\n        [3]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n            Quantum Amplitude Amplification and Estimation.\n            `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    "))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='growth_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='sample_from_iterations', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            iterations: Specify the number of iterations/power of Grover's operator to be checked.\n                * If an int, only one circuit is run with that power of the Grover operator.\n                If the number of solutions is known, this option should be used with the optimal\n                power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n                * If a list, all the powers in the list are run in the specified order.\n                * If an iterator, the powers yielded by the iterator are checked, until a maximum\n                number of iterations or maximum power is reached.\n                * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n                and circuits are run until that good state is reached.\n            growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n                i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n                number of iterations is reached.\n            sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n                powers of the Grover operator, a random integer sample between 0 and smaller value\n                than the iteration is used as a power, see [1], Section 4.\n            quantum_instance: A Quantum Instance or Backend to run the circuits.\n\n        Raises:\n            ValueError: If ``growth_rate`` is a float but not larger than 1.\n            ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\n        References:\n            [1]: Boyer et al., Tight bounds on quantum searching\n                 `<https://arxiv.org/abs/quant-ph/9605034>`_\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='growth_rate', ctx=Store())], value=Num(n=1.2))], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Store())], value=Name(id='sample_from_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Store())], value=Name(id='iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='amplify', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='amplification_problem', annotation=Name(id='AmplificationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the Grover algorithm.\n\n        Args:\n            amplification_problem: The amplification problem.\n\n        Returns:\n            The result as a ``GroverResult``, where e.g. the most likely state can be queried\n            as ``result.top_measurement``.\n\n        Raises:\n            TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n            is ``None`` or a ``list``)\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load())), Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='iterator', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='GroverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iterations', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=BinOp(left=Str(s='0'), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='all_circuit_results', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_probability', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=0)), For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='max_iterations', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())]), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load()), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))]), Expr(value=Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None)), Break()], orelse=[]), If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)]), body=[Break()], orelse=[])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='top_measurement', ctx=Store())], value=Name(id='top_measurement', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='assignment', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='oracle_evaluation', ctx=Store())], value=Name(id='oracle_evaluation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='all_circuit_results', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='max_probability', ctx=Store())], value=Name(id='max_probability', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='GroverResult'))
FunctionDef(name='optimal_num_iterations', args=arguments(args=[arg(arg='num_solutions', annotation=Name(id='int', ctx=Load())), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Return the optimal number of iterations, if the number of solutions is known.\n\n        Args:\n            num_solutions: The number of solutions.\n            num_qubits: The number of qubits used to encode the states.\n\n        Returns:\n            The optimal number of iterations for Grover's algorithm to succeed.\n        ")), Assign(targets=[Name(id='amplitude', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))], keywords=[])), Return(value=Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='AmplificationProblem', ctx=Load())), arg(arg='power', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)]), body=[Expr(value=Str(s="Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\n        Args:\n            problem: The amplification problem for the algorithm.\n            power: The number of times the Grover operator is repeated. If None, this argument\n                is set to the first item in ``iterations``.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\n        Raises:\n            ValueError: If no power is passed and the iterations are not an integer.\n        ")), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='power', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='Grover circuit'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='measurement_cr', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
Name(id='AmplitudeAmplifierResult', ctx=Load())
Expr(value=Str(s='Grover Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_results', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_shots', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='All the powers of the Grover operator that have been tried.\n\n        Returns:\n            The powers of the Grover operator tested.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
FunctionDef(name='iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator that have been tried.\n\n        Args:\n            value: A new value for the powers.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
Load()
Str(s="Grover's Search algorithm.\n\n    .. note::\n\n        If you want to learn more about the theory behind Grover's Search algorithm, check\n        out the `Qiskit Textbook <https://qiskit.org/textbook/ch-algorithms/grover.html>`_.\n        or the `Qiskit Tutorials\n        <https://qiskit.org/documentation/tutorials/algorithms/07_grover_examples.html>`_\n        for more concrete how-to examples.\n\n    Grover's Search [1, 2] is a well known quantum algorithm that can be used for\n    searching through unstructured collections of records for particular targets\n    with quadratic speedup compared to classical algorithms.\n\n    Given a set :math:`X` of :math:`N` elements :math:`X=\\{x_1,x_2,\\ldots,x_N\\}`\n    and a boolean function :math:`f : X \\rightarrow \\{0,1\\}`, the goal of an\n    unstructured-search problem is to find an element :math:`x^* \\in X` such\n    that :math:`f(x^*)=1`.\n\n    The search is called *unstructured* because there are no guarantees as to how\n    the database is ordered.  On a sorted database, for instance, one could perform\n    binary search to find an element in :math:`\\mathbb{O}(\\log N)` worst-case time.\n    Instead, in an unstructured-search problem, there is no prior knowledge about\n    the contents of the database. With classical circuits, there is no alternative\n    but to perform a linear number of queries to find the target element.\n    Conversely, Grover's Search algorithm allows to solve the unstructured-search\n    problem on a quantum computer in :math:`\\mathcal{O}(\\sqrt{N})` queries.\n\n    To carry out this search a so-called oracle is required, that flags a good element/state.\n    The action of the oracle :math:`\\mathcal{S}_f` is\n\n    .. math::\n\n        \\mathcal{S}_f |x\\rangle = (-1)^{f(x)} |x\\rangle,\n\n    i.e. it flips the phase of the state :math:`|x\\rangle` if :math:`x` is a hit.\n    The details of how :math:`S_f` works are unimportant to the algorithm; Grover's\n    search algorithm treats the oracle as a black box.\n\n    This class supports oracles in form of a :class:`~qiskit.circuit.QuantumCircuit`.\n\n    With the given oracle, Grover's Search constructs the Grover operator to amplify the\n    amplitudes of the good states:\n\n    .. math::\n\n        \\mathcal{Q} = H^{\\otimes n} \\mathcal{S}_0 H^{\\otimes n} \\mathcal{S}_f\n                    = D \\mathcal{S}_f,\n\n    where :math:`\\mathcal{S}_0` flips the phase of the all-zero state and acts as identity\n    on all other states. Sometimes the first three operands are summarized as diffusion operator,\n    which implements a reflection over the equal superposition state.\n\n    If the number of solutions is known, we can calculate how often :math:`\\mathcal{Q}` should be\n    applied to find a solution with very high probability, see the method\n    `optimal_num_iterations`. If the number of solutions is unknown, the algorithm tries different\n    powers of Grover's operator, see the `iterations` argument, and after each iteration checks\n    if a good state has been measured using `good_state`.\n\n    The generalization of Grover's Search, Quantum Amplitude Amplification [3], uses a modified\n    version of :math:`\\mathcal{Q}` where the diffusion operator does not reflect about the\n    equal superposition state, but another state specified via an operator :math:`\\mathcal{A}`:\n\n    .. math::\n\n        \\mathcal{Q} = \\mathcal{A} \\mathcal{S}_0 \\mathcal{A}^\\dagger \\mathcal{S}_f.\n\n    For more information, see the :class:`~qiskit.circuit.library.GroverOperator` in the\n    circuit library.\n\n    References:\n        [1]: L. K. Grover (1996), A fast quantum mechanical algorithm for database search,\n            `arXiv:quant-ph/9605043 <https://arxiv.org/abs/quant-ph/9605043>`_.\n        [2]: I. Chuang & M. Nielsen, Quantum Computation and Quantum Information,\n            Cambridge: Cambridge University Press, 2000. Chapter 6.1.2.\n        [3]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n            Quantum Amplitude Amplification and Estimation.\n            `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")
arguments(args=[arg(arg='self', annotation=None), arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='growth_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='sample_from_iterations', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None)])
Expr(value=Str(s="\n        Args:\n            iterations: Specify the number of iterations/power of Grover's operator to be checked.\n                * If an int, only one circuit is run with that power of the Grover operator.\n                If the number of solutions is known, this option should be used with the optimal\n                power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n                * If a list, all the powers in the list are run in the specified order.\n                * If an iterator, the powers yielded by the iterator are checked, until a maximum\n                number of iterations or maximum power is reached.\n                * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n                and circuits are run until that good state is reached.\n            growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n                i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n                number of iterations is reached.\n            sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n                powers of the Grover operator, a random integer sample between 0 and smaller value\n                than the iteration is used as a power, see [1], Section 4.\n            quantum_instance: A Quantum Instance or Backend to run the circuits.\n\n        Raises:\n            ValueError: If ``growth_rate`` is a float but not larger than 1.\n            ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\n        References:\n            [1]: Boyer et al., Tight bounds on quantum searching\n                 `<https://arxiv.org/abs/quant-ph/9605034>`_\n        "))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='growth_rate', ctx=Store())], value=Num(n=1.2))], orelse=[])
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[]), cause=None)], orelse=[])
If(test=Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))])])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None))
If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Store())], value=Name(id='sample_from_iterations', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Store())], value=Name(id='iterations', ctx=Load()))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the quantum instance.\n        Returns:\n            The quantum instance used to run this algorithm.\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set quantum instance.\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='amplification_problem', annotation=Name(id='AmplificationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Run the Grover algorithm.\n\n        Args:\n            amplification_problem: The amplification problem.\n\n        Returns:\n            The result as a ``GroverResult``, where e.g. the most likely state can be queried\n            as ``result.top_measurement``.\n\n        Raises:\n            TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n            is ``None`` or a ``list``)\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load())), Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='max_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[])), Assign(targets=[Name(id='iterator', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))])
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='GroverResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='iterations', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='top_measurement', ctx=Store())], value=BinOp(left=Str(s='0'), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=False))
Assign(targets=[Name(id='all_circuit_results', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='max_probability', ctx=Store())], value=Num(n=0))
Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=0))
For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='max_iterations', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())]), body=[Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load()), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))], orelse=[]), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))]), Expr(value=Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None)), Break()], orelse=[]), If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)]), body=[Break()], orelse=[])], orelse=[])
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='top_measurement', ctx=Store())], value=Name(id='top_measurement', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='assignment', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='oracle_evaluation', ctx=Store())], value=Name(id='oracle_evaluation', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())], value=Name(id='all_circuit_results', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='max_probability', ctx=Store())], value=Name(id='max_probability', ctx=Load()))
Return(value=Name(id='result', ctx=Load()))
Str(s='GroverResult')
arguments(args=[arg(arg='num_solutions', annotation=Name(id='int', ctx=Load())), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s="Return the optimal number of iterations, if the number of solutions is known.\n\n        Args:\n            num_solutions: The number of solutions.\n            num_qubits: The number of qubits used to encode the states.\n\n        Returns:\n            The optimal number of iterations for Grover's algorithm to succeed.\n        "))
Assign(targets=[Name(id='amplitude', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))], keywords=[]))
Return(value=Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))], keywords=[]))
Name(id='staticmethod', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='AmplificationProblem', ctx=Load())), arg(arg='power', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=False)])
Expr(value=Str(s="Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\n        Args:\n            problem: The amplification problem for the algorithm.\n            power: The number of times the Grover operator is repeated. If None, this argument\n                is set to the first item in ``iterations``.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\n        Raises:\n            ValueError: If no power is passed and the iterations are not an integer.\n        "))
If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='power', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[])
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='Grover circuit'))]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[])
If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='measurement_cr', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[]))], orelse=[])
Return(value=Name(id='qc', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
Load()
Str(s='Grover Result.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_results', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_shots', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='All the powers of the Grover operator that have been tried.\n\n        Returns:\n            The powers of the Grover operator tested.\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the powers of the Grover operator that have been tried.\n\n        Args:\n            value: A new value for the powers.\n        '))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='iterations', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arg(arg='self', annotation=None)
arg(arg='iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='growth_rate', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
arg(arg='sample_from_iterations', annotation=Name(id='bool', ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=False)
NameConstant(value=None)
Str(s="\n        Args:\n            iterations: Specify the number of iterations/power of Grover's operator to be checked.\n                * If an int, only one circuit is run with that power of the Grover operator.\n                If the number of solutions is known, this option should be used with the optimal\n                power. The optimal power can be computed with ``Grover.optimal_num_iterations``.\n                * If a list, all the powers in the list are run in the specified order.\n                * If an iterator, the powers yielded by the iterator are checked, until a maximum\n                number of iterations or maximum power is reached.\n                * If ``None``, the :obj:`AmplificationProblem` provided must have an ``is_good_state``,\n                and circuits are run until that good state is reached.\n            growth_rate: If specified, the iterator is set to increasing powers of ``growth_rate``,\n                i.e. to ``int(growth_rate ** 1), int(growth_rate ** 2), ...`` until a maximum\n                number of iterations is reached.\n            sample_from_iterations: If True, instead of taking the values in ``iterations`` as\n                powers of the Grover operator, a random integer sample between 0 and smaller value\n                than the iteration is used as a power, see [1], Section 4.\n            quantum_instance: A Quantum Instance or Backend to run the circuits.\n\n        Raises:\n            ValueError: If ``growth_rate`` is a float but not larger than 1.\n            ValueError: If both ``iterations`` and ``growth_rate`` is set.\n\n        References:\n            [1]: Boyer et al., Tight bounds on quantum searching\n                 `<https://arxiv.org/abs/quant-ph/9605034>`_\n        ")
BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
Assign(targets=[Name(id='growth_rate', ctx=Store())], value=Num(n=1.2))
BoolOp(op=And(), values=[Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[]), cause=None)
Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))])
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
NameConstant(value=None)
Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Store())
Name(id='sample_from_iterations', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Store())
Name(id='iterations', ctx=Load())
arg(arg='self', annotation=None)
Str(s='Get the quantum instance.\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Set quantum instance.\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='amplification_problem', annotation=Name(id='AmplificationProblem', ctx=Load()))
Str(s='Run the Grover algorithm.\n\n        Args:\n            amplification_problem: The amplification problem.\n\n        Returns:\n            The result as a ``GroverResult``, where e.g. the most likely state can be queried\n            as ``result.top_measurement``.\n\n        Raises:\n            TypeError: If ``is_good_state`` is not provided and is required (i.e. when iterations\n            is ``None`` or a ``list``)\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='max_power', ctx=Store())], value=Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load()))
Assign(targets=[Name(id='iterator', ctx=Store())], value=Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='max_iterations', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[]))
Assign(targets=[Name(id='max_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[]))
Assign(targets=[Name(id='iterator', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()))
Name(id='result', ctx=Store())
Call(func=Name(id='GroverResult', ctx=Load()), args=[], keywords=[])
Name(id='iterations', ctx=Store())
List(elts=[], ctx=Load())
Name(id='top_measurement', ctx=Store())
BinOp(left=Str(s='0'), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[]))
Name(id='oracle_evaluation', ctx=Store())
NameConstant(value=False)
Name(id='all_circuit_results', ctx=Store())
List(elts=[], ctx=Load())
Name(id='max_probability', ctx=Store())
Num(n=0)
Name(id='shots', ctx=Store())
Num(n=0)
Name(id='_', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='max_iterations', ctx=Load())], keywords=[])
Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())]), body=[Break()], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))
If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load()), body=[Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))], orelse=[])
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))])
Expr(value=Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[]))
If(test=BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None)), Break()], orelse=[])
If(test=BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)]), body=[Break()], orelse=[])
Attribute(value=Name(id='result', ctx=Load()), attr='iterations', ctx=Store())
Name(id='iterations', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='top_measurement', ctx=Store())
Name(id='top_measurement', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='assignment', ctx=Store())
Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='oracle_evaluation', ctx=Store())
Name(id='oracle_evaluation', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='circuit_results', ctx=Store())
Name(id='all_circuit_results', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='max_probability', ctx=Store())
Name(id='max_probability', ctx=Load())
Name(id='result', ctx=Load())
arg(arg='num_solutions', annotation=Name(id='int', ctx=Load()))
arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))
Str(s="Return the optimal number of iterations, if the number of solutions is known.\n\n        Args:\n            num_solutions: The number of solutions.\n            num_qubits: The number of qubits used to encode the states.\n\n        Returns:\n            The optimal number of iterations for Grover's algorithm to succeed.\n        ")
Name(id='amplitude', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))], keywords=[])
Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))], keywords=[])
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='problem', annotation=Name(id='AmplificationProblem', ctx=Load()))
arg(arg='power', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=None)
NameConstant(value=False)
Str(s="Construct the circuit for Grover's algorithm with ``power`` Grover operators.\n\n        Args:\n            problem: The amplification problem for the algorithm.\n            power: The number of times the Grover operator is repeated. If None, this argument\n                is set to the first item in ``iterations``.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the QuantumCircuit object for the constructed circuit\n\n        Raises:\n            ValueError: If no power is passed and the iterations are not an integer.\n        ")
Compare(left=Name(id='power', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='power', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Name(id='qc', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='Grover circuit'))])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
Name(id='measurement', ctx=Load())
Assign(targets=[Name(id='measurement_cr', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[]))
Name(id='qc', ctx=Load())
Load()
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_results', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_shots', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='All the powers of the Grover operator that have been tried.\n\n        Returns:\n            The powers of the Grover operator tested.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Str(s='Set the powers of the Grover operator that have been tried.\n\n        Args:\n            value: A new value for the powers.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())
Name(id='value', ctx=Load())
Name(id='iterations', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
And()
Compare(left=Name(id='growth_rate', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Name(id='growth_rate', ctx=Store())
Num(n=1.2)
And()
Compare(left=Name(id='growth_rate', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='iterations', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Pass either a value for iterations or growth_rate, not both.')], keywords=[])
Name(id='growth_rate', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())
Call(func=Name(id='map', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])), Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='iterations', ctx=Load()), Name(id='int', ctx=Load())], keywords=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=List(elts=[Name(id='iterations', ctx=Load())], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())], value=Name(id='iterations', ctx=Load()))
Name(id='self', ctx=Load())
Store()
Name(id='quantum_instance', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='AmplificationProblem', ctx=Load())
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Name(id='list', ctx=Load())
Name(id='max_iterations', ctx=Store())
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])
Name(id='max_power', ctx=Store())
Attribute(value=Name(id='np', ctx=Load()), attr='inf', ctx=Load())
Name(id='iterator', ctx=Store())
Call(func=Name(id='iter', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])
Name(id='max_iterations', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Num(n=10), BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))], keywords=[])
Name(id='max_power', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))], keywords=[])
Name(id='iterator', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Store()
Name(id='GroverResult', ctx=Load())
Store()
Load()
Store()
Str(s='0')
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])
Store()
Store()
Load()
Store()
Store()
Store()
Name(id='range', ctx=Load())
Name(id='max_iterations', ctx=Load())
Name(id='power', ctx=Store())
Call(func=Name(id='next', ctx=Load()), args=[Name(id='iterator', ctx=Load())], keywords=[])
Compare(left=Name(id='power', ctx=Load()), ops=[Gt()], comparators=[Name(id='max_power', ctx=Load())])
Break()
Call(func=Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_sample_from_iterations', ctx=Load())
Assign(targets=[Name(id='power', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[]))
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))]))
Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='num_bits', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[]))
If(test=Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())]), body=[Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))]))
Assign(targets=[Name(id='max_amplitude_idx', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)))
Assign(targets=[Name(id='shots', ctx=Store())], value=Num(n=1))
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))]))
Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='top_measurement', ctx=Store())], value=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='shots', ctx=Store())], value=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))
Assign(targets=[Name(id='max_probability', ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load())))
Call(func=Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circuit_results', ctx=Load())], keywords=[])
BoolOp(op=And(), values=[Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
Assign(targets=[Name(id='oracle_evaluation', ctx=Store())], value=NameConstant(value=None))
Break()
BoolOp(op=And(), values=[BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])]), Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[]), cause=None)
Name(id='oracle_evaluation', ctx=Store())
Call(func=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='top_measurement', ctx=Load())], keywords=[])
Compare(left=Name(id='oracle_evaluation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=True)])
Break()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='top_measurement', ctx=Load())
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=Name(id='num_solutions', ctx=Load()), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load())))
Name(id='round', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])))
Name(id='AmplificationProblem', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Name(id='power', ctx=Load())
Is()
NameConstant(value=None)
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[]), cause=None)
Name(id='power', ctx=Store())
Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Store()
Name(id='QuantumCircuit', ctx=Load())
Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())
keyword(arg='name', value=Str(s='Grover circuit'))
Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load())
Attribute(value=Name(id='problem', ctx=Load()), attr='state_preparation', ctx=Load())
keyword(arg='inplace', value=NameConstant(value=True))
Name(id='power', ctx=Load())
Gt()
Num(n=0)
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Load()
Name(id='measurement_cr', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='measurement_cr', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Name(id='measurement_cr', ctx=Load())], keywords=[])
Load()
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='growth_rate', ctx=Load())
Is()
NameConstant(value=None)
Name(id='iterations', ctx=Load())
Is()
NameConstant(value=None)
Store()
Name(id='growth_rate', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='iterations', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='ValueError', ctx=Load())
Str(s='Pass either a value for iterations or growth_rate, not both.')
Load()
Name(id='self', ctx=Load())
Store()
Name(id='map', ctx=Load())
Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[]))
Call(func=Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load()), args=[Num(n=1)], keywords=[])
Name(id='isinstance', ctx=Load())
Name(id='iterations', ctx=Load())
Name(id='int', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())
List(elts=[Name(id='iterations', ctx=Load())], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Store())
Name(id='iterations', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Name(id='len', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Store()
Name(id='np', ctx=Load())
Load()
Store()
Name(id='iter', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Store()
Name(id='max', ctx=Load())
Num(n=10)
BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load()))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load())
BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2)))
Store()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='len', ctx=Load())
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Load()
Load()
Store()
Name(id='next', ctx=Load())
Name(id='iterator', ctx=Load())
Name(id='power', ctx=Load())
Gt()
Name(id='max_power', ctx=Load())
Attribute(value=Name(id='iterations', ctx=Load()), attr='append', ctx=Load())
Name(id='power', ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='power', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='qc', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])
Name(id='circuit_results', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load()), args=[], keywords=[])
Name(id='num_bits', ctx=Store())
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])
Compare(left=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[]), ops=[NotEq()], comparators=[Name(id='num_bits', ctx=Load())])
Assign(targets=[Name(id='indices', ctx=Store())], value=ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)]))
Assign(targets=[Name(id='rho', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='circuit_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[]))
Name(id='max_amplitude', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])
Name(id='max_amplitude_idx', ctx=Store())
Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='top_measurement', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load()), args=[Name(id='max_amplitude_idx', ctx=Load()), Name(id='num_bits', ctx=Load())], keywords=[])
Name(id='max_probability', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='shots', ctx=Store())
Num(n=1)
Name(id='qc', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='amplification_problem', ctx=Load()), Name(id='power', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])
Name(id='circuit_results', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Name(id='top_measurement', ctx=Store())
Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='shots', ctx=Store())
Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])
Name(id='max_probability', ctx=Store())
BinOp(left=Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load()), op=Div(), right=Name(id='shots', ctx=Load()))
Attribute(value=Name(id='all_circuit_results', ctx=Load()), attr='append', ctx=Load())
Name(id='circuit_results', ctx=Load())
And()
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='int', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Name(id='oracle_evaluation', ctx=Store())
NameConstant(value=None)
And()
BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])])
Compare(left=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Call(func=Name(id='TypeError', ctx=Load()), args=[Str(s='An is_good_state function is required with the provided oracle')], keywords=[])
Store()
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load())
Name(id='top_measurement', ctx=Load())
Name(id='oracle_evaluation', ctx=Load())
Is()
NameConstant(value=True)
Load()
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='num_solutions', ctx=Load())
Div()
BinOp(left=Num(n=2), op=Pow(), right=Name(id='num_qubits', ctx=Load()))
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])
Div()
BinOp(left=Num(n=2), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())], keywords=[])
Gt()
Num(n=1)
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Please pass ``power`` if the iterations are not an integer.')], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Attribute(value=Name(id='problem', ctx=Load()), attr='oracle', ctx=Load())
Load()
Str(s='Grover circuit')
Name(id='qc', ctx=Load())
Load()
Name(id='problem', ctx=Load())
Load()
NameConstant(value=True)
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='power', ctx=Load())], keywords=[])
keyword(arg='inplace', value=NameConstant(value=True))
Store()
Name(id='ClassicalRegister', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])
Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load())
Name(id='measurement_cr', ctx=Load())
Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load())
Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='measurement_cr', ctx=Load())
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))], keywords=[])
Attribute(value=Name(id='itertools', ctx=Load()), attr='count', ctx=Load())
Num(n=1)
Load()
Load()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='iterations', ctx=Load())
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Num(n=2)
Pow()
Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='np', ctx=Load())
Load()
Num(n=2)
Pow()
BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[]), op=Div(), right=Num(n=2))
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='iterations', ctx=Load())
Load()
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load()), attr='randint', ctx=Load())
Name(id='power', ctx=Load())
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='amplification_problem', ctx=Load())
Name(id='power', ctx=Load())
keyword(arg='measurement', value=NameConstant(value=False))
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_statevector', ctx=Load())
Store()
Name(id='len', ctx=Load())
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load()), args=[], keywords=[])
NotEq()
Name(id='num_bits', ctx=Load())
Name(id='indices', ctx=Store())
ListComp(elt=Name(id='i', ctx=Load()), generators=[comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)])
Name(id='rho', ctx=Store())
Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='circuit_results', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])
Name(id='circuit_results', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())], keywords=[])
Store()
Name(id='max', ctx=Load())
Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])
keyword(arg='key', value=Name(id='abs', ctx=Load()))
Store()
Subscript(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='binary_repr', ctx=Load())
Name(id='max_amplitude_idx', ctx=Load())
Name(id='num_bits', ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='max_amplitude', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Store()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='amplification_problem', ctx=Load())
Name(id='power', ctx=Load())
keyword(arg='measurement', value=NameConstant(value=True))
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load())
Name(id='qc', ctx=Load())
Store()
Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))])
Index(value=Num(n=0))
Load()
Store()
Name(id='sum', ctx=Load())
Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])
Store()
Subscript(value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))]), slice=Index(value=Num(n=1)), ctx=Load())
Div()
Name(id='shots', ctx=Load())
Name(id='all_circuit_results', ctx=Load())
Load()
Load()
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load())
Name(id='int', ctx=Load())
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load())
Is()
NameConstant(value=None)
Store()
Or()
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='is_good_state', ctx=Load())
Is()
NameConstant(value=None)
Name(id='TypeError', ctx=Load())
Str(s='An is_good_state function is required with the provided oracle')
Name(id='amplification_problem', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Num(n=2)
Pow()
Name(id='num_qubits', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
Name(id='amplitude', ctx=Load())
Num(n=2)
Mult()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])
Load()
Name(id='int', ctx=Load())
Name(id='len', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations', ctx=Load())
Name(id='ValueError', ctx=Load())
Str(s='Please pass ``power`` if the iterations are not an integer.')
Name(id='self', ctx=Load())
Load()
Num(n=0)
Name(id='problem', ctx=Load())
Load()
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load())
Name(id='power', ctx=Load())
NameConstant(value=True)
Load()
Name(id='len', ctx=Load())
Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Name(id='problem', ctx=Load())
Load()
Load()
Name(id='super', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
arg(arg='x', annotation=None)
Name(id='int', ctx=Load())
BinOp(left=Name(id='growth_rate', ctx=Load()), op=Pow(), right=Name(id='x', ctx=Load()))
Name(id='itertools', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='oracle', ctx=Load())
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())], keywords=[])
Div()
Num(n=2)
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='random', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=False)
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='width', ctx=Load())
Load()
Store()
Name(id='i', ctx=Load())
comprehension(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]), ifs=[Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])], is_async=0)
Store()
Name(id='partial_trace', ctx=Load())
Name(id='circuit_results', ctx=Load())
Name(id='indices', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load())
Attribute(value=Name(id='rho', ctx=Load()), attr='data', ctx=Load())
Load()
Attribute(value=Name(id='circuit_results', ctx=Load()), attr='max', ctx=Load())
Attribute(value=Name(id='circuit_results', ctx=Load()), attr='min', ctx=Load())
Name(id='abs', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[])
Index(value=Num(n=0))
Load()
Num(n=0)
Name(id='np', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Name(id='max_amplitude', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Load()
Load()
Name(id='max', ctx=Load())
Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))
Num(n=0)
Load()
Attribute(value=Name(id='circuit_results', ctx=Load()), attr='values', ctx=Load())
Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))])
Index(value=Num(n=1))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load())
Is()
NameConstant(value=None)
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_iterations_arg', ctx=Load())
Name(id='list', ctx=Load())
Name(id='amplification_problem', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load())
Name(id='amplitude', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Load()
Name(id='problem', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Name(id='growth_rate', ctx=Load())
Pow()
Name(id='x', ctx=Load())
Load()
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Name(id='len', ctx=Load())
Attribute(value=Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='reflection_qubits', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='qc', ctx=Load())
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Compare(left=Name(id='i', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())])
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='rho', ctx=Load())
Load()
Name(id='circuit_results', ctx=Load())
Load()
Name(id='circuit_results', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='where', ctx=Load())
Compare(left=Name(id='circuit_results', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])
Num(n=0)
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='qc', ctx=Load())
Load()
Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load())
Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[])
Name(id='circuit_results', ctx=Load())
Load()
Name(id='max', ctx=Load())
Call(func=Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
keyword(arg='key', value=Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[]))
Num(n=1)
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='problem', ctx=Load())
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Iterator', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='int', ctx=Load())
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='range', ctx=Load())
Attribute(value=Name(id='qc', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='i', ctx=Load())
NotIn()
Attribute(value=Name(id='amplification_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='circuit_results', ctx=Load())
Eq()
Name(id='max_amplitude', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='circuit_results', ctx=Load())
Load()
Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load())
Num(n=1)
Load()
Load()
Attribute(value=Name(id='circuit_results', ctx=Load()), attr='items', ctx=Load())
Call(func=Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load()), args=[Num(n=1)], keywords=[])
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='Iterator', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='amplification_problem', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='operator', ctx=Load())
Load()
Name(id='circuit_results', ctx=Load())
Load()
Attribute(value=Name(id='operator', ctx=Load()), attr='itemgetter', ctx=Load())
Num(n=1)
Load()
Name(id='int', ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='operator', ctx=Load())
Load()
Load()
Load()
Load()
  metric  value
0     NC      4
DONE!
