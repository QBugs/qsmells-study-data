Python 3.7.8
Module(body=[Expr(value=Str(s='The Variational Quantum Deflation Algorithm for computing higher energy states.\n\nSee https://arxiv.org/abs/1805.08138.\n')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Callable', asname=None), alias(name='Union', asname=None), alias(name='Dict', asname=None), alias(name='Tuple', asname=None)], level=0), Import(names=[alias(name='logging', asname=None)]), ImportFrom(module='time', names=[alias(name='time', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='Parameter', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library', names=[alias(name='RealAmplitudes', asname=None)], level=0), ImportFrom(module='qiskit.opflow.primitive_ops.pauli_op', names=[alias(name='PauliOp', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.opflow', names=[alias(name='OperatorBase', asname=None), alias(name='ExpectationBase', asname=None), alias(name='ExpectationFactory', asname=None), alias(name='StateFn', asname=None), alias(name='CircuitStateFn', asname=None), alias(name='ListOp', asname=None), alias(name='CircuitSampler', asname=None), alias(name='PauliSumOp', asname=None)], level=0), ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None)], level=0), ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0), ImportFrom(module='qiskit.utils.backend_utils', names=[alias(name='is_aer_provider', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='list_or_dict', names=[alias(name='ListOrDict', asname=None)], level=2), ImportFrom(module='optimizers', names=[alias(name='Optimizer', asname=None), alias(name='SLSQP', asname=None), alias(name='Minimizer', asname=None)], level=2), ImportFrom(module='variational_algorithm', names=[alias(name='VariationalAlgorithm', asname=None), alias(name='VariationalResult', asname=None)], level=2), ImportFrom(module='eigen_solver', names=[alias(name='Eigensolver', asname=None), alias(name='EigensolverResult', asname=None)], level=1), ImportFrom(module='minimum_eigen_solvers.vqe', names=[alias(name='_validate_bounds', asname=None), alias(name='_validate_initial_point', asname=None)], level=2), ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2), ImportFrom(module='aux_ops_evaluator', names=[alias(name='eval_observables', asname=None)], level=2), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='VQD', bases=[Name(id='VariationalAlgorithm', ctx=Load()), Name(id='Eigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Variational Quantum Deflation algorithm.\n\n    `VQD <https://arxiv.org/abs/1805.08138>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the k eigenvalues of the Hamiltonian :math:`H` of a given system.\n\n    The algorithm computes excited state energies of generalised hamiltonians\n    by optimising over a modified cost function where each succesive eigen value\n    is calculated iteratively by introducing an overlap term with all\n    the previously computed eigenstaes that must be minimised, thus ensuring\n    higher energy eigen states are found.\n\n    An instance of VQD requires defining three algorithmic sub-components:\n    an integer k denoting the number of eigenstates to calculate, a trial\n    state (a.k.a. ansatz)which is a :class:`QuantumCircuit`,\n    and one of the classical :mod:`~qiskit.algorithms.optimizers`.\n    The ansatz is varied, via its set of parameters, by the optimizer,\n    such that it works towards a state, as determined by the parameters\n    applied to the ansatz, that will result in the minimum expectation values\n    being measured of the input operator (Hamiltonian). The algorithm does\n    this by iteratively refining each excited state to be orthogonal to all\n    the previous excited states.\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQD will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQD\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='betas', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), Num(n=2), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as ansatz for the wave function.\n            k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n            betas: beta parameter in the VQD paper. Should have size k -1, the number of excited states.\n                It is a hyperparameter that balances the contribution of the overlap\n                term to the cost function and has a default value computed as\n                mean square sum of coefficients of observable.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n                Only used to compute the ground state at the moment.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQD performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Store())], value=Name(id='k', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=Name(id='betas', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n                If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets a quantum_instance.')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load())), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQD as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None), FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Preparing the setting of VQD into a string.\n\n        Returns:\n            str: the formatted setting of VQD.\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_eval_aux_ops', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameters', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-12)]), body=[Assign(targets=[Name(id='sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='aux_op_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='aux_op_expect', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='aux_op_expect_sampled', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='aux_op_expect', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])), Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])]), body=[Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))]))], orelse=[]), Assign(targets=[Name(id='std_devs', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='aux_op_means', ctx=Store())], value=BinOp(left=Name(id='values', ctx=Load()), op=Mult(), right=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())]))), Assign(targets=[Name(id='aux_op_results', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='aux_op_means', ctx=Load()), Name(id='std_devs', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='key_value_iterator', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='aux_operator_eigenvalues', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='compute_eigenvalues', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='upper_bound', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQDResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), For(target=Name(id='step', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eigenvalue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='EigensolverResult', ctx=Load())), FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='step', annotation=Name(id='int', ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load())), arg(arg='prev_states', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This return value is the objective function to be passed to the optimizer for evaluation.\n\n        Args:\n            step: level of enegy being calculated. 0 for ground, 1 for first excited state and so on.\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n            prev_states: List of parameters from previous rounds of optimization.\n\n\n        Returns:\n            A callable that computes and returns the energy of the hamiltonian\n            of each parameter, and, optionally, the expectation\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n            AlgorithmError: If operator was not provided.\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='overlap_op', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='prev_circ', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))], decorator_list=[]), ClassDef(name='VQDResult', bases=[Name(id='VariationalResult', ctx=Load()), Name(id='EigensolverResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='VQD Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstates', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])])
Expr(value=Str(s='The Variational Quantum Deflation Algorithm for computing higher energy states.\n\nSee https://arxiv.org/abs/1805.08138.\n'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Callable', asname=None), alias(name='Union', asname=None), alias(name='Dict', asname=None), alias(name='Tuple', asname=None)], level=0)
Import(names=[alias(name='logging', asname=None)])
ImportFrom(module='time', names=[alias(name='time', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='Parameter', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library', names=[alias(name='RealAmplitudes', asname=None)], level=0)
ImportFrom(module='qiskit.opflow.primitive_ops.pauli_op', names=[alias(name='PauliOp', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.opflow', names=[alias(name='OperatorBase', asname=None), alias(name='ExpectationBase', asname=None), alias(name='ExpectationFactory', asname=None), alias(name='StateFn', asname=None), alias(name='CircuitStateFn', asname=None), alias(name='ListOp', asname=None), alias(name='CircuitSampler', asname=None), alias(name='PauliSumOp', asname=None)], level=0)
ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None)], level=0)
ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0)
ImportFrom(module='qiskit.utils.backend_utils', names=[alias(name='is_aer_provider', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='list_or_dict', names=[alias(name='ListOrDict', asname=None)], level=2)
ImportFrom(module='optimizers', names=[alias(name='Optimizer', asname=None), alias(name='SLSQP', asname=None), alias(name='Minimizer', asname=None)], level=2)
ImportFrom(module='variational_algorithm', names=[alias(name='VariationalAlgorithm', asname=None), alias(name='VariationalResult', asname=None)], level=2)
ImportFrom(module='eigen_solver', names=[alias(name='Eigensolver', asname=None), alias(name='EigensolverResult', asname=None)], level=1)
ImportFrom(module='minimum_eigen_solvers.vqe', names=[alias(name='_validate_bounds', asname=None), alias(name='_validate_initial_point', asname=None)], level=2)
ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2)
ImportFrom(module='aux_ops_evaluator', names=[alias(name='eval_observables', asname=None)], level=2)
Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[]))
ClassDef(name='VQD', bases=[Name(id='VariationalAlgorithm', ctx=Load()), Name(id='Eigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Variational Quantum Deflation algorithm.\n\n    `VQD <https://arxiv.org/abs/1805.08138>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the k eigenvalues of the Hamiltonian :math:`H` of a given system.\n\n    The algorithm computes excited state energies of generalised hamiltonians\n    by optimising over a modified cost function where each succesive eigen value\n    is calculated iteratively by introducing an overlap term with all\n    the previously computed eigenstaes that must be minimised, thus ensuring\n    higher energy eigen states are found.\n\n    An instance of VQD requires defining three algorithmic sub-components:\n    an integer k denoting the number of eigenstates to calculate, a trial\n    state (a.k.a. ansatz)which is a :class:`QuantumCircuit`,\n    and one of the classical :mod:`~qiskit.algorithms.optimizers`.\n    The ansatz is varied, via its set of parameters, by the optimizer,\n    such that it works towards a state, as determined by the parameters\n    applied to the ansatz, that will result in the minimum expectation values\n    being measured of the input operator (Hamiltonian). The algorithm does\n    this by iteratively refining each excited state to be orthogonal to all\n    the previous excited states.\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQD will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQD\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='betas', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), Num(n=2), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as ansatz for the wave function.\n            k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n            betas: beta parameter in the VQD paper. Should have size k -1, the number of excited states.\n                It is a hyperparameter that balances the contribution of the overlap\n                term to the cost function and has a default value computed as\n                mean square sum of coefficients of observable.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n                Only used to compute the ground state at the moment.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQD performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Store())], value=Name(id='k', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=Name(id='betas', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n                If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets a quantum_instance.')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load())), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQD as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None), FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Preparing the setting of VQD into a string.\n\n        Returns:\n            str: the formatted setting of VQD.\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_eval_aux_ops', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameters', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-12)]), body=[Assign(targets=[Name(id='sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='aux_op_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='aux_op_expect', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='aux_op_expect_sampled', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='aux_op_expect', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])), Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])]), body=[Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))]))], orelse=[]), Assign(targets=[Name(id='std_devs', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='aux_op_means', ctx=Store())], value=BinOp(left=Name(id='values', ctx=Load()), op=Mult(), right=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())]))), Assign(targets=[Name(id='aux_op_results', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='aux_op_means', ctx=Load()), Name(id='std_devs', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='key_value_iterator', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='aux_operator_eigenvalues', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='compute_eigenvalues', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='upper_bound', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQDResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), For(target=Name(id='step', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eigenvalue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='EigensolverResult', ctx=Load())), FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='step', annotation=Name(id='int', ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load())), arg(arg='prev_states', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This return value is the objective function to be passed to the optimizer for evaluation.\n\n        Args:\n            step: level of enegy being calculated. 0 for ground, 1 for first excited state and so on.\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n            prev_states: List of parameters from previous rounds of optimization.\n\n\n        Returns:\n            A callable that computes and returns the energy of the hamiltonian\n            of each parameter, and, optionally, the expectation\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n            AlgorithmError: If operator was not provided.\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='overlap_op', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='prev_circ', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))], decorator_list=[])
ClassDef(name='VQDResult', bases=[Name(id='VariationalResult', ctx=Load()), Name(id='EigensolverResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='VQD Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstates', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
Str(s='The Variational Quantum Deflation Algorithm for computing higher energy states.\n\nSee https://arxiv.org/abs/1805.08138.\n')
alias(name='Optional', asname=None)
alias(name='List', asname=None)
alias(name='Callable', asname=None)
alias(name='Union', asname=None)
alias(name='Dict', asname=None)
alias(name='Tuple', asname=None)
alias(name='logging', asname=None)
alias(name='time', asname=None)
alias(name='numpy', asname='np')
alias(name='QuantumCircuit', asname=None)
alias(name='Parameter', asname=None)
alias(name='RealAmplitudes', asname=None)
alias(name='PauliOp', asname=None)
alias(name='Backend', asname=None)
alias(name='OperatorBase', asname=None)
alias(name='ExpectationBase', asname=None)
alias(name='ExpectationFactory', asname=None)
alias(name='StateFn', asname=None)
alias(name='CircuitStateFn', asname=None)
alias(name='ListOp', asname=None)
alias(name='CircuitSampler', asname=None)
alias(name='PauliSumOp', asname=None)
alias(name='GradientBase', asname=None)
alias(name='validate_min', asname=None)
alias(name='is_aer_provider', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='ListOrDict', asname=None)
alias(name='Optimizer', asname=None)
alias(name='SLSQP', asname=None)
alias(name='Minimizer', asname=None)
alias(name='VariationalAlgorithm', asname=None)
alias(name='VariationalResult', asname=None)
alias(name='Eigensolver', asname=None)
alias(name='EigensolverResult', asname=None)
alias(name='_validate_bounds', asname=None)
alias(name='_validate_initial_point', asname=None)
alias(name='AlgorithmError', asname=None)
alias(name='eval_observables', asname=None)
Name(id='logger', ctx=Store())
Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])
Name(id='VariationalAlgorithm', ctx=Load())
Name(id='Eigensolver', ctx=Load())
Expr(value=Str(s='The Variational Quantum Deflation algorithm.\n\n    `VQD <https://arxiv.org/abs/1805.08138>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the k eigenvalues of the Hamiltonian :math:`H` of a given system.\n\n    The algorithm computes excited state energies of generalised hamiltonians\n    by optimising over a modified cost function where each succesive eigen value\n    is calculated iteratively by introducing an overlap term with all\n    the previously computed eigenstaes that must be minimised, thus ensuring\n    higher energy eigen states are found.\n\n    An instance of VQD requires defining three algorithmic sub-components:\n    an integer k denoting the number of eigenstates to calculate, a trial\n    state (a.k.a. ansatz)which is a :class:`QuantumCircuit`,\n    and one of the classical :mod:`~qiskit.algorithms.optimizers`.\n    The ansatz is varied, via its set of parameters, by the optimizer,\n    such that it works towards a state, as determined by the parameters\n    applied to the ansatz, that will result in the minimum expectation values\n    being measured of the input operator (Hamiltonian). The algorithm does\n    this by iteratively refining each excited state to be orthogonal to all\n    the previous excited states.\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQD will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQD\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='betas', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), Num(n=2), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as ansatz for the wave function.\n            k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n            betas: beta parameter in the VQD paper. Should have size k -1, the number of excited states.\n                It is a hyperparameter that balances the contribution of the overlap\n                term to the cost function and has a default value computed as\n                mean square sum of coefficients of observable.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n                Only used to compute the ground state at the moment.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQD performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Store())], value=Name(id='k', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=Name(id='betas', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n                If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets a quantum_instance.')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None)
FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load()))
FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQD as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None)
FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Preparing the setting of VQD into a string.\n\n        Returns:\n            str: the formatted setting of VQD.\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None)
FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='_eval_aux_ops', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameters', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-12)]), body=[Assign(targets=[Name(id='sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='aux_op_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='aux_op_expect', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='aux_op_expect_sampled', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='aux_op_expect', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])), Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])]), body=[Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))]))], orelse=[]), Assign(targets=[Name(id='std_devs', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='aux_op_means', ctx=Store())], value=BinOp(left=Name(id='values', ctx=Load()), op=Mult(), right=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())]))), Assign(targets=[Name(id='aux_op_results', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='aux_op_means', ctx=Load()), Name(id='std_devs', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='key_value_iterator', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='aux_operator_eigenvalues', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='compute_eigenvalues', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='upper_bound', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQDResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), For(target=Name(id='step', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eigenvalue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='EigensolverResult', ctx=Load()))
FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='step', annotation=Name(id='int', ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load())), arg(arg='prev_states', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This return value is the objective function to be passed to the optimizer for evaluation.\n\n        Args:\n            step: level of enegy being calculated. 0 for ground, 1 for first excited state and so on.\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n            prev_states: List of parameters from previous rounds of optimization.\n\n\n        Returns:\n            A callable that computes and returns the energy of the hamiltonian\n            of each parameter, and, optionally, the expectation\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n            AlgorithmError: If operator was not provided.\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='overlap_op', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='prev_circ', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Name(id='VariationalResult', ctx=Load())
Name(id='EigensolverResult', ctx=Load())
Expr(value=Str(s='VQD Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstates', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
Store()
Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load())
Name(id='__name__', ctx=Load())
Load()
Load()
Str(s='The Variational Quantum Deflation algorithm.\n\n    `VQD <https://arxiv.org/abs/1805.08138>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the k eigenvalues of the Hamiltonian :math:`H` of a given system.\n\n    The algorithm computes excited state energies of generalised hamiltonians\n    by optimising over a modified cost function where each succesive eigen value\n    is calculated iteratively by introducing an overlap term with all\n    the previously computed eigenstaes that must be minimised, thus ensuring\n    higher energy eigen states are found.\n\n    An instance of VQD requires defining three algorithmic sub-components:\n    an integer k denoting the number of eigenstates to calculate, a trial\n    state (a.k.a. ansatz)which is a :class:`QuantumCircuit`,\n    and one of the classical :mod:`~qiskit.algorithms.optimizers`.\n    The ansatz is varied, via its set of parameters, by the optimizer,\n    such that it works towards a state, as determined by the parameters\n    applied to the ansatz, that will result in the minimum expectation values\n    being measured of the input operator (Hamiltonian). The algorithm does\n    this by iteratively refining each excited state to be orthogonal to all\n    the previous excited states.\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQD will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQD\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='betas', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), Num(n=2), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as ansatz for the wave function.\n            k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n            betas: beta parameter in the VQD paper. Should have size k -1, the number of excited states.\n                It is a hyperparameter that balances the contribution of the overlap\n                term to the cost function and has a default value computed as\n                mean square sum of coefficients of observable.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n                Only used to compute the ground state at the moment.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQD performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        '))
Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[]))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Store())], value=Name(id='k', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=Name(id='betas', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None))
If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load()))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[]))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the ansatz.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n                If None is passed, RealAmplitudes is used by default.\n\n        '))
If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the gradient.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the gradient.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))
Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns quantum instance.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets a quantum_instance.'))
If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns initial point.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets initial point'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))
Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns max_evals_grouped'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets max_evals_grouped'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load()))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))
Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns include_custom'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        '))
If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])
Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns callback'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets callback'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))
Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))
Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.'))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns optimizer'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='Optimizer', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        '))
If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))
Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Prepare the setting of VQD as a string.'))
Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))
Assign(targets=[Name(id='params', ctx=Store())], value=Str(s=''))
For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)]))
Return(value=Name(id='ret', ctx=Load()))
Name(id='property', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Preparing the setting of VQD into a string.\n\n        Returns:\n            str: the formatted setting of VQD.\n        '))
Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n'))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
Return(value=Name(id='ret', ctx=Load()))
arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)])
Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        "))
If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))])
Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[]))
Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]))
If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='expect_op', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        '))
Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load()))
FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None)
Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[]))
Return(value=Name(id='circuits', ctx=Load()))
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Return(value=NameConstant(value=True))
Name(id='classmethod', ctx=Load())
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='parameters', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-12)])
Assign(targets=[Name(id='sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))])
Assign(targets=[Name(id='aux_op_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[]))
Assign(targets=[Name(id='aux_op_expect', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='aux_op_expect_sampled', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='aux_op_expect', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[]))
Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])], keywords=[]))
If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])), Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])]), body=[Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))]))], orelse=[])
Assign(targets=[Name(id='std_devs', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[]))
Assign(targets=[Name(id='aux_op_means', ctx=Store())], value=BinOp(left=Name(id='values', ctx=Load()), op=Mult(), right=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())])))
Assign(targets=[Name(id='aux_op_results', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='aux_op_means', ctx=Load()), Name(id='std_devs', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[]))])
For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='key_value_iterator', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])], orelse=[])
Return(value=Name(id='aux_operator_eigenvalues', ctx=Load()))
Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))])
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='upper_bound', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQDResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=List(elts=[], ctx=Load()))
If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[])
For(target=Name(id='step', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eigenvalue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))])], orelse=[])
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[])
Return(value=Name(id='result', ctx=Load()))
Name(id='EigensolverResult', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='step', annotation=Name(id='int', ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load())), arg(arg='prev_states', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False), NameConstant(value=None)])
Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This return value is the objective function to be passed to the optimizer for evaluation.\n\n        Args:\n            step: level of enegy being calculated. 0 for ground, 1 for first excited state and so on.\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n            prev_states: List of parameters from previous rounds of optimization.\n\n\n        Returns:\n            A callable that computes and returns the energy of the hamiltonian\n            of each parameter, and, optionally, the expectation\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n            AlgorithmError: If operator was not provided.\n\n        '))
Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()))
If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[])
If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[])
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='overlap_op', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()))
Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))]))
For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='prev_circ', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[])
FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None)
If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='energy_evaluation', ctx=Load()))
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.'))
Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[]))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))])
Return(value=Name(id='state', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Str(s='VQD Result.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns number of cost optimizer evaluations'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets number of cost function evaluations'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='return eigen state'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='set eigen state'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='eigenstates', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
Name(id='logging', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='k', annotation=Name(id='int', ctx=Load()))
arg(arg='betas', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))
arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))
arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Num(n=2)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=False)
Num(n=1)
NameConstant(value=None)
NameConstant(value=None)
Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as ansatz for the wave function.\n            k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n            betas: beta parameter in the VQD paper. Should have size k -1, the number of excited states.\n                It is a hyperparameter that balances the contribution of the overlap\n                term to the cost function and has a default value computed as\n                mean square sum of coefficients of observable.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n                Only used to compute the ground state at the moment.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQD performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')
Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())
Name(id='max_evals_grouped', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())
Name(id='expectation', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())
Name(id='include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())
Name(id='ansatz', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Store())
Name(id='k', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())
Name(id='betas', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())
Name(id='optimizer', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())
Name(id='initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())
Name(id='gradient', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
NameConstant(value=None)
Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Num(n=0)
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())
Name(id='callback', ctx=Load())
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[])
arg(arg='self', annotation=None)
Str(s='Returns the ansatz.')
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n                If None is passed, RealAmplitudes is used by default.\n\n        ')
Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
Name(id='ansatz', ctx=Load())
Name(id='ansatz', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns the gradient.')
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Sets the gradient.')
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())
Name(id='gradient', ctx=Load())
Name(id='gradient', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns quantum instance.')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Sets a quantum_instance.')
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())
Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))])
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns initial point.')
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Str(s='Sets initial point')
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())
Name(id='initial_point', ctx=Load())
Name(id='initial_point', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns max_evals_grouped')
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))
Str(s='Sets max_evals_grouped')
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())
Name(id='max_evals_grouped', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[])
Name(id='max_evals_grouped', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns include_custom')
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))
Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')
Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))
Name(id='include_custom', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns callback')
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Sets callback')
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())
Name(id='callback', ctx=Load())
Name(id='callback', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
Name(id='exp', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
Str(s='Check that the number of qubits of operator and ansatz match.')
BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])
arg(arg='self', annotation=None)
Str(s='Returns optimizer')
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))
Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')
Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())
Name(id='optimizer', ctx=Load())
Name(id='optimizer', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Prepare the setting of VQD as a string.')
Name(id='ret', ctx=Store())
JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])
Name(id='params', ctx=Store())
Str(s='')
Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])
Name(id='ret', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Preparing the setting of VQD into a string.\n\n        Returns:\n            str: the formatted setting of VQD.\n        ')
Name(id='ret', ctx=Store())
Str(s='\n')
Name(id='ret', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Name(id='ret', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=False)
Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")
Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))
Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))
Name(id='wave_function', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])
Name(id='observable_meas', ctx=Store())
Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])
Name(id='ansatz_circuit_op', ctx=Store())
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])
Name(id='expect_op', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])
Name(id='return_expectation', ctx=Load())
Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))
Name(id='expect_op', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')
Name(id='expect_op', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])
Name(id='circuits', ctx=Store())
List(elts=[], ctx=Load())
arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])
Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])
Name(id='circuits', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
arg(arg='cls', annotation=None)
NameConstant(value=True)
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='parameters', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
arg(arg='aux_operators', annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()))
arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))
arg(arg='threshold', annotation=Name(id='float', ctx=Load()))
Num(n=1e-12)
Name(id='sampler', ctx=Store())
Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])
Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Name(id='aux_op_meas', ctx=Store())
Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])
Name(id='aux_op_expect', ctx=Store())
Call(func=Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='aux_op_expect_sampled', ctx=Store())
Call(func=Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='aux_op_expect', ctx=Load())], keywords=[])
Name(id='values', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])
Name(id='variances', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])], keywords=[])
BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])), Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])])
Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))]))
Name(id='std_devs', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])
Name(id='aux_op_means', ctx=Store())
BinOp(left=Name(id='values', ctx=Load()), op=Mult(), right=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())]))
Name(id='aux_op_results', ctx=Store())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='aux_op_means', ctx=Load()), Name(id='std_devs', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=Dict(keys=[], values=[]))
Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[]))
Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())
Name(id='key_value_iterator', ctx=Load())
If(test=Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])
Name(id='aux_operator_eigenvalues', ctx=Load())
Name(id='ListOrDict', ctx=Load())
Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())
NameConstant(value=True)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Name(id='initial_point', ctx=Store())
Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Name(id='bounds', ctx=Store())
Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Name(id='aux_operators', ctx=Load())
Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))])
For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[])
Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))
Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='upper_bound', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load())))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Name(id='result', ctx=Store())
Call(func=Name(id='VQDResult', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())
List(elts=[], ctx=Load())
Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='aux_values', ctx=Store())], value=List(elts=[], ctx=Load()))
Name(id='step', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0))
Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))])
Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]))
If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))])
Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load())))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='eigenvalue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[]))
If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))], orelse=[])
If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))])
Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())
Call(func=Name(id='ListOp', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())], keywords=[])
Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))
Name(id='result', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='step', annotation=Name(id='int', ctx=Load()))
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))
arg(arg='prev_states', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=False)
NameConstant(value=None)
Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This return value is the objective function to be passed to the optimizer for evaluation.\n\n        Args:\n            step: level of enegy being calculated. 0 for ground, 1 for first excited state and so on.\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n            prev_states: List of parameters from previous rounds of optimization.\n\n\n        Returns:\n            A callable that computes and returns the energy of the hamiltonian\n            of each parameter, and, optionally, the expectation\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n            AlgorithmError: If operator was not provided.\n\n        ')
Name(id='num_parameters', ctx=Store())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)
Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)
BoolOp(op=And(), values=[Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])])
Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[]), cause=None)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Name(id='overlap_op', ctx=Store())
List(elts=[], ctx=Load())
Name(id='ansatz_params', ctx=Store())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])
Name(id='state', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Assign(targets=[Name(id='prev_circ', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[]))
arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[]))
Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))]))
Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[]))
For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))], orelse=[])
AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]))
Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))
Name(id='return_expectation', ctx=Load())
Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))
Name(id='energy_evaluation', ctx=Load())
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='optimal_parameters', annotation=None)
Str(s='Get the simulation outcome of the ansatz, provided with parameters.')
Name(id='optimal_circuit', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])
Name(id='state_fn', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))
Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))
Name(id='state', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='Returns number of cost optimizer evaluations')
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='int', ctx=Load()))
Str(s='Sets number of cost function evaluations')
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())
Name(id='value', ctx=Load())
Name(id='cost_function_evals', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='return eigen state')
Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Str(s='set eigen state')
Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Store())
Name(id='value', ctx=Load())
Name(id='eigenstates', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Name(id='int', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Name(id='int', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='validate_min', ctx=Load())
Str(s='max_evals_grouped')
Name(id='max_evals_grouped', ctx=Load())
Num(n=1)
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='quantum_instance', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Name(id='ansatz', ctx=Load())
Is()
NameConstant(value=None)
Name(id='ansatz', ctx=Store())
Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='CircuitSampler', ctx=Load())
Name(id='quantum_instance', ctx=Load())
keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load())
Name(id='max_evals_grouped', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='bool', ctx=Load())
Name(id='include_custom', ctx=Load())
NotEq()
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())
Name(id='include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())
NameConstant(value=None)
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='ExpectationBase', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
And()
Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())])
Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())
Name(id='optimizer', ctx=Load())
Is()
NameConstant(value=None)
Name(id='optimizer', ctx=Store())
Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[])
Name(id='isinstance', ctx=Load())
Name(id='optimizer', ctx=Load())
Name(id='Optimizer', ctx=Load())
Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Store()
Str(s='Algorithm: ')
FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None)
Str(s='\n')
Store()
Name(id='key', ctx=Store())
Name(id='value', ctx=Store())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load())
Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')])
If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])
Store()
FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)
Load()
Store()
Store()
Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())
Store()
FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='ret', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[])
Name(id='ret', ctx=Store())
Add()
Str(s='ansatz has not been set')
Store()
Store()
FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)
Store()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='OperatorBase', ctx=Load())
Name(id='bool', ctx=Load())
Name(id='operator', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load())
Name(id='operator', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load())
Is()
NameConstant(value=None)
Name(id='expectation', ctx=Store())
Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))])
Name(id='expectation', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load())
Name(id='parameter', ctx=Load())
Store()
Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load())
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])
Store()
Name(id='CircuitStateFn', ctx=Load())
Name(id='wave_function', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load())
Load()
Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='OperatorBase', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load())
Store()
Load()
arg(arg='op', annotation=None)
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])
Name(id='extract_circuits', ctx=Load())
Name(id='expect_op', ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())
Name(id='ExpectationBase', ctx=Load())
Name(id='float', ctx=Load())
Store()
Name(id='CircuitSampler', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='dict', ctx=Load())
Name(id='list_op', ctx=Store())
Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])
Name(id='list_op', ctx=Store())
Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load())
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])
Store()
Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load())
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])
Store()
Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load())
Name(id='aux_op_expect', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])
And()
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[]))
Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])
Name(id='variances', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))])
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))
Store()
Name(id='values', ctx=Load())
Mult()
Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())])
Store()
Name(id='zip', ctx=Load())
Name(id='aux_op_means', ctx=Load())
Name(id='std_devs', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='list', ctx=Load())
Name(id='aux_operator_eigenvalues', ctx=Store())
BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Name(id='key_value_iterator', ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[])
Name(id='aux_operator_eigenvalues', ctx=Store())
Dict(keys=[], values=[])
Name(id='key_value_iterator', ctx=Store())
Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[])
Name(id='key', ctx=Store())
Name(id='value', ctx=Store())
Store()
Load()
Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))
Load()
Load()
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='OperatorBase', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load())
Name(id='operator', ctx=Load())
Name(id='aux_operators', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load())
Name(id='operator', ctx=Load())
Store()
Name(id='_validate_initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Store()
Name(id='_validate_bounds', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='zero_op', ctx=Store())
Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))
Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store())
Name(id='key_op_iterator', ctx=Load())
If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])
Name(id='aux_operators', ctx=Store())
Name(id='converted', ctx=Load())
Name(id='aux_operators', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load())
Is()
NameConstant(value=None)
Name(id='upper_bound', ctx=Store())
IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))
Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())
BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()))
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Store()
Name(id='VQDResult', ctx=Load())
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='aux_operators', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='aux_values', ctx=Store())
List(elts=[], ctx=Load())
Store()
Name(id='range', ctx=Load())
Num(n=1)
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))])
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[])
Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))
Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))
Name(id='start_time', ctx=Store())
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[])
Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))
Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))
Name(id='eval_time', ctx=Store())
BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[])
Name(id='eigenvalue', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])
Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]))
Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))]))
Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))
Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))
Name(id='result', ctx=Load())
Store()
Name(id='ListOp', ctx=Load())
ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())
Name(id='aux_operators', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())
Name(id='aux_values', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='OperatorBase', ctx=Load())
Name(id='bool', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='num_parameters', ctx=Load())
Eq()
Num(n=0)
Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[])
Name(id='operator', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[])
And()
Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)])
Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])
Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load())
Name(id='operator', ctx=Load())
Store()
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='expect_op', ctx=Store())
Name(id='expectation', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load())
Name(id='ansatz_params', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='return_expectation', value=NameConstant(value=True))
Store()
Name(id='range', ctx=Load())
BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))
Name(id='prev_circ', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[])
arg(arg='parameters', annotation=None)
Name(id='parameter_sets', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])
Name(id='param_bindings', ctx=Store())
Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])
Name(id='sampled_expect_op', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])
Name(id='mean', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])
Name(id='state', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))]))
Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[]))
AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Add()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])
IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Load()
Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Name(id='optimal_parameters', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Name(id='state', ctx=Store())
Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load())
Name(id='state', ctx=Store())
Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load())
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Load()
Store()
Name(id='RealAmplitudes', ctx=Load())
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[])
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
Load()
Load()
Name(id='operator', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load())
NotEq()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))
ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='Optimizer', ctx=Load()))
Load()
Load()
Store()
Name(id='SLSQP', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())
Store()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load())
Load()
Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Eq()
Str(s='_')
BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))
AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))
Name(id='params', ctx=Load())
Str(s='==================== Setting of {} ============================\n')
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load())
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Str(s='{}'), attr='format', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='The operator was never provided.')
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load())
keyword(arg='operator', value=Name(id='operator', ctx=Load()))
keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()))
keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))
Store()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Name(id='expectation', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='is_measurement', value=NameConstant(value=True))
Load()
Load()
Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[])
Load()
Name(id='expect_op', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
Name(id='OperatorBase', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()))
Load()
Load()
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[])
Load()
Name(id='isinstance', ctx=Load())
Name(id='op', ctx=Load())
Name(id='CircuitStateFn', ctx=Load())
Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[])
For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='ListOrDict', ctx=Load())
Index(value=Name(id='OperatorBase', ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='ListOp', ctx=Load())
Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])
Store()
Name(id='ListOp', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='list_op', ctx=Load())
keyword(arg='is_measurement', value=NameConstant(value=True))
Name(id='aux_op_meas', ctx=Load())
Load()
Name(id='CircuitStateFn', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])
Name(id='sampler', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load())
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load())
Name(id='aux_op_expect_sampled', ctx=Load())
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])
Name(id='variances', ctx=Load())
Eq()
Num(n=0.0)
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
keyword(arg='dtype', value=Name(id='float', ctx=Load()))
Name(id='np', ctx=Load())
Load()
Name(id='variances', ctx=Load())
Div()
Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[])
Gt()
Name(id='threshold', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Store()
List(elts=[NameConstant(value=None)], ctx=Load())
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Store()
Name(id='enumerate', ctx=Load())
Name(id='aux_op_results', ctx=Load())
Store()
Store()
Name(id='zip', ctx=Load())
Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])
Name(id='aux_op_results', ctx=Load())
Store()
Store()
Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load())
IsNot()
NameConstant(value=None)
Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())
Name(id='value', ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()))
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load())
List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='list', ctx=Load())
Name(id='key_op_iterator', ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Name(id='converted', ctx=Store())
BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Name(id='key_op_iterator', ctx=Store())
Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
Name(id='converted', ctx=Store())
Dict(keys=[], values=[])
Name(id='key', ctx=Store())
Name(id='op', ctx=Store())
Store()
Load()
Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))
Store()
Load()
Store()
Name(id='self', ctx=Load())
Load()
Store()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[])
Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[])
BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Name(id='self', ctx=Load())
Store()
List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load())
Mult()
Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='beta autoevaluated to %s')
Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Store()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load())
Add()
Num(n=1)
Name(id='self', ctx=Load())
Store()
Name(id='energy_evaluation', ctx=Store())
Name(id='expectation', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load())
Name(id='step', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='return_expectation', value=NameConstant(value=True))
keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Name(id='GradientBase', ctx=Load())
Name(id='gradient', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))])
Name(id='gradient', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Store()
Name(id='time', ctx=Load())
Name(id='callable', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Name(id='opt_result', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))])
Name(id='opt_result', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))])
Store()
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Sub()
Name(id='start_time', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load())
Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load())
Name(id='eval_time', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load())
Name(id='eigenvalue', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Name(id='aux_operators', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='bound_ansatz', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Name(id='aux_value', ctx=Store())
Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])
Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[])
Name(id='step', ctx=Load())
Eq()
Num(n=1)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])
Load()
Load()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[])
comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='RuntimeError', ctx=Load())
Str(s='The ansatz must be parameterized, but has 0 free parameters.')
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='The operator was never provided.')
Name(id='step', ctx=Load())
Gt()
Num(n=1)
BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1))
NotEq()
Name(id='step', ctx=Load())
Name(id='RuntimeError', ctx=Load())
JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Load()
Name(id='step', ctx=Load())
Sub()
Num(n=1)
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())
Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load())
BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load())
Name(id='parameters', ctx=Load())
Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())
Store()
Name(id='dict', ctx=Load())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load())
Name(id='expect_op', ctx=Load())
keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])
Store()
Name(id='range', ctx=Load())
BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))
Name(id='sampled_final_op', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])
Name(id='cost', ctx=Store())
Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])
Name(id='mean', ctx=Store())
Add()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[])
Name(id='self', ctx=Load())
Store()
Name(id='len', ctx=Load())
Name(id='mean', ctx=Load())
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)])
Name(id='mean', ctx=Load())
Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='energy_evaluation', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[])
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load())
Load()
Store()
Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[])
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='is_aer_provider', ctx=Load())
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='operator', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())
Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='AttributeError', ctx=Load())
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))
Load()
Name(id='Optimizer', ctx=Load())
Load()
Name(id='optimizer', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='key', ctx=Load())
Index(value=Num(n=0))
Load()
And()
Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())])
Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Name(id='params', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[])
Name(id='params', ctx=Store())
Add()
JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Str(s='{}')
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load())
keyword(arg='output', value=Str(s='text'))
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load())
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Name(id='ExpectationFactory', ctx=Load())
Load()
Name(id='operator', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load())
Name(id='ansatz_circuit_op', ctx=Load())
Load()
Load()
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load())
Name(id='parameter', ctx=Load())
Name(id='operator', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load())
Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='op', ctx=Load())
Name(id='ListOp', ctx=Load())
Name(id='op_i', ctx=Store())
Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load())
Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Load()
Load()
Name(id='list', ctx=Load())
Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
NameConstant(value=True)
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Name(id='parameters', ctx=Load())
Load()
Load()
Name(id='aux_op_expect_sampled', ctx=Load())
Load()
Load()
Name(id='expectation', ctx=Load())
Load()
Load()
Name(id='isinstance', ctx=Load())
Name(id='variances', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Name(id='values', ctx=Load())
Load()
NameConstant(value=None)
Load()
Name(id='len', ctx=Load())
Name(id='aux_operators', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load())
Load()
Name(id='aux_operators', ctx=Load())
Index(value=Name(id='key', ctx=Load()))
Load()
Name(id='aux_operator_eigenvalues', ctx=Load())
Index(value=Name(id='key', ctx=Load()))
Store()
Load()
Load()
Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())
Load()
Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='PauliSumOp', ctx=Load())
Load()
Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='enumerate', ctx=Load())
Name(id='aux_operators', ctx=Load())
Store()
List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load())
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load())
Store()
Store()
Store()
Name(id='op', ctx=Load())
IsNot()
NameConstant(value=None)
Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())
IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load()))
Load()
Name(id='isinstance', ctx=Load())
Name(id='operator', ctx=Load())
Name(id='PauliOp', ctx=Load())
Name(id='abs', ctx=Load())
Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())
Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[])
Mult()
Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Load()
BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))
Load()
Name(id='self', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load())
BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[]))
keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Store()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load()))
keyword(arg='x0', value=Name(id='initial_point', ctx=Load()))
keyword(arg='jac', value=Name(id='gradient', ctx=Load()))
keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load())
keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load()))
keyword(arg='x0', value=Name(id='initial_point', ctx=Load()))
keyword(arg='jac', value=Name(id='gradient', ctx=Load()))
keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))
Name(id='time', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Load()
Name(id='opt_result', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())
Load()
Name(id='dict', ctx=Load())
Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())
Load()
Name(id='opt_result', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())
Load()
Name(id='opt_result', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())
Load()
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load())
Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Store()
Name(id='eval_observables', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Name(id='bound_ansatz', ctx=Load())
Name(id='aux_operators', ctx=Load())
keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))
Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load())
Name(id='aux_value', ctx=Load())
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals')
Name(id='eval_time', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals')
Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Name(id='eval_time', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())
Name(id='StateFn', ctx=Load())
Name(id='vec', ctx=Load())
Name(id='vec', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])
Add()
Num(n=1)
Load()
Load()
Str(s='Passed previous states of the wrong size.Passed array has length ')
FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='prev_states', ctx=Load())
Index(value=Name(id='state', ctx=Load()))
Load()
Name(id='overlap_op', ctx=Load())
Load()
UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[]))
MatMult()
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Name(id='np', ctx=Load())
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='num_parameters', ctx=Load())
Load()
Load()
Name(id='zip', ctx=Load())
Name(id='ansatz_params', ctx=Load())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load())
Load()
Load()
Name(id='param_bindings', ctx=Load())
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load())
Load()
Name(id='step', ctx=Load())
Sub()
Num(n=1)
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load())
Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())
keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))
Store()
Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))
Load()
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])
Gt()
Num(n=1)
Load()
Name(id='mean', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load())
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])
Load()
Name(id='state_fn', ctx=Load())
Load()
Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='Dict', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='super', ctx=Load())
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Name(id='quantum_instance', ctx=Load())
Load()
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Store()
Name(id='operator', ctx=Load())
Load()
Load()
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[])
Name(id='ex', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Num(n=0)
Str(s='initial_point')
In()
Name(id='key', ctx=Load())
Name(id='value', ctx=Load())
Is()
NameConstant(value=None)
Store()
Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load())
Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load())
Str(s='Random seed')
Store()
Str(s='-- ')
FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None)
Str(s=': ')
FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None)
Str(s='\n')
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Str(s='text')
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='observable_meas', ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='circuits', ctx=Load())
Load()
Name(id='op', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='op', ctx=Load())
Load()
Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[])
Load()
Load()
Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='aux_operators', ctx=Load())
Load()
Load()
Name(id='key', ctx=Load())
Load()
Name(id='key', ctx=Load())
Name(id='complex', ctx=Load())
Name(id='complex', ctx=Load())
Load()
Name(id='ListOrDict', ctx=Load())
Index(value=Name(id='OperatorBase', ctx=Load()))
Load()
Load()
Load()
BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()))
Num(n=0)
Load()
Load()
Load()
Name(id='zero_op', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='aux_operators', ctx=Load())
Load()
Load()
Name(id='converted', ctx=Load())
Index(value=Name(id='key', ctx=Load()))
Store()
Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Name(id='zero_op', ctx=Load())
Name(id='op', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='operator', ctx=Load())
Load()
Name(id='abs', ctx=Load())
Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())
Name(id='sum', ctx=Load())
GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])
Name(id='upper_bound', ctx=Load())
Mult()
Num(n=10)
Load()
Load()
Name(id='self', ctx=Load())
Load()
Num(n=0)
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Load()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])
MatMult()
Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='energy_evaluation', ctx=Load())
Name(id='initial_point', ctx=Load())
Name(id='gradient', ctx=Load())
Name(id='bounds', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Load()
Name(id='energy_evaluation', ctx=Load())
Name(id='initial_point', ctx=Load())
Name(id='gradient', ctx=Load())
Name(id='bounds', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='zip', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())
Name(id='result', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load())
Name(id='result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='expectation', ctx=Load())
Name(id='aux_values', ctx=Load())
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))
Load()
Name(id='result', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='result', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
Name(id='len', ctx=Load())
Name(id='prev_states', ctx=Load())
Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[])
Name(id='self', ctx=Load())
Load()
Load()
Name(id='state', ctx=Load())
Load()
Invert()
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])
Name(id='CircuitStateFn', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
USub()
Num(n=1)
Load()
Load()
Load()
Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='sampled_expect_op', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load())
Load()
Name(id='overlap_op', ctx=Load())
Index(value=Name(id='state', ctx=Load()))
Load()
Name(id='param_bindings', ctx=Load())
Name(id='sampled_final_op', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[]))
Mult()
Name(id='cost', ctx=Load())
Name(id='len', ctx=Load())
Name(id='mean', ctx=Load())
Load()
Num(n=0)
Name(id='np', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='optimal_circuit', ctx=Load())
Load()
Name(id='state_fn', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Load()
Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')
Load()
Load()
Load()
Load()
Str(s='-- {}: {}\n')
Load()
Name(id='key', ctx=Load())
Slice(lower=Num(n=1), upper=None, step=None)
Load()
Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load())
Name(id='value', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='Parameter', ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Name(id='ExpectationBase', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='Parameter', ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='extract_circuits', ctx=Load())
Name(id='op_i', ctx=Load())
Name(id='aux_operators', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Str(s='I')
Mult()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='key', ctx=Load())
Name(id='op', ctx=Load())
Eq()
Num(n=0)
Load()
Load()
Load()
Load()
Name(id='operator', ctx=Load())
Load()
Load()
Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[])
comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='is_measurement', value=NameConstant(value=True))
Name(id='StateFn', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Name(id='list', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='opt_result', ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Load()
Load()
Load()
Load()
Name(id='result', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='step', ctx=Load())
Sub()
Num(n=1)
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Load()
Name(id='str', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])
Load()
Load()
Name(id='CircuitStateFn', ctx=Load())
Name(id='prev_circ', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='state', ctx=Load())
Load()
Load()
Load()
Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())
Mult()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='str', ctx=Load())
Name(id='int', ctx=Load())
Load()
Load()
Name(id='Optimizer', ctx=Load())
Name(id='Minimizer', ctx=Load())
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Load()
Load()
Load()
Num(n=1)
Name(id='key', ctx=Load())
Slice(lower=Num(n=1), upper=None, step=None)
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='Parameter', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='Parameter', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='abs', ctx=Load())
Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())
Name(id='operation', ctx=Store())
Name(id='operator', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load())
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])
Load()
USub()
Num(n=1)
Load()
Load()
USub()
Num(n=1)
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='len', ctx=Load())
Name(id='prev_states', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load())
Index(value=Name(id='state', ctx=Load()))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load())
Name(id='cost', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Num(n=1)
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='operation', ctx=Load())
Load()
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])
Load()
Name(id='CircuitStateFn', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Load()
Load()
Load()
Name(id='parameter_sets', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='state', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='StateFn', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='is_measurement', value=NameConstant(value=True))
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Load()
USub()
Num(n=1)
Module(body=[Expr(value=Str(s='The Variational Quantum Deflation Algorithm for computing higher energy states.\n\nSee https://arxiv.org/abs/1805.08138.\n')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Callable', asname=None), alias(name='Union', asname=None), alias(name='Dict', asname=None), alias(name='Tuple', asname=None)], level=0), Import(names=[alias(name='logging', asname=None)]), ImportFrom(module='time', names=[alias(name='time', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='Parameter', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library', names=[alias(name='RealAmplitudes', asname=None)], level=0), ImportFrom(module='qiskit.opflow.primitive_ops.pauli_op', names=[alias(name='PauliOp', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.opflow', names=[alias(name='OperatorBase', asname=None), alias(name='ExpectationBase', asname=None), alias(name='ExpectationFactory', asname=None), alias(name='StateFn', asname=None), alias(name='CircuitStateFn', asname=None), alias(name='ListOp', asname=None), alias(name='CircuitSampler', asname=None), alias(name='PauliSumOp', asname=None)], level=0), ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None)], level=0), ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0), ImportFrom(module='qiskit.utils.backend_utils', names=[alias(name='is_aer_provider', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='list_or_dict', names=[alias(name='ListOrDict', asname=None)], level=2), ImportFrom(module='optimizers', names=[alias(name='Optimizer', asname=None), alias(name='SLSQP', asname=None), alias(name='Minimizer', asname=None)], level=2), ImportFrom(module='variational_algorithm', names=[alias(name='VariationalAlgorithm', asname=None), alias(name='VariationalResult', asname=None)], level=2), ImportFrom(module='eigen_solver', names=[alias(name='Eigensolver', asname=None), alias(name='EigensolverResult', asname=None)], level=1), ImportFrom(module='minimum_eigen_solvers.vqe', names=[alias(name='_validate_bounds', asname=None), alias(name='_validate_initial_point', asname=None)], level=2), ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2), ImportFrom(module='aux_ops_evaluator', names=[alias(name='eval_observables', asname=None)], level=2), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='VQD', bases=[Name(id='VariationalAlgorithm', ctx=Load()), Name(id='Eigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Variational Quantum Deflation algorithm.\n\n    `VQD <https://arxiv.org/abs/1805.08138>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the k eigenvalues of the Hamiltonian :math:`H` of a given system.\n\n    The algorithm computes excited state energies of generalised hamiltonians\n    by optimising over a modified cost function where each succesive eigen value\n    is calculated iteratively by introducing an overlap term with all\n    the previously computed eigenstaes that must be minimised, thus ensuring\n    higher energy eigen states are found.\n\n    An instance of VQD requires defining three algorithmic sub-components:\n    an integer k denoting the number of eigenstates to calculate, a trial\n    state (a.k.a. ansatz)which is a :class:`QuantumCircuit`,\n    and one of the classical :mod:`~qiskit.algorithms.optimizers`.\n    The ansatz is varied, via its set of parameters, by the optimizer,\n    such that it works towards a state, as determined by the parameters\n    applied to the ansatz, that will result in the minimum expectation values\n    being measured of the input operator (Hamiltonian). The algorithm does\n    this by iteratively refining each excited state to be orthogonal to all\n    the previous excited states.\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQD will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQD\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='betas', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), Num(n=2), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as ansatz for the wave function.\n            k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n            betas: beta parameter in the VQD paper. Should have size k -1, the number of excited states.\n                It is a hyperparameter that balances the contribution of the overlap\n                term to the cost function and has a default value computed as\n                mean square sum of coefficients of observable.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n                Only used to compute the ground state at the moment.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQD performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Store())], value=Name(id='k', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=Name(id='betas', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n                If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets a quantum_instance.')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load())), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQD as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None), FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Preparing the setting of VQD into a string.\n\n        Returns:\n            str: the formatted setting of VQD.\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_eval_aux_ops', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameters', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-12)]), body=[Assign(targets=[Name(id='sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='aux_op_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='aux_op_expect', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='aux_op_expect_sampled', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='aux_op_expect', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])), Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])]), body=[Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))]))], orelse=[]), Assign(targets=[Name(id='std_devs', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='aux_op_means', ctx=Store())], value=BinOp(left=Name(id='values', ctx=Load()), op=Mult(), right=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())]))), Assign(targets=[Name(id='aux_op_results', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='aux_op_means', ctx=Load()), Name(id='std_devs', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='key_value_iterator', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='aux_operator_eigenvalues', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='compute_eigenvalues', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='upper_bound', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQDResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), For(target=Name(id='step', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eigenvalue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='EigensolverResult', ctx=Load())), FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='step', annotation=Name(id='int', ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load())), arg(arg='prev_states', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This return value is the objective function to be passed to the optimizer for evaluation.\n\n        Args:\n            step: level of enegy being calculated. 0 for ground, 1 for first excited state and so on.\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n            prev_states: List of parameters from previous rounds of optimization.\n\n\n        Returns:\n            A callable that computes and returns the energy of the hamiltonian\n            of each parameter, and, optionally, the expectation\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n            AlgorithmError: If operator was not provided.\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='overlap_op', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='prev_circ', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))], decorator_list=[]), ClassDef(name='VQDResult', bases=[Name(id='VariationalResult', ctx=Load()), Name(id='EigensolverResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='VQD Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstates', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])])
Expr(value=Str(s='The Variational Quantum Deflation Algorithm for computing higher energy states.\n\nSee https://arxiv.org/abs/1805.08138.\n'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Callable', asname=None), alias(name='Union', asname=None), alias(name='Dict', asname=None), alias(name='Tuple', asname=None)], level=0)
Import(names=[alias(name='logging', asname=None)])
ImportFrom(module='time', names=[alias(name='time', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='Parameter', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library', names=[alias(name='RealAmplitudes', asname=None)], level=0)
ImportFrom(module='qiskit.opflow.primitive_ops.pauli_op', names=[alias(name='PauliOp', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.opflow', names=[alias(name='OperatorBase', asname=None), alias(name='ExpectationBase', asname=None), alias(name='ExpectationFactory', asname=None), alias(name='StateFn', asname=None), alias(name='CircuitStateFn', asname=None), alias(name='ListOp', asname=None), alias(name='CircuitSampler', asname=None), alias(name='PauliSumOp', asname=None)], level=0)
ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None)], level=0)
ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0)
ImportFrom(module='qiskit.utils.backend_utils', names=[alias(name='is_aer_provider', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='list_or_dict', names=[alias(name='ListOrDict', asname=None)], level=2)
ImportFrom(module='optimizers', names=[alias(name='Optimizer', asname=None), alias(name='SLSQP', asname=None), alias(name='Minimizer', asname=None)], level=2)
ImportFrom(module='variational_algorithm', names=[alias(name='VariationalAlgorithm', asname=None), alias(name='VariationalResult', asname=None)], level=2)
ImportFrom(module='eigen_solver', names=[alias(name='Eigensolver', asname=None), alias(name='EigensolverResult', asname=None)], level=1)
ImportFrom(module='minimum_eigen_solvers.vqe', names=[alias(name='_validate_bounds', asname=None), alias(name='_validate_initial_point', asname=None)], level=2)
ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2)
ImportFrom(module='aux_ops_evaluator', names=[alias(name='eval_observables', asname=None)], level=2)
Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[]))
ClassDef(name='VQD', bases=[Name(id='VariationalAlgorithm', ctx=Load()), Name(id='Eigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Variational Quantum Deflation algorithm.\n\n    `VQD <https://arxiv.org/abs/1805.08138>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the k eigenvalues of the Hamiltonian :math:`H` of a given system.\n\n    The algorithm computes excited state energies of generalised hamiltonians\n    by optimising over a modified cost function where each succesive eigen value\n    is calculated iteratively by introducing an overlap term with all\n    the previously computed eigenstaes that must be minimised, thus ensuring\n    higher energy eigen states are found.\n\n    An instance of VQD requires defining three algorithmic sub-components:\n    an integer k denoting the number of eigenstates to calculate, a trial\n    state (a.k.a. ansatz)which is a :class:`QuantumCircuit`,\n    and one of the classical :mod:`~qiskit.algorithms.optimizers`.\n    The ansatz is varied, via its set of parameters, by the optimizer,\n    such that it works towards a state, as determined by the parameters\n    applied to the ansatz, that will result in the minimum expectation values\n    being measured of the input operator (Hamiltonian). The algorithm does\n    this by iteratively refining each excited state to be orthogonal to all\n    the previous excited states.\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQD will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQD\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='betas', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), Num(n=2), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as ansatz for the wave function.\n            k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n            betas: beta parameter in the VQD paper. Should have size k -1, the number of excited states.\n                It is a hyperparameter that balances the contribution of the overlap\n                term to the cost function and has a default value computed as\n                mean square sum of coefficients of observable.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n                Only used to compute the ground state at the moment.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQD performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Store())], value=Name(id='k', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=Name(id='betas', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n                If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets a quantum_instance.')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load())), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQD as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None), FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Preparing the setting of VQD into a string.\n\n        Returns:\n            str: the formatted setting of VQD.\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_eval_aux_ops', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameters', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-12)]), body=[Assign(targets=[Name(id='sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='aux_op_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='aux_op_expect', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='aux_op_expect_sampled', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='aux_op_expect', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])), Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])]), body=[Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))]))], orelse=[]), Assign(targets=[Name(id='std_devs', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='aux_op_means', ctx=Store())], value=BinOp(left=Name(id='values', ctx=Load()), op=Mult(), right=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())]))), Assign(targets=[Name(id='aux_op_results', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='aux_op_means', ctx=Load()), Name(id='std_devs', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='key_value_iterator', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='aux_operator_eigenvalues', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='compute_eigenvalues', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='upper_bound', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQDResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), For(target=Name(id='step', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eigenvalue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='EigensolverResult', ctx=Load())), FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='step', annotation=Name(id='int', ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load())), arg(arg='prev_states', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This return value is the objective function to be passed to the optimizer for evaluation.\n\n        Args:\n            step: level of enegy being calculated. 0 for ground, 1 for first excited state and so on.\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n            prev_states: List of parameters from previous rounds of optimization.\n\n\n        Returns:\n            A callable that computes and returns the energy of the hamiltonian\n            of each parameter, and, optionally, the expectation\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n            AlgorithmError: If operator was not provided.\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='overlap_op', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='prev_circ', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))], decorator_list=[])
ClassDef(name='VQDResult', bases=[Name(id='VariationalResult', ctx=Load()), Name(id='EigensolverResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='VQD Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstates', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
Str(s='The Variational Quantum Deflation Algorithm for computing higher energy states.\n\nSee https://arxiv.org/abs/1805.08138.\n')
alias(name='Optional', asname=None)
alias(name='List', asname=None)
alias(name='Callable', asname=None)
alias(name='Union', asname=None)
alias(name='Dict', asname=None)
alias(name='Tuple', asname=None)
alias(name='logging', asname=None)
alias(name='time', asname=None)
alias(name='numpy', asname='np')
alias(name='QuantumCircuit', asname=None)
alias(name='Parameter', asname=None)
alias(name='RealAmplitudes', asname=None)
alias(name='PauliOp', asname=None)
alias(name='Backend', asname=None)
alias(name='OperatorBase', asname=None)
alias(name='ExpectationBase', asname=None)
alias(name='ExpectationFactory', asname=None)
alias(name='StateFn', asname=None)
alias(name='CircuitStateFn', asname=None)
alias(name='ListOp', asname=None)
alias(name='CircuitSampler', asname=None)
alias(name='PauliSumOp', asname=None)
alias(name='GradientBase', asname=None)
alias(name='validate_min', asname=None)
alias(name='is_aer_provider', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='ListOrDict', asname=None)
alias(name='Optimizer', asname=None)
alias(name='SLSQP', asname=None)
alias(name='Minimizer', asname=None)
alias(name='VariationalAlgorithm', asname=None)
alias(name='VariationalResult', asname=None)
alias(name='Eigensolver', asname=None)
alias(name='EigensolverResult', asname=None)
alias(name='_validate_bounds', asname=None)
alias(name='_validate_initial_point', asname=None)
alias(name='AlgorithmError', asname=None)
alias(name='eval_observables', asname=None)
Name(id='logger', ctx=Store())
Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])
Name(id='VariationalAlgorithm', ctx=Load())
Name(id='Eigensolver', ctx=Load())
Expr(value=Str(s='The Variational Quantum Deflation algorithm.\n\n    `VQD <https://arxiv.org/abs/1805.08138>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the k eigenvalues of the Hamiltonian :math:`H` of a given system.\n\n    The algorithm computes excited state energies of generalised hamiltonians\n    by optimising over a modified cost function where each succesive eigen value\n    is calculated iteratively by introducing an overlap term with all\n    the previously computed eigenstaes that must be minimised, thus ensuring\n    higher energy eigen states are found.\n\n    An instance of VQD requires defining three algorithmic sub-components:\n    an integer k denoting the number of eigenstates to calculate, a trial\n    state (a.k.a. ansatz)which is a :class:`QuantumCircuit`,\n    and one of the classical :mod:`~qiskit.algorithms.optimizers`.\n    The ansatz is varied, via its set of parameters, by the optimizer,\n    such that it works towards a state, as determined by the parameters\n    applied to the ansatz, that will result in the minimum expectation values\n    being measured of the input operator (Hamiltonian). The algorithm does\n    this by iteratively refining each excited state to be orthogonal to all\n    the previous excited states.\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQD will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQD\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='betas', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), Num(n=2), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as ansatz for the wave function.\n            k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n            betas: beta parameter in the VQD paper. Should have size k -1, the number of excited states.\n                It is a hyperparameter that balances the contribution of the overlap\n                term to the cost function and has a default value computed as\n                mean square sum of coefficients of observable.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n                Only used to compute the ground state at the moment.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQD performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Store())], value=Name(id='k', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=Name(id='betas', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[]))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n                If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets a quantum_instance.')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None)
FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load()))
FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQD as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None)
FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Preparing the setting of VQD into a string.\n\n        Returns:\n            str: the formatted setting of VQD.\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None)
FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='_eval_aux_ops', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameters', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-12)]), body=[Assign(targets=[Name(id='sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='aux_op_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='aux_op_expect', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='aux_op_expect_sampled', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='aux_op_expect', ctx=Load())], keywords=[])), Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])), Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])]), body=[Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))]))], orelse=[]), Assign(targets=[Name(id='std_devs', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='aux_op_means', ctx=Store())], value=BinOp(left=Name(id='values', ctx=Load()), op=Mult(), right=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())]))), Assign(targets=[Name(id='aux_op_results', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='aux_op_means', ctx=Load()), Name(id='std_devs', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='key_value_iterator', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Name(id='aux_operator_eigenvalues', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='compute_eigenvalues', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='upper_bound', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQDResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=List(elts=[], ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[]), For(target=Name(id='step', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eigenvalue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))])], orelse=[]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='EigensolverResult', ctx=Load()))
FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='step', annotation=Name(id='int', ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load())), arg(arg='prev_states', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False), NameConstant(value=None)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This return value is the objective function to be passed to the optimizer for evaluation.\n\n        Args:\n            step: level of enegy being calculated. 0 for ground, 1 for first excited state and so on.\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n            prev_states: List of parameters from previous rounds of optimization.\n\n\n        Returns:\n            A callable that computes and returns the energy of the hamiltonian\n            of each parameter, and, optionally, the expectation\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n            AlgorithmError: If operator was not provided.\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='overlap_op', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='prev_circ', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Name(id='VariationalResult', ctx=Load())
Name(id='EigensolverResult', ctx=Load())
Expr(value=Str(s='VQD Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
FunctionDef(name='eigenstates', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstates', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
Store()
Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load())
Name(id='__name__', ctx=Load())
Load()
Load()
Str(s='The Variational Quantum Deflation algorithm.\n\n    `VQD <https://arxiv.org/abs/1805.08138>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the k eigenvalues of the Hamiltonian :math:`H` of a given system.\n\n    The algorithm computes excited state energies of generalised hamiltonians\n    by optimising over a modified cost function where each succesive eigen value\n    is calculated iteratively by introducing an overlap term with all\n    the previously computed eigenstaes that must be minimised, thus ensuring\n    higher energy eigen states are found.\n\n    An instance of VQD requires defining three algorithmic sub-components:\n    an integer k denoting the number of eigenstates to calculate, a trial\n    state (a.k.a. ansatz)which is a :class:`QuantumCircuit`,\n    and one of the classical :mod:`~qiskit.algorithms.optimizers`.\n    The ansatz is varied, via its set of parameters, by the optimizer,\n    such that it works towards a state, as determined by the parameters\n    applied to the ansatz, that will result in the minimum expectation values\n    being measured of the input operator (Hamiltonian). The algorithm does\n    this by iteratively refining each excited state to be orthogonal to all\n    the previous excited states.\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQD will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQD\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='betas', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), Num(n=2), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as ansatz for the wave function.\n            k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n            betas: beta parameter in the VQD paper. Should have size k -1, the number of excited states.\n                It is a hyperparameter that balances the contribution of the overlap\n                term to the cost function and has a default value computed as\n                mean square sum of coefficients of observable.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n                Only used to compute the ground state at the moment.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQD performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        '))
Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[]))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Store())], value=Name(id='k', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=Name(id='betas', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None))
If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load()))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[]))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the ansatz.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n                If None is passed, RealAmplitudes is used by default.\n\n        '))
If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the gradient.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the gradient.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))
Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns quantum instance.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets a quantum_instance.'))
If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns initial point.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets initial point'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))
Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns max_evals_grouped'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets max_evals_grouped'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load()))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))
Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns include_custom'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        '))
If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])
Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns callback'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets callback'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))
Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))
Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.'))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns optimizer'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='Optimizer', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        '))
If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))
Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Prepare the setting of VQD as a string.'))
Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))
Assign(targets=[Name(id='params', ctx=Store())], value=Str(s=''))
For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)]))
Return(value=Name(id='ret', ctx=Load()))
Name(id='property', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Preparing the setting of VQD into a string.\n\n        Returns:\n            str: the formatted setting of VQD.\n        '))
Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n'))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
Return(value=Name(id='ret', ctx=Load()))
arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)])
Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        "))
If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))])
Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[]))
Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]))
If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='expect_op', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        '))
Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load()))
FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None)
Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[]))
Return(value=Name(id='circuits', ctx=Load()))
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Return(value=NameConstant(value=True))
Name(id='classmethod', ctx=Load())
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='parameters', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-12)])
Assign(targets=[Name(id='sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))])
Assign(targets=[Name(id='aux_op_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[]))
Assign(targets=[Name(id='aux_op_expect', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='aux_op_expect_sampled', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='aux_op_expect', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='values', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[]))
Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])], keywords=[]))
If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])), Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])]), body=[Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))]))], orelse=[])
Assign(targets=[Name(id='std_devs', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[]))
Assign(targets=[Name(id='aux_op_means', ctx=Store())], value=BinOp(left=Name(id='values', ctx=Load()), op=Mult(), right=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())])))
Assign(targets=[Name(id='aux_op_results', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='aux_op_means', ctx=Load()), Name(id='std_devs', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=Dict(keys=[], values=[])), Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[]))])
For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Name(id='key_value_iterator', ctx=Load()), body=[If(test=Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])], orelse=[])
Return(value=Name(id='aux_operator_eigenvalues', ctx=Load()))
Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))])
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='upper_bound', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQDResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=List(elts=[], ctx=Load()))
If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=List(elts=[], ctx=Load()))], orelse=[])
For(target=Name(id='step', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[])), Assign(targets=[Name(id='eigenvalue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))])], orelse=[])
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[])
Return(value=Name(id='result', ctx=Load()))
Name(id='EigensolverResult', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='step', annotation=Name(id='int', ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load())), arg(arg='prev_states', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False), NameConstant(value=None)])
Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This return value is the objective function to be passed to the optimizer for evaluation.\n\n        Args:\n            step: level of enegy being calculated. 0 for ground, 1 for first excited state and so on.\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n            prev_states: List of parameters from previous rounds of optimization.\n\n\n        Returns:\n            A callable that computes and returns the energy of the hamiltonian\n            of each parameter, and, optionally, the expectation\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n            AlgorithmError: If operator was not provided.\n\n        '))
Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()))
If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[])
If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[])
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='overlap_op', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()))
Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))]))
For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='prev_circ', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[])
FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))], orelse=[]), AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None)
If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='energy_evaluation', ctx=Load()))
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.'))
Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[]))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))])
Return(value=Name(id='state', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Str(s='VQD Result.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns number of cost optimizer evaluations'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets number of cost function evaluations'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='return eigen state'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='set eigen state'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='eigenstates', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
Name(id='logging', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='k', annotation=Name(id='int', ctx=Load()))
arg(arg='betas', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))
arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))
arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Num(n=2)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=False)
Num(n=1)
NameConstant(value=None)
NameConstant(value=None)
Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as ansatz for the wave function.\n            k: the number of eigenvalues to return. Returns the lowest k eigenvalues.\n            betas: beta parameter in the VQD paper. Should have size k -1, the number of excited states.\n                It is a hyperparameter that balances the contribution of the overlap\n                term to the cost function and has a default value computed as\n                mean square sum of coefficients of observable.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQD will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n                Only used to compute the ground state at the moment.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQD performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')
Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())
Name(id='max_evals_grouped', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())
Name(id='expectation', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())
Name(id='include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())
Name(id='ansatz', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Store())
Name(id='k', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())
Name(id='betas', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())
Name(id='optimizer', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())
Name(id='initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())
Name(id='gradient', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
NameConstant(value=None)
Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Num(n=0)
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())
Name(id='callback', ctx=Load())
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[])
arg(arg='self', annotation=None)
Str(s='Returns the ansatz.')
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n                If None is passed, RealAmplitudes is used by default.\n\n        ')
Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
Name(id='ansatz', ctx=Load())
Name(id='ansatz', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns the gradient.')
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Sets the gradient.')
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())
Name(id='gradient', ctx=Load())
Name(id='gradient', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns quantum instance.')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Sets a quantum_instance.')
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())
Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))])
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns initial point.')
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Str(s='Sets initial point')
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())
Name(id='initial_point', ctx=Load())
Name(id='initial_point', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns max_evals_grouped')
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))
Str(s='Sets max_evals_grouped')
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())
Name(id='max_evals_grouped', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[])
Name(id='max_evals_grouped', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns include_custom')
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))
Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')
Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))
Name(id='include_custom', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns callback')
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Sets callback')
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())
Name(id='callback', ctx=Load())
Name(id='callback', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
Name(id='exp', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
Str(s='Check that the number of qubits of operator and ansatz match.')
BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])
arg(arg='self', annotation=None)
Str(s='Returns optimizer')
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))
Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')
Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())
Name(id='optimizer', ctx=Load())
Name(id='optimizer', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Prepare the setting of VQD as a string.')
Name(id='ret', ctx=Store())
JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])
Name(id='params', ctx=Store())
Str(s='')
Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])
Name(id='ret', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Preparing the setting of VQD into a string.\n\n        Returns:\n            str: the formatted setting of VQD.\n        ')
Name(id='ret', ctx=Store())
Str(s='\n')
Name(id='ret', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Name(id='ret', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=False)
Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")
Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))
Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))
Name(id='wave_function', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])
Name(id='observable_meas', ctx=Store())
Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])
Name(id='ansatz_circuit_op', ctx=Store())
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])
Name(id='expect_op', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])
Name(id='return_expectation', ctx=Load())
Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))
Name(id='expect_op', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')
Name(id='expect_op', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])
Name(id='circuits', ctx=Store())
List(elts=[], ctx=Load())
arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])
Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])
Name(id='circuits', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
arg(arg='cls', annotation=None)
NameConstant(value=True)
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='parameters', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
arg(arg='aux_operators', annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()))
arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))
arg(arg='threshold', annotation=Name(id='float', ctx=Load()))
Num(n=1e-12)
Name(id='sampler', ctx=Store())
Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])
Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='list_op', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Name(id='aux_op_meas', ctx=Store())
Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])
Name(id='aux_op_expect', ctx=Store())
Call(func=Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='aux_op_expect_sampled', ctx=Store())
Call(func=Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='aux_op_expect', ctx=Load())], keywords=[])
Name(id='values', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])
Name(id='variances', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])], keywords=[])
BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])), Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])])
Assign(targets=[Name(id='variances', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))]))
Name(id='std_devs', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])
Name(id='aux_op_means', ctx=Store())
BinOp(left=Name(id='values', ctx=Load()), op=Mult(), right=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())]))
Name(id='aux_op_results', ctx=Store())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='aux_op_means', ctx=Load()), Name(id='std_devs', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='aux_operator_eigenvalues', ctx=Store())], value=Dict(keys=[], values=[]))
Assign(targets=[Name(id='key_value_iterator', ctx=Store())], value=Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[]))
Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())
Name(id='key_value_iterator', ctx=Load())
If(test=Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))], orelse=[])
Name(id='aux_operator_eigenvalues', ctx=Load())
Name(id='ListOrDict', ctx=Load())
Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())
NameConstant(value=True)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Name(id='initial_point', ctx=Store())
Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Name(id='bounds', ctx=Store())
Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Name(id='aux_operators', ctx=Load())
Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))])
For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[])
Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))
Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='upper_bound', ctx=Store())], value=IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())], value=BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load())))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Name(id='result', ctx=Store())
Call(func=Name(id='VQDResult', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())
List(elts=[], ctx=Load())
Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='aux_values', ctx=Store())], value=List(elts=[], ctx=Load()))
Name(id='step', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0))
Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))])
Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]))
If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))])
Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load())))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='eigenvalue', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[]))
If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))], orelse=[])
If(test=Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))])
Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Store())
Call(func=Name(id='ListOp', ctx=Load()), args=[ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())], keywords=[])
Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))
Name(id='result', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='step', annotation=Name(id='int', ctx=Load()))
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))
arg(arg='prev_states', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=False)
NameConstant(value=None)
Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This return value is the objective function to be passed to the optimizer for evaluation.\n\n        Args:\n            step: level of enegy being calculated. 0 for ground, 1 for first excited state and so on.\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n            prev_states: List of parameters from previous rounds of optimization.\n\n\n        Returns:\n            A callable that computes and returns the energy of the hamiltonian\n            of each parameter, and, optionally, the expectation\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n            AlgorithmError: If operator was not provided.\n\n        ')
Name(id='num_parameters', ctx=Store())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)
Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)
BoolOp(op=And(), values=[Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])])
Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[]), cause=None)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Name(id='overlap_op', ctx=Store())
List(elts=[], ctx=Load())
Name(id='ansatz_params', ctx=Store())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])
Name(id='state', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Assign(targets=[Name(id='prev_circ', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[]))
arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[]))
Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))]))
Assign(targets=[Name(id='mean', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[]))
For(target=Name(id='state', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))], orelse=[])
AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]))
Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))
Name(id='return_expectation', ctx=Load())
Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))
Name(id='energy_evaluation', ctx=Load())
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='optimal_parameters', annotation=None)
Str(s='Get the simulation outcome of the ansatz, provided with parameters.')
Name(id='optimal_circuit', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])
Name(id='state_fn', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))
Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))
Name(id='state', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='Returns number of cost optimizer evaluations')
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='int', ctx=Load()))
Str(s='Sets number of cost function evaluations')
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())
Name(id='value', ctx=Load())
Name(id='cost_function_evals', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='return eigen state')
Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Str(s='set eigen state')
Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstates', ctx=Store())
Name(id='value', ctx=Load())
Name(id='eigenstates', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Name(id='int', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Name(id='int', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='validate_min', ctx=Load())
Str(s='max_evals_grouped')
Name(id='max_evals_grouped', ctx=Load())
Num(n=1)
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='quantum_instance', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Name(id='ansatz', ctx=Load())
Is()
NameConstant(value=None)
Name(id='ansatz', ctx=Store())
Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='CircuitSampler', ctx=Load())
Name(id='quantum_instance', ctx=Load())
keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load())
Name(id='max_evals_grouped', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='bool', ctx=Load())
Name(id='include_custom', ctx=Load())
NotEq()
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())
Name(id='include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())
NameConstant(value=None)
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='ExpectationBase', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
And()
Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())])
Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())
Name(id='optimizer', ctx=Load())
Is()
NameConstant(value=None)
Name(id='optimizer', ctx=Store())
Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[])
Name(id='isinstance', ctx=Load())
Name(id='optimizer', ctx=Load())
Name(id='Optimizer', ctx=Load())
Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Store()
Str(s='Algorithm: ')
FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None)
Str(s='\n')
Store()
Name(id='key', ctx=Store())
Name(id='value', ctx=Store())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load())
Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')])
If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])
Store()
FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)
Load()
Store()
Store()
Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())
Store()
FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='ret', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[])
Name(id='ret', ctx=Store())
Add()
Str(s='ansatz has not been set')
Store()
Store()
FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)
Store()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='OperatorBase', ctx=Load())
Name(id='bool', ctx=Load())
Name(id='operator', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load())
Name(id='operator', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load())
Is()
NameConstant(value=None)
Name(id='expectation', ctx=Store())
Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))])
Name(id='expectation', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load())
Name(id='parameter', ctx=Load())
Store()
Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load())
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])
Store()
Name(id='CircuitStateFn', ctx=Load())
Name(id='wave_function', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load())
Load()
Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='OperatorBase', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load())
Store()
Load()
arg(arg='op', annotation=None)
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])
Name(id='extract_circuits', ctx=Load())
Name(id='expect_op', ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())
Name(id='ExpectationBase', ctx=Load())
Name(id='float', ctx=Load())
Store()
Name(id='CircuitSampler', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='dict', ctx=Load())
Name(id='list_op', ctx=Store())
Call(func=Name(id='ListOp', ctx=Load()), args=[Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])
Name(id='list_op', ctx=Store())
Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load())
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='list_op', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])
Store()
Attribute(value=Name(id='aux_op_meas', ctx=Load()), attr='compose', ctx=Load())
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])], keywords=[])
Store()
Attribute(value=Name(id='sampler', ctx=Load()), attr='convert', ctx=Load())
Name(id='aux_op_expect', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Call(func=Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='aux_op_expect_sampled', ctx=Load())], keywords=[])
And()
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[]))
Compare(left=Name(id='variances', ctx=Load()), ops=[Eq()], comparators=[Num(n=0.0)])
Name(id='variances', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])], keywords=[keyword(arg='dtype', value=Name(id='float', ctx=Load()))])
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=Name(id='variances', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))
Store()
Name(id='values', ctx=Load())
Mult()
Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Name(id='threshold', ctx=Load())])
Store()
Name(id='zip', ctx=Load())
Name(id='aux_op_means', ctx=Load())
Name(id='std_devs', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='list', ctx=Load())
Name(id='aux_operator_eigenvalues', ctx=Store())
BinOp(left=List(elts=[NameConstant(value=None)], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Name(id='key_value_iterator', ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_op_results', ctx=Load())], keywords=[])
Name(id='aux_operator_eigenvalues', ctx=Store())
Dict(keys=[], values=[])
Name(id='key_value_iterator', ctx=Store())
Call(func=Name(id='zip', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), Name(id='aux_op_results', ctx=Load())], keywords=[])
Name(id='key', ctx=Store())
Name(id='value', ctx=Store())
Store()
Load()
Compare(left=Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=Name(id='value', ctx=Load()))
Load()
Load()
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='OperatorBase', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_eigenvalues', ctx=Load())
Name(id='operator', ctx=Load())
Name(id='aux_operators', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load())
Name(id='operator', ctx=Load())
Store()
Name(id='_validate_initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Store()
Name(id='_validate_bounds', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='zero_op', ctx=Store())
Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))
Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store())
Name(id='key_op_iterator', ctx=Load())
If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])
Name(id='aux_operators', ctx=Store())
Name(id='converted', ctx=Load())
Name(id='aux_operators', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load())
Is()
NameConstant(value=None)
Name(id='upper_bound', ctx=Store())
IfExp(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[]), body=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), orelse=BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])))
Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Store())
BinOp(left=List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()))
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='beta autoevaluated to %s'), Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Store()
Name(id='VQDResult', ctx=Load())
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='aux_operators', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='aux_values', ctx=Store())
List(elts=[], ctx=Load())
Store()
Name(id='range', ctx=Load())
Num(n=1)
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load()), op=Add(), right=Num(n=1))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='step', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True)), keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))])
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[])
Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))
Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))
Name(id='start_time', ctx=Store())
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[])
Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))
Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))
Name(id='eval_time', ctx=Store())
BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eval_time', ctx=Load())], keywords=[])
Name(id='eigenvalue', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='eigenvalue', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])
Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]))
Assign(targets=[Name(id='aux_value', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))]))
Expr(value=Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[]))
Compare(left=Name(id='step', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))
Name(id='result', ctx=Load())
Store()
Name(id='ListOp', ctx=Load())
ListComp(elt=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)])
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())
Name(id='aux_operators', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())
Name(id='aux_values', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='OperatorBase', ctx=Load())
Name(id='bool', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='num_parameters', ctx=Load())
Eq()
Num(n=0)
Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[])
Name(id='operator', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[])
And()
Compare(left=Name(id='step', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)])
Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1)), ops=[NotEq()], comparators=[Name(id='step', ctx=Load())])
Call(func=Name(id='RuntimeError', ctx=Load()), args=[JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load())
Name(id='operator', ctx=Load())
Store()
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='expect_op', ctx=Store())
Name(id='expectation', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load())
Name(id='ansatz_params', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='return_expectation', value=NameConstant(value=True))
Store()
Name(id='range', ctx=Load())
BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))
Name(id='prev_circ', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[])
arg(arg='parameters', annotation=None)
Name(id='parameter_sets', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])
Name(id='param_bindings', ctx=Store())
Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])
Name(id='sampled_expect_op', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])
Name(id='mean', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])
Name(id='state', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Assign(targets=[Name(id='sampled_final_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))]))
Assign(targets=[Name(id='cost', ctx=Store())], value=Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[]))
AugAssign(target=Name(id='mean', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Add()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])
IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='mean', ctx=Load()), orelse=Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Load()
Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Name(id='optimal_parameters', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Name(id='state', ctx=Store())
Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load())
Name(id='state', ctx=Store())
Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load())
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Load()
Store()
Name(id='RealAmplitudes', ctx=Load())
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[])
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
Load()
Load()
Name(id='operator', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load())
NotEq()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))
ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='Optimizer', ctx=Load()))
Load()
Load()
Store()
Name(id='SLSQP', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())
Store()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load())
Load()
Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Eq()
Str(s='_')
BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))
AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))
Name(id='params', ctx=Load())
Str(s='==================== Setting of {} ============================\n')
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load())
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Str(s='{}'), attr='format', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='The operator was never provided.')
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load())
keyword(arg='operator', value=Name(id='operator', ctx=Load()))
keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()))
keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))
Store()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Name(id='expectation', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='is_measurement', value=NameConstant(value=True))
Load()
Load()
Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[])
Load()
Name(id='expect_op', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
Name(id='OperatorBase', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()))
Load()
Load()
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[])
Load()
Name(id='isinstance', ctx=Load())
Name(id='op', ctx=Load())
Name(id='CircuitStateFn', ctx=Load())
Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[])
For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='ListOrDict', ctx=Load())
Index(value=Name(id='OperatorBase', ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='ListOp', ctx=Load())
Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])
Store()
Name(id='ListOp', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='list_op', ctx=Load())
keyword(arg='is_measurement', value=NameConstant(value=True))
Name(id='aux_op_meas', ctx=Load())
Load()
Name(id='CircuitStateFn', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[])
Name(id='sampler', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='aux_op_expect_sampled', ctx=Load()), attr='eval', ctx=Load())
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load())
Name(id='aux_op_expect_sampled', ctx=Load())
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='variances', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], keywords=[])
Name(id='variances', ctx=Load())
Eq()
Num(n=0.0)
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
keyword(arg='dtype', value=Name(id='float', ctx=Load()))
Name(id='np', ctx=Load())
Load()
Name(id='variances', ctx=Load())
Div()
Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='values', ctx=Load())], keywords=[])
Gt()
Name(id='threshold', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Store()
List(elts=[NameConstant(value=None)], ctx=Load())
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Store()
Name(id='enumerate', ctx=Load())
Name(id='aux_op_results', ctx=Load())
Store()
Store()
Name(id='zip', ctx=Load())
Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])
Name(id='aux_op_results', ctx=Load())
Store()
Store()
Subscript(value=Name(id='aux_operators', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Load())
IsNot()
NameConstant(value=None)
Subscript(value=Name(id='aux_operator_eigenvalues', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())
Name(id='value', ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()))
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load())
List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='list', ctx=Load())
Name(id='key_op_iterator', ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Name(id='converted', ctx=Store())
BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Name(id='key_op_iterator', ctx=Store())
Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
Name(id='converted', ctx=Store())
Dict(keys=[], values=[])
Name(id='key', ctx=Store())
Name(id='op', ctx=Store())
Store()
Load()
Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))
Store()
Load()
Store()
Name(id='self', ctx=Load())
Load()
Store()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='PauliOp', ctx=Load())], keywords=[])
Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[])
BinOp(left=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), op=Mult(), right=Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Name(id='self', ctx=Load())
Store()
List(elts=[BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))], ctx=Load())
Mult()
Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='beta autoevaluated to %s')
Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Store()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='k', ctx=Load())
Add()
Num(n=1)
Name(id='self', ctx=Load())
Store()
Name(id='energy_evaluation', ctx=Store())
Name(id='expectation', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load())
Name(id='step', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='return_expectation', value=NameConstant(value=True))
keyword(arg='prev_states', value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()))
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Name(id='GradientBase', ctx=Load())
Name(id='gradient', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))])
Name(id='gradient', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Store()
Name(id='time', ctx=Load())
Name(id='callable', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Name(id='opt_result', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))])
Name(id='opt_result', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))])
Store()
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Sub()
Name(id='start_time', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='append', ctx=Load())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), attr='append', ctx=Load())
Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load()), attr='append', ctx=Load())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load()), attr='append', ctx=Load())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load()), attr='append', ctx=Load())
Name(id='eval_time', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]), attr='eval', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load()), attr='append', ctx=Load())
Name(id='eigenvalue', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Name(id='aux_operators', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='bound_ansatz', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Name(id='aux_value', ctx=Store())
Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])
Call(func=Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='aux_value', ctx=Load())], keywords=[])
Name(id='step', ctx=Load())
Eq()
Num(n=1)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals'), Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])
Load()
Load()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='vec', ctx=Load())], keywords=[])
comprehension(target=Name(id='vec', ctx=Store()), iter=Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load()), ifs=[], is_async=0)
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='RuntimeError', ctx=Load())
Str(s='The ansatz must be parameterized, but has 0 free parameters.')
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='The operator was never provided.')
Name(id='step', ctx=Load())
Gt()
Num(n=1)
BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[]), op=Add(), right=Num(n=1))
NotEq()
Name(id='step', ctx=Load())
Name(id='RuntimeError', ctx=Load())
JoinedStr(values=[Str(s='Passed previous states of the wrong size.Passed array has length '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)])
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Load()
Name(id='step', ctx=Load())
Sub()
Num(n=1)
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Subscript(value=Name(id='prev_states', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())
Attribute(value=Name(id='overlap_op', ctx=Load()), attr='append', ctx=Load())
BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load())
Name(id='parameters', ctx=Load())
Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())
Store()
Name(id='dict', ctx=Load())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load())
Name(id='expect_op', ctx=Load())
keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])
Store()
Name(id='range', ctx=Load())
BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))
Name(id='sampled_final_op', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])
Name(id='cost', ctx=Store())
Call(func=Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])
Name(id='mean', ctx=Store())
Add()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))], keywords=[])
Name(id='self', ctx=Load())
Store()
Name(id='len', ctx=Load())
Name(id='mean', ctx=Load())
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)])
Name(id='mean', ctx=Load())
Subscript(value=Name(id='mean', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='energy_evaluation', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[])
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load())
Load()
Store()
Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[])
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='is_aer_provider', ctx=Load())
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='operator', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())
Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='AttributeError', ctx=Load())
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))
Load()
Name(id='Optimizer', ctx=Load())
Load()
Name(id='optimizer', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='key', ctx=Load())
Index(value=Num(n=0))
Load()
And()
Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())])
Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Name(id='params', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[])
Name(id='params', ctx=Store())
Add()
JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Str(s='{}')
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load())
keyword(arg='output', value=Str(s='text'))
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load())
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Name(id='ExpectationFactory', ctx=Load())
Load()
Name(id='operator', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load())
Name(id='ansatz_circuit_op', ctx=Load())
Load()
Load()
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load())
Name(id='parameter', ctx=Load())
Name(id='operator', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load())
Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='op', ctx=Load())
Name(id='ListOp', ctx=Load())
Name(id='op_i', ctx=Store())
Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load())
Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Load()
Load()
Name(id='list', ctx=Load())
Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
NameConstant(value=True)
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Name(id='parameters', ctx=Load())
Load()
Load()
Name(id='aux_op_expect_sampled', ctx=Load())
Load()
Load()
Name(id='expectation', ctx=Load())
Load()
Load()
Name(id='isinstance', ctx=Load())
Name(id='variances', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Name(id='values', ctx=Load())
Load()
NameConstant(value=None)
Load()
Name(id='len', ctx=Load())
Name(id='aux_operators', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='aux_operators', ctx=Load()), attr='keys', ctx=Load())
Load()
Name(id='aux_operators', ctx=Load())
Index(value=Name(id='key', ctx=Load()))
Load()
Name(id='aux_operator_eigenvalues', ctx=Load())
Index(value=Name(id='key', ctx=Load()))
Store()
Load()
Load()
Tuple(elts=[Name(id='complex', ctx=Load()), Name(id='complex', ctx=Load())], ctx=Load())
Load()
Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='PauliSumOp', ctx=Load())
Load()
Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='enumerate', ctx=Load())
Name(id='aux_operators', ctx=Load())
Store()
List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load())
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load())
Store()
Store()
Store()
Name(id='op', ctx=Load())
IsNot()
NameConstant(value=None)
Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())
IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load()))
Load()
Name(id='isinstance', ctx=Load())
Name(id='operator', ctx=Load())
Name(id='PauliOp', ctx=Load())
Name(id='abs', ctx=Load())
Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())
Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())], keywords=[])
Mult()
Call(func=Name(id='sum', ctx=Load()), args=[GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Load()
BinOp(left=Name(id='upper_bound', ctx=Load()), op=Mult(), right=Num(n=10))
Load()
Name(id='self', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load())
BinOp(left=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[]))
keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Store()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load()))
keyword(arg='x0', value=Name(id='initial_point', ctx=Load()))
keyword(arg='jac', value=Name(id='gradient', ctx=Load()))
keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load())
keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load()))
keyword(arg='x0', value=Name(id='initial_point', ctx=Load()))
keyword(arg='jac', value=Name(id='gradient', ctx=Load()))
keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))
Name(id='time', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Load()
Name(id='opt_result', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())
Load()
Name(id='dict', ctx=Load())
Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Load())
Load()
Name(id='opt_result', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Load())
Load()
Name(id='opt_result', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalues', ctx=Load())
Load()
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load())
Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Store()
Name(id='eval_observables', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Name(id='bound_ansatz', ctx=Load())
Name(id='aux_operators', ctx=Load())
keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))
Attribute(value=Name(id='aux_values', ctx=Load()), attr='append', ctx=Load())
Name(id='aux_value', ctx=Load())
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Ground state optimization complete in %s seconds.\nFound opt_params %s in %s evals')
Name(id='eval_time', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='%s excited state optimization complete in %s s.\nFound opt_parms %s in %s evals')
Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Name(id='eval_time', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())
Name(id='StateFn', ctx=Load())
Name(id='vec', ctx=Load())
Name(id='vec', ctx=Store())
Attribute(value=Name(id='result', ctx=Load()), attr='eigenstates', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])
Add()
Num(n=1)
Load()
Load()
Str(s='Passed previous states of the wrong size.Passed array has length ')
FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[]), conversion=-1, format_spec=None)
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='prev_states', ctx=Load())
Index(value=Name(id='state', ctx=Load()))
Load()
Name(id='overlap_op', ctx=Load())
Load()
UnaryOp(op=Invert(), operand=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[]))
MatMult()
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Name(id='np', ctx=Load())
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='num_parameters', ctx=Load())
Load()
Load()
Name(id='zip', ctx=Load())
Name(id='ansatz_params', ctx=Load())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load())
Load()
Load()
Name(id='param_bindings', ctx=Load())
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load())
Load()
Name(id='step', ctx=Load())
Sub()
Num(n=1)
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load())
Subscript(value=Name(id='overlap_op', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())
keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))
Store()
Attribute(value=Name(id='sampled_final_op', ctx=Load()), attr='eval', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
BinOp(left=BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])), op=Mult(), right=Name(id='cost', ctx=Load()))
Load()
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='mean', ctx=Load())], keywords=[])
Gt()
Num(n=1)
Load()
Name(id='mean', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load())
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])
Load()
Name(id='state_fn', ctx=Load())
Load()
Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='Dict', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='super', ctx=Load())
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Name(id='quantum_instance', ctx=Load())
Load()
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Store()
Name(id='operator', ctx=Load())
Load()
Load()
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[])
Name(id='ex', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Num(n=0)
Str(s='initial_point')
In()
Name(id='key', ctx=Load())
Name(id='value', ctx=Load())
Is()
NameConstant(value=None)
Store()
Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load())
Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load())
Str(s='Random seed')
Store()
Str(s='-- ')
FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None)
Str(s=': ')
FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None)
Str(s='\n')
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Str(s='text')
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='observable_meas', ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='circuits', ctx=Load())
Load()
Name(id='op', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='op', ctx=Load())
Load()
Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[])
Load()
Load()
Attribute(value=Name(id='aux_operators', ctx=Load()), attr='values', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='aux_operators', ctx=Load())
Load()
Load()
Name(id='key', ctx=Load())
Load()
Name(id='key', ctx=Load())
Name(id='complex', ctx=Load())
Name(id='complex', ctx=Load())
Load()
Name(id='ListOrDict', ctx=Load())
Index(value=Name(id='OperatorBase', ctx=Load()))
Load()
Load()
Load()
BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()))
Num(n=0)
Load()
Load()
Load()
Name(id='zero_op', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='aux_operators', ctx=Load())
Load()
Load()
Name(id='converted', ctx=Load())
Index(value=Name(id='key', ctx=Load()))
Store()
Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Name(id='zero_op', ctx=Load())
Name(id='op', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='operator', ctx=Load())
Load()
Name(id='abs', ctx=Load())
Attribute(value=Name(id='operator', ctx=Load()), attr='coeff', ctx=Load())
Name(id='sum', ctx=Load())
GeneratorExp(elt=Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)])
Name(id='upper_bound', ctx=Load())
Mult()
Num(n=10)
Load()
Load()
Name(id='self', ctx=Load())
Load()
Num(n=0)
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Load()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])
MatMult()
Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='energy_evaluation', ctx=Load())
Name(id='initial_point', ctx=Load())
Name(id='gradient', ctx=Load())
Name(id='bounds', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Load()
Name(id='energy_evaluation', ctx=Load())
Name(id='initial_point', ctx=Load())
Name(id='gradient', ctx=Load())
Name(id='bounds', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='zip', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())
Name(id='result', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Attribute(value=Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[]), attr='reduce', ctx=Load())
Name(id='result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='expectation', ctx=Load())
Name(id='aux_values', ctx=Load())
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
BinOp(left=Name(id='step', ctx=Load()), op=Sub(), right=Num(n=1))
Load()
Name(id='result', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='result', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
Name(id='len', ctx=Load())
Name(id='prev_states', ctx=Load())
Call(func=Name(id='str', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])], keywords=[])
Name(id='self', ctx=Load())
Load()
Load()
Name(id='state', ctx=Load())
Load()
Invert()
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='prev_circ', ctx=Load())], keywords=[])
Name(id='CircuitStateFn', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
USub()
Num(n=1)
Load()
Load()
Load()
Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='sampled_expect_op', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load())
Load()
Name(id='overlap_op', ctx=Load())
Index(value=Name(id='state', ctx=Load()))
Load()
Name(id='param_bindings', ctx=Load())
Name(id='sampled_final_op', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load()), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[]))
Mult()
Name(id='cost', ctx=Load())
Name(id='len', ctx=Load())
Name(id='mean', ctx=Load())
Load()
Num(n=0)
Name(id='np', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='optimal_circuit', ctx=Load())
Load()
Name(id='state_fn', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Load()
Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')
Load()
Load()
Load()
Load()
Str(s='-- {}: {}\n')
Load()
Name(id='key', ctx=Load())
Slice(lower=Num(n=1), upper=None, step=None)
Load()
Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load())
Name(id='value', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='Parameter', ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Name(id='ExpectationBase', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='Parameter', ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='extract_circuits', ctx=Load())
Name(id='op_i', ctx=Load())
Name(id='aux_operators', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Str(s='I')
Mult()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='key', ctx=Load())
Name(id='op', ctx=Load())
Eq()
Num(n=0)
Load()
Load()
Load()
Load()
Name(id='operator', ctx=Load())
Load()
Load()
Call(func=Name(id='abs', ctx=Load()), args=[Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())], keywords=[])
comprehension(target=Name(id='operation', ctx=Store()), iter=Name(id='operator', ctx=Load()), ifs=[], is_async=0)
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='is_measurement', value=NameConstant(value=True))
Name(id='StateFn', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Name(id='list', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='opt_result', ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load()), args=[Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Load()
Load()
Load()
Load()
Name(id='result', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='step', ctx=Load())
Sub()
Num(n=1)
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Load()
Name(id='str', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='prev_states', ctx=Load())], keywords=[])
Load()
Load()
Name(id='CircuitStateFn', ctx=Load())
Name(id='prev_circ', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='state', ctx=Load())
Load()
Load()
Load()
Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load()), slice=Index(value=Name(id='state', ctx=Load())), ctx=Load())
Mult()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load()), args=[Name(id='cost', ctx=Load())], keywords=[])
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='str', ctx=Load())
Name(id='int', ctx=Load())
Load()
Load()
Name(id='Optimizer', ctx=Load())
Name(id='Minimizer', ctx=Load())
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Load()
Load()
Load()
Num(n=1)
Name(id='key', ctx=Load())
Slice(lower=Num(n=1), upper=None, step=None)
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='Parameter', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='Parameter', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='abs', ctx=Load())
Attribute(value=Name(id='operation', ctx=Load()), attr='coeff', ctx=Load())
Name(id='operation', ctx=Store())
Name(id='operator', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))]), attr='compose', ctx=Load())
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])], keywords=[])
Load()
USub()
Num(n=1)
Load()
Load()
USub()
Num(n=1)
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='len', ctx=Load())
Name(id='prev_states', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='betas', ctx=Load())
Index(value=Name(id='state', ctx=Load()))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='conj', ctx=Load())
Name(id='cost', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Num(n=1)
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='operation', ctx=Load())
Load()
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])
Load()
Name(id='CircuitStateFn', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Load()
Load()
Load()
Name(id='parameter_sets', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='state', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='StateFn', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='is_measurement', value=NameConstant(value=True))
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Load()
USub()
Num(n=1)
  metric  value
0     NC      0
DONE!
