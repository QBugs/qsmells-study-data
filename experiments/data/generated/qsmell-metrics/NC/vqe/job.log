Python 3.7.8
Module(body=[Expr(value=Str(s='The Variational Quantum Eigensolver algorithm.\n\nSee https://arxiv.org/abs/1304.3061\n')), ImportFrom(module='__future__', names=[alias(name='annotations', asname=None)], level=0), Import(names=[alias(name='logging', asname=None)]), ImportFrom(module='time', names=[alias(name='time', asname=None)], level=0), ImportFrom(module='typing', names=[alias(name='Callable', asname=None), alias(name='Dict', asname=None), alias(name='List', asname=None), alias(name='Optional', asname=None), alias(name='Tuple', asname=None), alias(name='Union', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit.circuit', names=[alias(name='Parameter', asname=None), alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library', names=[alias(name='RealAmplitudes', asname=None)], level=0), ImportFrom(module='qiskit.opflow', names=[alias(name='CircuitSampler', asname=None), alias(name='CircuitStateFn', asname=None), alias(name='ExpectationBase', asname=None), alias(name='ExpectationFactory', asname=None), alias(name='ListOp', asname=None), alias(name='OperatorBase', asname=None), alias(name='PauliSumOp', asname=None), alias(name='StateFn', asname=None)], level=0), ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None), alias(name='algorithm_globals', asname=None)], level=0), ImportFrom(module='qiskit.utils.backend_utils', names=[alias(name='is_aer_provider', asname=None)], level=0), ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0), ImportFrom(module='aux_ops_evaluator', names=[alias(name='eval_observables', asname=None)], level=2), ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2), ImportFrom(module='list_or_dict', names=[alias(name='ListOrDict', asname=None)], level=2), ImportFrom(module='optimizers', names=[alias(name='SLSQP', asname=None), alias(name='Minimizer', asname=None), alias(name='Optimizer', asname=None)], level=2), ImportFrom(module='variational_algorithm', names=[alias(name='VariationalAlgorithm', asname=None), alias(name='VariationalResult', asname=None)], level=2), ImportFrom(module='minimum_eigen_solver', names=[alias(name='MinimumEigensolver', asname=None), alias(name='MinimumEigensolverResult', asname=None)], level=1), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='VQE', bases=[Name(id='VariationalAlgorithm', ctx=Load()), Name(id='MinimumEigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Variational Quantum Eigensolver algorithm.\n\n    `VQE <https://arxiv.org/abs/1304.3061>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the minimum eigenvalue of the Hamiltonian :math:`H` of a given system.\n\n    An instance of VQE requires defining two algorithmic sub-components:\n    a trial state (a.k.a. ansatz) which is a :class:`QuantumCircuit`, and one of the classical\n    :mod:`~qiskit.algorithms.optimizers`. The ansatz is varied, via its set of parameters, by the\n    optimizer, such that it works towards a state, as determined by the parameters applied to the\n    ansatz, that will result in the minimum expectation value being measured of the input operator\n    (Hamiltonian).\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.  As an example, when building the dissociation profile of a molecule,\n    it is likely that using the previous computed optimal solution as the starting\n    initial point for the next interatomic distance is going to reduce the number of iterations\n    necessary for the variational algorithm to converge.  It provides an\n    `initial point tutorial <https://github.com/Qiskit/qiskit-tutorials-community/blob/master\n    /chemistry/h2_vqe_initial_point.ipynb>`__ detailing this use case.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQE will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQE\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    The optimizer can either be one of Qiskit\'s optimizers, such as\n    :class:`~qiskit.algorithms.optimizers.SPSA` or a callable with the following signature:\n\n    .. note::\n\n        The callable _must_ have the argument names ``fun, x0, jac, bounds`` as indicated\n        in the following code block.\n\n    .. code-block::python\n\n        from qiskit.algorithms.optimizers import OptimizerResult\n\n        def my_minimizer(fun, x0, jac=None, bounds=None) -> OptimizerResult:\n            # Note that the callable *must* have these argument names!\n            # Args:\n            #     fun (callable): the function to minimize\n            #     x0 (np.ndarray): the initial point for the optimization\n            #     jac (callable, optional): the gradient of the objective function\n            #     bounds (list, optional): a list of tuples specifying the parameter bounds\n\n            result = OptimizerResult()\n            result.x = # optimal parameters\n            result.fun = # optimal function value\n            return result\n\n    The above signature also allows to directly pass any SciPy minimizer, for instance as\n\n    .. code-block::python\n\n        from functools import partial\n        from scipy.optimize import minimize\n\n        optimizer = partial(minimize, method="L-BFGS-B")\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as Ansatz for the wave function.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQE performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n            If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum_instance')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load())), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQE as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None), FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Preparing the setting of VQE into a string.\n\n        Returns:\n            str: the formatted setting of VQE\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='Optimizer is custom callable\n'))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='compute_minimum_eigenvalue', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQEResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Name(id='eval_time', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalue', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()), op=Add(), right=Num(n=0j))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstate', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=Name(id='result', ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='MinimumEigensolverResult', ctx=Load())), FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This is the objective function to be passed to the optimizer that is used for evaluation.\n\n        Args:\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n\n\n        Returns:\n            Energy of the hamiltonian of each parameter, and, optionally, the expectation\n            converter.\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='end_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))], decorator_list=[]), ClassDef(name='VQEResult', bases=[Name(id='VariationalResult', ctx=Load()), Name(id='MinimumEigensolverResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='VQE Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstate', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[]), FunctionDef(name='_validate_initial_point', args=arguments(args=[arg(arg='point', annotation=None), arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='expected_size', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='preferred_init_points')], keywords=[])]), body=[Assign(targets=[Name(id='point', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='preferred_init_points', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds'), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='bounds', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='lower_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='upper_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store()), iter=Name(id='bounds', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='point', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Name(id='lower_bounds', ctx=Load()), Name(id='upper_bounds', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='expected_size', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])]), Return(value=Name(id='point', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='_validate_bounds', args=arguments(args=[arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds')], keywords=[]), Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load())), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])], orelse=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())))]), Return(value=Name(id='bounds', ctx=Load()))], decorator_list=[], returns=None)])
Expr(value=Str(s='The Variational Quantum Eigensolver algorithm.\n\nSee https://arxiv.org/abs/1304.3061\n'))
ImportFrom(module='__future__', names=[alias(name='annotations', asname=None)], level=0)
Import(names=[alias(name='logging', asname=None)])
ImportFrom(module='time', names=[alias(name='time', asname=None)], level=0)
ImportFrom(module='typing', names=[alias(name='Callable', asname=None), alias(name='Dict', asname=None), alias(name='List', asname=None), alias(name='Optional', asname=None), alias(name='Tuple', asname=None), alias(name='Union', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit.circuit', names=[alias(name='Parameter', asname=None), alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library', names=[alias(name='RealAmplitudes', asname=None)], level=0)
ImportFrom(module='qiskit.opflow', names=[alias(name='CircuitSampler', asname=None), alias(name='CircuitStateFn', asname=None), alias(name='ExpectationBase', asname=None), alias(name='ExpectationFactory', asname=None), alias(name='ListOp', asname=None), alias(name='OperatorBase', asname=None), alias(name='PauliSumOp', asname=None), alias(name='StateFn', asname=None)], level=0)
ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None), alias(name='algorithm_globals', asname=None)], level=0)
ImportFrom(module='qiskit.utils.backend_utils', names=[alias(name='is_aer_provider', asname=None)], level=0)
ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0)
ImportFrom(module='aux_ops_evaluator', names=[alias(name='eval_observables', asname=None)], level=2)
ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2)
ImportFrom(module='list_or_dict', names=[alias(name='ListOrDict', asname=None)], level=2)
ImportFrom(module='optimizers', names=[alias(name='SLSQP', asname=None), alias(name='Minimizer', asname=None), alias(name='Optimizer', asname=None)], level=2)
ImportFrom(module='variational_algorithm', names=[alias(name='VariationalAlgorithm', asname=None), alias(name='VariationalResult', asname=None)], level=2)
ImportFrom(module='minimum_eigen_solver', names=[alias(name='MinimumEigensolver', asname=None), alias(name='MinimumEigensolverResult', asname=None)], level=1)
Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[]))
ClassDef(name='VQE', bases=[Name(id='VariationalAlgorithm', ctx=Load()), Name(id='MinimumEigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Variational Quantum Eigensolver algorithm.\n\n    `VQE <https://arxiv.org/abs/1304.3061>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the minimum eigenvalue of the Hamiltonian :math:`H` of a given system.\n\n    An instance of VQE requires defining two algorithmic sub-components:\n    a trial state (a.k.a. ansatz) which is a :class:`QuantumCircuit`, and one of the classical\n    :mod:`~qiskit.algorithms.optimizers`. The ansatz is varied, via its set of parameters, by the\n    optimizer, such that it works towards a state, as determined by the parameters applied to the\n    ansatz, that will result in the minimum expectation value being measured of the input operator\n    (Hamiltonian).\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.  As an example, when building the dissociation profile of a molecule,\n    it is likely that using the previous computed optimal solution as the starting\n    initial point for the next interatomic distance is going to reduce the number of iterations\n    necessary for the variational algorithm to converge.  It provides an\n    `initial point tutorial <https://github.com/Qiskit/qiskit-tutorials-community/blob/master\n    /chemistry/h2_vqe_initial_point.ipynb>`__ detailing this use case.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQE will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQE\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    The optimizer can either be one of Qiskit\'s optimizers, such as\n    :class:`~qiskit.algorithms.optimizers.SPSA` or a callable with the following signature:\n\n    .. note::\n\n        The callable _must_ have the argument names ``fun, x0, jac, bounds`` as indicated\n        in the following code block.\n\n    .. code-block::python\n\n        from qiskit.algorithms.optimizers import OptimizerResult\n\n        def my_minimizer(fun, x0, jac=None, bounds=None) -> OptimizerResult:\n            # Note that the callable *must* have these argument names!\n            # Args:\n            #     fun (callable): the function to minimize\n            #     x0 (np.ndarray): the initial point for the optimization\n            #     jac (callable, optional): the gradient of the objective function\n            #     bounds (list, optional): a list of tuples specifying the parameter bounds\n\n            result = OptimizerResult()\n            result.x = # optimal parameters\n            result.fun = # optimal function value\n            return result\n\n    The above signature also allows to directly pass any SciPy minimizer, for instance as\n\n    .. code-block::python\n\n        from functools import partial\n        from scipy.optimize import minimize\n\n        optimizer = partial(minimize, method="L-BFGS-B")\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as Ansatz for the wave function.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQE performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n            If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum_instance')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load())), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQE as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None), FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Preparing the setting of VQE into a string.\n\n        Returns:\n            str: the formatted setting of VQE\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='Optimizer is custom callable\n'))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='compute_minimum_eigenvalue', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQEResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Name(id='eval_time', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalue', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()), op=Add(), right=Num(n=0j))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstate', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=Name(id='result', ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='MinimumEigensolverResult', ctx=Load())), FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This is the objective function to be passed to the optimizer that is used for evaluation.\n\n        Args:\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n\n\n        Returns:\n            Energy of the hamiltonian of each parameter, and, optionally, the expectation\n            converter.\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='end_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))], decorator_list=[])
ClassDef(name='VQEResult', bases=[Name(id='VariationalResult', ctx=Load()), Name(id='MinimumEigensolverResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='VQE Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstate', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
FunctionDef(name='_validate_initial_point', args=arguments(args=[arg(arg='point', annotation=None), arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='expected_size', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='preferred_init_points')], keywords=[])]), body=[Assign(targets=[Name(id='point', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='preferred_init_points', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds'), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='bounds', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='lower_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='upper_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store()), iter=Name(id='bounds', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='point', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Name(id='lower_bounds', ctx=Load()), Name(id='upper_bounds', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='expected_size', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])]), Return(value=Name(id='point', ctx=Load()))], decorator_list=[], returns=None)
FunctionDef(name='_validate_bounds', args=arguments(args=[arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds')], keywords=[]), Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load())), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])], orelse=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())))]), Return(value=Name(id='bounds', ctx=Load()))], decorator_list=[], returns=None)
Str(s='The Variational Quantum Eigensolver algorithm.\n\nSee https://arxiv.org/abs/1304.3061\n')
alias(name='annotations', asname=None)
alias(name='logging', asname=None)
alias(name='time', asname=None)
alias(name='Callable', asname=None)
alias(name='Dict', asname=None)
alias(name='List', asname=None)
alias(name='Optional', asname=None)
alias(name='Tuple', asname=None)
alias(name='Union', asname=None)
alias(name='numpy', asname='np')
alias(name='Parameter', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='RealAmplitudes', asname=None)
alias(name='CircuitSampler', asname=None)
alias(name='CircuitStateFn', asname=None)
alias(name='ExpectationBase', asname=None)
alias(name='ExpectationFactory', asname=None)
alias(name='ListOp', asname=None)
alias(name='OperatorBase', asname=None)
alias(name='PauliSumOp', asname=None)
alias(name='StateFn', asname=None)
alias(name='GradientBase', asname=None)
alias(name='Backend', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='algorithm_globals', asname=None)
alias(name='is_aer_provider', asname=None)
alias(name='validate_min', asname=None)
alias(name='eval_observables', asname=None)
alias(name='AlgorithmError', asname=None)
alias(name='ListOrDict', asname=None)
alias(name='SLSQP', asname=None)
alias(name='Minimizer', asname=None)
alias(name='Optimizer', asname=None)
alias(name='VariationalAlgorithm', asname=None)
alias(name='VariationalResult', asname=None)
alias(name='MinimumEigensolver', asname=None)
alias(name='MinimumEigensolverResult', asname=None)
Name(id='logger', ctx=Store())
Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])
Name(id='VariationalAlgorithm', ctx=Load())
Name(id='MinimumEigensolver', ctx=Load())
Expr(value=Str(s='The Variational Quantum Eigensolver algorithm.\n\n    `VQE <https://arxiv.org/abs/1304.3061>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the minimum eigenvalue of the Hamiltonian :math:`H` of a given system.\n\n    An instance of VQE requires defining two algorithmic sub-components:\n    a trial state (a.k.a. ansatz) which is a :class:`QuantumCircuit`, and one of the classical\n    :mod:`~qiskit.algorithms.optimizers`. The ansatz is varied, via its set of parameters, by the\n    optimizer, such that it works towards a state, as determined by the parameters applied to the\n    ansatz, that will result in the minimum expectation value being measured of the input operator\n    (Hamiltonian).\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.  As an example, when building the dissociation profile of a molecule,\n    it is likely that using the previous computed optimal solution as the starting\n    initial point for the next interatomic distance is going to reduce the number of iterations\n    necessary for the variational algorithm to converge.  It provides an\n    `initial point tutorial <https://github.com/Qiskit/qiskit-tutorials-community/blob/master\n    /chemistry/h2_vqe_initial_point.ipynb>`__ detailing this use case.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQE will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQE\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    The optimizer can either be one of Qiskit\'s optimizers, such as\n    :class:`~qiskit.algorithms.optimizers.SPSA` or a callable with the following signature:\n\n    .. note::\n\n        The callable _must_ have the argument names ``fun, x0, jac, bounds`` as indicated\n        in the following code block.\n\n    .. code-block::python\n\n        from qiskit.algorithms.optimizers import OptimizerResult\n\n        def my_minimizer(fun, x0, jac=None, bounds=None) -> OptimizerResult:\n            # Note that the callable *must* have these argument names!\n            # Args:\n            #     fun (callable): the function to minimize\n            #     x0 (np.ndarray): the initial point for the optimization\n            #     jac (callable, optional): the gradient of the objective function\n            #     bounds (list, optional): a list of tuples specifying the parameter bounds\n\n            result = OptimizerResult()\n            result.x = # optimal parameters\n            result.fun = # optimal function value\n            return result\n\n    The above signature also allows to directly pass any SciPy minimizer, for instance as\n\n    .. code-block::python\n\n        from functools import partial\n        from scipy.optimize import minimize\n\n        optimizer = partial(minimize, method="L-BFGS-B")\n\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as Ansatz for the wave function.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQE performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n            If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum_instance')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None)
FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load()))
FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQE as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None)
FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Preparing the setting of VQE into a string.\n\n        Returns:\n            str: the formatted setting of VQE\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='Optimizer is custom callable\n'))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None)
FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='compute_minimum_eigenvalue', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQEResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Name(id='eval_time', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalue', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()), op=Add(), right=Num(n=0j))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstate', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=Name(id='result', ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='MinimumEigensolverResult', ctx=Load()))
FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This is the objective function to be passed to the optimizer that is used for evaluation.\n\n        Args:\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n\n\n        Returns:\n            Energy of the hamiltonian of each parameter, and, optionally, the expectation\n            converter.\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='end_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Name(id='VariationalResult', ctx=Load())
Name(id='MinimumEigensolverResult', ctx=Load())
Expr(value=Str(s='VQE Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstate', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
arguments(args=[arg(arg='point', annotation=None), arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='expected_size', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='preferred_init_points')], keywords=[])]), body=[Assign(targets=[Name(id='point', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='preferred_init_points', ctx=Load()))], orelse=[])
If(test=Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds'), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='bounds', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='lower_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='upper_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store()), iter=Name(id='bounds', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='point', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Name(id='lower_bounds', ctx=Load()), Name(id='upper_bounds', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='expected_size', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])])
Return(value=Name(id='point', ctx=Load()))
arguments(args=[arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds')], keywords=[]), Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load())), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])], orelse=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())))])
Return(value=Name(id='bounds', ctx=Load()))
Store()
Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load())
Name(id='__name__', ctx=Load())
Load()
Load()
Str(s='The Variational Quantum Eigensolver algorithm.\n\n    `VQE <https://arxiv.org/abs/1304.3061>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the minimum eigenvalue of the Hamiltonian :math:`H` of a given system.\n\n    An instance of VQE requires defining two algorithmic sub-components:\n    a trial state (a.k.a. ansatz) which is a :class:`QuantumCircuit`, and one of the classical\n    :mod:`~qiskit.algorithms.optimizers`. The ansatz is varied, via its set of parameters, by the\n    optimizer, such that it works towards a state, as determined by the parameters applied to the\n    ansatz, that will result in the minimum expectation value being measured of the input operator\n    (Hamiltonian).\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.  As an example, when building the dissociation profile of a molecule,\n    it is likely that using the previous computed optimal solution as the starting\n    initial point for the next interatomic distance is going to reduce the number of iterations\n    necessary for the variational algorithm to converge.  It provides an\n    `initial point tutorial <https://github.com/Qiskit/qiskit-tutorials-community/blob/master\n    /chemistry/h2_vqe_initial_point.ipynb>`__ detailing this use case.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQE will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQE\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    The optimizer can either be one of Qiskit\'s optimizers, such as\n    :class:`~qiskit.algorithms.optimizers.SPSA` or a callable with the following signature:\n\n    .. note::\n\n        The callable _must_ have the argument names ``fun, x0, jac, bounds`` as indicated\n        in the following code block.\n\n    .. code-block::python\n\n        from qiskit.algorithms.optimizers import OptimizerResult\n\n        def my_minimizer(fun, x0, jac=None, bounds=None) -> OptimizerResult:\n            # Note that the callable *must* have these argument names!\n            # Args:\n            #     fun (callable): the function to minimize\n            #     x0 (np.ndarray): the initial point for the optimization\n            #     jac (callable, optional): the gradient of the objective function\n            #     bounds (list, optional): a list of tuples specifying the parameter bounds\n\n            result = OptimizerResult()\n            result.x = # optimal parameters\n            result.fun = # optimal function value\n            return result\n\n    The above signature also allows to directly pass any SciPy minimizer, for instance as\n\n    .. code-block::python\n\n        from functools import partial\n        from scipy.optimize import minimize\n\n        optimizer = partial(minimize, method="L-BFGS-B")\n\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as Ansatz for the wave function.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQE performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        '))
Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[]))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None))
If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load()))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the ansatz.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n            If None is passed, RealAmplitudes is used by default.\n\n        '))
If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the gradient.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the gradient.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))
Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns quantum instance.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets quantum_instance'))
If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns initial point'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets initial point'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))
Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns max_evals_grouped'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets max_evals_grouped'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load()))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))
Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns include_custom'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        '))
If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])
Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns callback'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets callback'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))
Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))
Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.'))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns optimizer'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='Optimizer', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        '))
If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))
Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Prepare the setting of VQE as a string.'))
Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))
Assign(targets=[Name(id='params', ctx=Store())], value=Str(s=''))
For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)]))
Return(value=Name(id='ret', ctx=Load()))
Name(id='property', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Preparing the setting of VQE into a string.\n\n        Returns:\n            str: the formatted setting of VQE\n        '))
Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n'))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='Optimizer is custom callable\n'))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
Return(value=Name(id='ret', ctx=Load()))
arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)])
Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        "))
If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))])
Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[]))
Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]))
If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='expect_op', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        '))
Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load()))
FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None)
Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[]))
Return(value=Name(id='circuits', ctx=Load()))
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Return(value=NameConstant(value=True))
Name(id='classmethod', ctx=Load())
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0))
Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))]))
Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]))
If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))])
Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load())))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQEResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Name(id='eval_time', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalue', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()), op=Add(), right=Num(n=0j)))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstate', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=Name(id='result', ctx=Load()))
If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[])
Return(value=Name(id='result', ctx=Load()))
Name(id='MinimumEigensolverResult', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)])
Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This is the objective function to be passed to the optimizer that is used for evaluation.\n\n        Args:\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n\n\n        Returns:\n            Energy of the hamiltonian of each parameter, and, optionally, the expectation\n            converter.\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n\n        '))
Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()))
If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()))
Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))]))
FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='end_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None)
If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='energy_evaluation', ctx=Load()))
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.'))
Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[]))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))])
Return(value=Name(id='state', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Str(s='VQE Result.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns number of cost optimizer evaluations'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets number of cost function evaluations'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='return eigen state'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='set eigen state'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='eigenstate', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arg(arg='point', annotation=None)
arg(arg='ansatz', annotation=None)
Name(id='expected_size', ctx=Store())
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
BoolOp(op=And(), values=[Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='preferred_init_points')], keywords=[])])
Assign(targets=[Name(id='point', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='preferred_init_points', ctx=Load()))
Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds'), NameConstant(value=None)], keywords=[]))
If(test=Compare(left=Name(id='bounds', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load())))], orelse=[])
Assign(targets=[Name(id='lower_bounds', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='upper_bounds', ctx=Store())], value=List(elts=[], ctx=Load()))
For(target=Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store()), iter=Name(id='bounds', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))], orelse=[])
Assign(targets=[Name(id='point', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Name(id='lower_bounds', ctx=Load()), Name(id='upper_bounds', ctx=Load())], keywords=[]))
If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='expected_size', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])
Name(id='point', ctx=Load())
arg(arg='ansatz', annotation=None)
BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds')], keywords=[]), Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Assign(targets=[Name(id='bounds', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()))
If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())))
Name(id='bounds', ctx=Load())
Name(id='logging', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))
arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))
arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=False)
Num(n=1)
NameConstant(value=None)
NameConstant(value=None)
Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as Ansatz for the wave function.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQE performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')
Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())
Name(id='max_evals_grouped', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())
Name(id='expectation', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())
Name(id='include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())
Name(id='ansatz', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())
Name(id='optimizer', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())
Name(id='initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())
Name(id='gradient', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
NameConstant(value=None)
Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Num(n=0)
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())
Name(id='callback', ctx=Load())
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='Returns the ansatz.')
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n            If None is passed, RealAmplitudes is used by default.\n\n        ')
Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
Name(id='ansatz', ctx=Load())
Name(id='ansatz', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns the gradient.')
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Sets the gradient.')
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())
Name(id='gradient', ctx=Load())
Name(id='gradient', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns quantum instance.')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Sets quantum_instance')
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())
Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))])
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns initial point')
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Str(s='Sets initial point')
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())
Name(id='initial_point', ctx=Load())
Name(id='initial_point', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns max_evals_grouped')
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))
Str(s='Sets max_evals_grouped')
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())
Name(id='max_evals_grouped', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[])
Name(id='max_evals_grouped', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns include_custom')
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))
Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')
Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))
Name(id='include_custom', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns callback')
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Sets callback')
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())
Name(id='callback', ctx=Load())
Name(id='callback', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
Name(id='exp', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
Str(s='Check that the number of qubits of operator and ansatz match.')
BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])
arg(arg='self', annotation=None)
Str(s='Returns optimizer')
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))
Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')
Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())
Name(id='optimizer', ctx=Load())
Name(id='optimizer', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Prepare the setting of VQE as a string.')
Name(id='ret', ctx=Store())
JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])
Name(id='params', ctx=Store())
Str(s='')
Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])
Name(id='ret', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='\n        Preparing the setting of VQE into a string.\n\n        Returns:\n            str: the formatted setting of VQE\n        ')
Name(id='ret', ctx=Store())
Str(s='\n')
Name(id='ret', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='Optimizer is custom callable\n'))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Name(id='ret', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=False)
Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")
Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))
Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))
Name(id='wave_function', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])
Name(id='observable_meas', ctx=Store())
Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])
Name(id='ansatz_circuit_op', ctx=Store())
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])
Name(id='expect_op', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])
Name(id='return_expectation', ctx=Load())
Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))
Name(id='expect_op', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')
Name(id='expect_op', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])
Name(id='circuits', ctx=Store())
List(elts=[], ctx=Load())
arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])
Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])
Name(id='circuits', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
arg(arg='cls', annotation=None)
NameConstant(value=True)
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())
NameConstant(value=True)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Name(id='initial_point', ctx=Store())
Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Name(id='bounds', ctx=Store())
Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Name(id='aux_operators', ctx=Load())
Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))])
For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[])
Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))
Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[])
Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))
Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])
Name(id='start_time', ctx=Store())
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[])
Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))
Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))
Name(id='eval_time', ctx=Store())
BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))
Name(id='result', ctx=Store())
Call(func=Name(id='VQEResult', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())
Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())
Name(id='eval_time', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalue', ctx=Store())
BinOp(left=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()), op=Add(), right=Num(n=0j))
Attribute(value=Name(id='result', ctx=Load()), attr='eigenstate', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())
Name(id='result', ctx=Load())
Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))
Name(id='result', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=False)
Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This is the objective function to be passed to the optimizer that is used for evaluation.\n\n        Args:\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n\n\n        Returns:\n            Energy of the hamiltonian of each parameter, and, optionally, the expectation\n            converter.\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n\n        ')
Name(id='num_parameters', ctx=Store())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)
Name(id='ansatz_params', ctx=Store())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])
arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[]))
Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))]))
Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))])
Assign(targets=[Name(id='end_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))
Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))
Name(id='return_expectation', ctx=Load())
Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))
Name(id='energy_evaluation', ctx=Load())
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='optimal_parameters', annotation=None)
Str(s='Get the simulation outcome of the ansatz, provided with parameters.')
Name(id='optimal_circuit', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])
Name(id='state_fn', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))
Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))
Name(id='state', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='Returns number of cost optimizer evaluations')
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='int', ctx=Load()))
Str(s='Sets number of cost function evaluations')
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())
Name(id='value', ctx=Load())
Name(id='cost_function_evals', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='return eigen state')
Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Str(s='set eigen state')
Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Store())
Name(id='value', ctx=Load())
Name(id='eigenstate', ctx=Load())
Load()
Store()
Name(id='ansatz', ctx=Load())
Load()
And()
Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='preferred_init_points')], keywords=[])
Name(id='point', ctx=Store())
Attribute(value=Name(id='ansatz', ctx=Load()), attr='preferred_init_points', ctx=Load())
Name(id='point', ctx=Load())
Is()
NameConstant(value=None)
Name(id='bounds', ctx=Store())
Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds'), NameConstant(value=None)], keywords=[])
Compare(left=Name(id='bounds', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load())))
Name(id='lower_bounds', ctx=Store())
List(elts=[], ctx=Load())
Name(id='upper_bounds', ctx=Store())
List(elts=[], ctx=Load())
Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store())
Name(id='bounds', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))
Name(id='point', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Name(id='lower_bounds', ctx=Load()), Name(id='upper_bounds', ctx=Load())], keywords=[])
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='expected_size', ctx=Load())])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)
Load()
And()
Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds')], keywords=[])
Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Name(id='bounds', ctx=Store())
Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load())
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)
Name(id='bounds', ctx=Store())
BinOp(left=List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()))
Load()
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Name(id='int', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='validate_min', ctx=Load())
Str(s='max_evals_grouped')
Name(id='max_evals_grouped', ctx=Load())
Num(n=1)
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='quantum_instance', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Name(id='ansatz', ctx=Load())
Is()
NameConstant(value=None)
Name(id='ansatz', ctx=Store())
Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='CircuitSampler', ctx=Load())
Name(id='quantum_instance', ctx=Load())
keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load())
Name(id='max_evals_grouped', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='bool', ctx=Load())
Name(id='include_custom', ctx=Load())
NotEq()
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())
Name(id='include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())
NameConstant(value=None)
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='ExpectationBase', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
And()
Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())])
Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())
Name(id='optimizer', ctx=Load())
Is()
NameConstant(value=None)
Name(id='optimizer', ctx=Store())
Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[])
Name(id='isinstance', ctx=Load())
Name(id='optimizer', ctx=Load())
Name(id='Optimizer', ctx=Load())
Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Store()
Str(s='Algorithm: ')
FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None)
Str(s='\n')
Store()
Name(id='key', ctx=Store())
Name(id='value', ctx=Store())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load())
Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')])
If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])
Store()
FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)
Load()
Store()
Store()
Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())
Store()
FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='ret', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[])
Name(id='ret', ctx=Store())
Add()
Str(s='ansatz has not been set')
Store()
Name(id='callable', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Name(id='ret', ctx=Store())
Add()
Str(s='Optimizer is custom callable\n')
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])
Store()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='OperatorBase', ctx=Load())
Name(id='bool', ctx=Load())
Name(id='operator', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load())
Name(id='operator', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load())
Is()
NameConstant(value=None)
Name(id='expectation', ctx=Store())
Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))])
Name(id='expectation', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load())
Name(id='parameter', ctx=Load())
Store()
Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load())
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])
Store()
Name(id='CircuitStateFn', ctx=Load())
Name(id='wave_function', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load())
Load()
Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='OperatorBase', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load())
Store()
Load()
arg(arg='op', annotation=None)
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])
Name(id='extract_circuits', ctx=Load())
Name(id='expect_op', ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='OperatorBase', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load())
Name(id='operator', ctx=Load())
Name(id='aux_operators', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load())
Name(id='operator', ctx=Load())
Store()
Name(id='_validate_initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Store()
Name(id='_validate_bounds', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='zero_op', ctx=Store())
Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))
Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store())
Name(id='key_op_iterator', ctx=Load())
If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])
Name(id='aux_operators', ctx=Store())
Name(id='converted', ctx=Load())
Name(id='aux_operators', ctx=Store())
NameConstant(value=None)
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Name(id='GradientBase', ctx=Load())
Name(id='gradient', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))])
Name(id='gradient', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='energy_evaluation', ctx=Store())
Name(id='expectation', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='return_expectation', value=NameConstant(value=True))
Store()
Name(id='time', ctx=Load())
Name(id='callable', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Name(id='opt_result', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))])
Name(id='opt_result', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))])
Store()
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Sub()
Name(id='start_time', ctx=Load())
Store()
Name(id='VQEResult', ctx=Load())
Name(id='result', ctx=Load())
Store()
Name(id='opt_result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Name(id='dict', ctx=Load())
Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])
Name(id='result', ctx=Load())
Store()
Name(id='opt_result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Name(id='opt_result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())
Add()
Num(n=0j)
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals')
Name(id='eval_time', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='aux_operators', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='bound_ansatz', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])
Name(id='aux_values', ctx=Store())
Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])
Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())
Name(id='aux_values', ctx=Load())
Load()
Name(id='OperatorBase', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='num_parameters', ctx=Load())
Eq()
Num(n=0)
Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='expect_op', ctx=Store())
Name(id='expectation', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load())
Name(id='ansatz_params', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='return_expectation', value=NameConstant(value=True))
arg(arg='parameters', annotation=None)
Name(id='parameter_sets', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])
Name(id='param_bindings', ctx=Store())
Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])
Name(id='start_time', ctx=Store())
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Name(id='sampled_expect_op', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])
Name(id='means', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[]))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])
AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))
Name(id='end_time', ctx=Store())
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])
IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Load()
Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Name(id='optimal_parameters', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Name(id='state', ctx=Store())
Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load())
Name(id='state', ctx=Store())
Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load())
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Name(id='point', ctx=Load())
Is()
NameConstant(value=None)
Name(id='hasattr', ctx=Load())
Name(id='ansatz', ctx=Load())
Str(s='preferred_init_points')
Store()
Name(id='ansatz', ctx=Load())
Load()
Load()
Store()
Name(id='getattr', ctx=Load())
Name(id='ansatz', ctx=Load())
Str(s='parameter_bounds')
NameConstant(value=None)
Name(id='bounds', ctx=Load())
Is()
NameConstant(value=None)
Name(id='bounds', ctx=Store())
BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load()))
Store()
Load()
Store()
Load()
Name(id='lower', ctx=Store())
Name(id='upper', ctx=Store())
Store()
Load()
Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])
Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])
Store()
Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load())
Name(id='lower_bounds', ctx=Load())
Name(id='upper_bounds', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[])
NotEq()
Name(id='expected_size', ctx=Load())
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[])
Name(id='hasattr', ctx=Load())
Name(id='ansatz', ctx=Load())
Str(s='parameter_bounds')
Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load())
IsNot()
NameConstant(value=None)
Store()
Name(id='ansatz', ctx=Load())
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[])
NotEq()
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[])
Store()
List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load())
Mult()
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load())
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Load()
Store()
Name(id='RealAmplitudes', ctx=Load())
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[])
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
Load()
Load()
Name(id='operator', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load())
NotEq()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))
ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='Optimizer', ctx=Load()))
Load()
Load()
Store()
Name(id='SLSQP', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())
Store()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load())
Load()
Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Eq()
Str(s='_')
BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))
AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))
Name(id='params', ctx=Load())
Str(s='==================== Setting of {} ============================\n')
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load())
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Str(s='{}'), attr='format', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])
Store()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Store()
FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='The operator was never provided.')
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load())
keyword(arg='operator', value=Name(id='operator', ctx=Load()))
keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()))
keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))
Store()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Name(id='expectation', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='is_measurement', value=NameConstant(value=True))
Load()
Load()
Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[])
Load()
Name(id='expect_op', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
Name(id='OperatorBase', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()))
Load()
Load()
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[])
Load()
Name(id='isinstance', ctx=Load())
Name(id='op', ctx=Load())
Name(id='CircuitStateFn', ctx=Load())
Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[])
For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()))
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load())
List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='list', ctx=Load())
Name(id='key_op_iterator', ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Name(id='converted', ctx=Store())
BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Name(id='key_op_iterator', ctx=Store())
Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
Name(id='converted', ctx=Store())
Dict(keys=[], values=[])
Name(id='key', ctx=Store())
Name(id='op', ctx=Store())
Store()
Load()
Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))
Store()
Load()
Store()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load())
BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[]))
keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Store()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Load()
NameConstant(value=True)
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load()))
keyword(arg='x0', value=Name(id='initial_point', ctx=Load()))
keyword(arg='jac', value=Name(id='gradient', ctx=Load()))
keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load())
keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load()))
keyword(arg='x0', value=Name(id='initial_point', ctx=Load()))
keyword(arg='jac', value=Name(id='gradient', ctx=Load()))
keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))
Name(id='time', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='zip', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='opt_result', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Store()
Name(id='eval_observables', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Name(id='bound_ansatz', ctx=Load())
Name(id='aux_operators', ctx=Load())
keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))
Name(id='result', ctx=Load())
Store()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='RuntimeError', ctx=Load())
Str(s='The ansatz must be parameterized, but has 0 free parameters.')
Name(id='self', ctx=Load())
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load())
Name(id='parameters', ctx=Load())
Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())
Store()
Name(id='dict', ctx=Load())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])
Store()
Name(id='time', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load())
Name(id='expect_op', ctx=Load())
keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='variance', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])
Name(id='estimator_error', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[])
AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Add()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[])
Store()
Name(id='time', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s')
Name(id='means', ctx=Load())
BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)])
Name(id='means', ctx=Load())
Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='energy_evaluation', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[])
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load())
Load()
Store()
Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[])
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Store()
List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load())
Mult()
Name(id='expected_size', ctx=Load())
Store()
Store()
Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load())
IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load())
IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load())
Load()
Load()
Load()
Name(id='len', ctx=Load())
Name(id='point', ctx=Load())
Load()
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])
Load()
Load()
Name(id='ansatz', ctx=Load())
Load()
Load()
Name(id='len', ctx=Load())
Name(id='bounds', ctx=Load())
Name(id='ansatz', ctx=Load())
Load()
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])
Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())
Load()
Name(id='ansatz', ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='is_aer_provider', ctx=Load())
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='operator', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())
Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='AttributeError', ctx=Load())
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))
Load()
Name(id='Optimizer', ctx=Load())
Load()
Name(id='optimizer', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='key', ctx=Load())
Index(value=Num(n=0))
Load()
And()
Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())])
Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Name(id='params', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[])
Name(id='params', ctx=Store())
Add()
JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Str(s='{}')
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load())
keyword(arg='output', value=Str(s='text'))
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load())
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Name(id='ExpectationFactory', ctx=Load())
Load()
Name(id='operator', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load())
Name(id='ansatz_circuit_op', ctx=Load())
Load()
Load()
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load())
Name(id='parameter', ctx=Load())
Name(id='operator', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load())
Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='op', ctx=Load())
Name(id='ListOp', ctx=Load())
Name(id='op_i', ctx=Store())
Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load())
Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))
Load()
Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='PauliSumOp', ctx=Load())
Load()
Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='enumerate', ctx=Load())
Name(id='aux_operators', ctx=Load())
Store()
List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load())
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load())
Store()
Store()
Store()
Name(id='op', ctx=Load())
IsNot()
NameConstant(value=None)
Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())
IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load()))
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Load()
UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
MatMult()
Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='energy_evaluation', ctx=Load())
Name(id='initial_point', ctx=Load())
Name(id='gradient', ctx=Load())
Name(id='bounds', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Load()
Name(id='energy_evaluation', ctx=Load())
Name(id='initial_point', ctx=Load())
Name(id='gradient', ctx=Load())
Name(id='bounds', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='opt_result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='expectation', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='num_parameters', ctx=Load())
Load()
Load()
Name(id='zip', ctx=Load())
Name(id='ansatz_params', ctx=Load())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load())
Load()
Load()
Name(id='param_bindings', ctx=Load())
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load())
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))
Name(id='i', ctx=Store())
Name(id='param_set', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='parameter_sets', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Add()
Num(n=1)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Name(id='len', ctx=Load())
Name(id='means', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Load()
BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load()))
Mult()
Num(n=1000)
Name(id='self', ctx=Load())
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[])
Gt()
Num(n=1)
Load()
Name(id='means', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load())
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])
Load()
Name(id='state_fn', ctx=Load())
Load()
Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='Dict', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='super', ctx=Load())
Load()
Load()
Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())
Load()
Load()
Name(id='lower_bounds', ctx=Load())
Load()
Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Name(id='lower', ctx=Load())
BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Name(id='upper_bounds', ctx=Load())
Load()
Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Name(id='upper', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Name(id='algorithm_globals', ctx=Load())
Load()
Load()
Load()
Load()
Str(s='The dimension of the initial point (')
FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Str(s=') does not match the number of parameters in the circuit (')
FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None)
Str(s=').')
Load()
Load()
Load()
Load()
Load()
Str(s='The number of bounds (')
FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Str(s=') does not match the number of parameters in the circuit (')
FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None)
Str(s=').')
NameConstant(value=None)
NameConstant(value=None)
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Name(id='quantum_instance', ctx=Load())
Load()
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Store()
Name(id='operator', ctx=Load())
Load()
Load()
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[])
Name(id='ex', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Num(n=0)
Str(s='initial_point')
In()
Name(id='key', ctx=Load())
Name(id='value', ctx=Load())
Is()
NameConstant(value=None)
Store()
Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load())
Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load())
Str(s='Random seed')
Store()
Str(s='-- ')
FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None)
Str(s=': ')
FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None)
Str(s='\n')
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Str(s='text')
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='observable_meas', ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='circuits', ctx=Load())
Load()
Name(id='op', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='op', ctx=Load())
Load()
Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[])
Name(id='ListOrDict', ctx=Load())
Index(value=Name(id='OperatorBase', ctx=Load()))
Load()
Load()
Load()
BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()))
Num(n=0)
Load()
Load()
Load()
Name(id='zero_op', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='aux_operators', ctx=Load())
Load()
Load()
Name(id='converted', ctx=Load())
Index(value=Name(id='key', ctx=Load()))
Store()
Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Name(id='zero_op', ctx=Load())
Name(id='op', ctx=Load())
Name(id='self', ctx=Load())
Load()
Invert()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Name(id='StateFn', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Name(id='list', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
USub()
Num(n=1)
Load()
Load()
Load()
Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='sampled_expect_op', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load())
Name(id='sampled_expect_op', ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='variance', ctx=Load())
Div()
Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load())
Store()
Store()
Load()
Load()
Name(id='self', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())
Name(id='param_set', ctx=Load())
Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Name(id='end_time', ctx=Load())
Sub()
Name(id='start_time', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='means', ctx=Load())
Load()
Num(n=0)
Name(id='np', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='optimal_circuit', ctx=Load())
Load()
Name(id='state_fn', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Load()
Load()
Name(id='lower', ctx=Load())
IsNot()
NameConstant(value=None)
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Name(id='upper', ctx=Load())
IsNot()
NameConstant(value=None)
Load()
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[])
Name(id='expected_size', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[])
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
Load()
Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')
Load()
Load()
Load()
Load()
Str(s='-- {}: {}\n')
Load()
Name(id='key', ctx=Load())
Slice(lower=Num(n=1), upper=None, step=None)
Load()
Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load())
Name(id='value', ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='Parameter', ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Name(id='ExpectationBase', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='Parameter', ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='extract_circuits', ctx=Load())
Name(id='op_i', ctx=Load())
Load()
Name(id='OperatorBase', ctx=Load())
Str(s='I')
Mult()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='key', ctx=Load())
Name(id='op', ctx=Load())
Eq()
Num(n=0)
Load()
Load()
Load()
Name(id='StateFn', ctx=Load())
Name(id='operator', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Name(id='expectation', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='means', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='estimator_error', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='str', ctx=Load())
Name(id='int', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
USub()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='point', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='bounds', ctx=Load())
Name(id='ansatz', ctx=Load())
Load()
Name(id='Optimizer', ctx=Load())
Name(id='Minimizer', ctx=Load())
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Load()
Load()
Load()
Num(n=1)
Name(id='key', ctx=Load())
Slice(lower=Num(n=1), upper=None, step=None)
Load()
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='Parameter', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='Parameter', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Load()
USub()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Num(n=1)
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='parameter_sets', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Module(body=[Expr(value=Str(s='The Variational Quantum Eigensolver algorithm.\n\nSee https://arxiv.org/abs/1304.3061\n')), ImportFrom(module='__future__', names=[alias(name='annotations', asname=None)], level=0), Import(names=[alias(name='logging', asname=None)]), ImportFrom(module='time', names=[alias(name='time', asname=None)], level=0), ImportFrom(module='typing', names=[alias(name='Callable', asname=None), alias(name='Dict', asname=None), alias(name='List', asname=None), alias(name='Optional', asname=None), alias(name='Tuple', asname=None), alias(name='Union', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit.circuit', names=[alias(name='Parameter', asname=None), alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library', names=[alias(name='RealAmplitudes', asname=None)], level=0), ImportFrom(module='qiskit.opflow', names=[alias(name='CircuitSampler', asname=None), alias(name='CircuitStateFn', asname=None), alias(name='ExpectationBase', asname=None), alias(name='ExpectationFactory', asname=None), alias(name='ListOp', asname=None), alias(name='OperatorBase', asname=None), alias(name='PauliSumOp', asname=None), alias(name='StateFn', asname=None)], level=0), ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None), alias(name='algorithm_globals', asname=None)], level=0), ImportFrom(module='qiskit.utils.backend_utils', names=[alias(name='is_aer_provider', asname=None)], level=0), ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0), ImportFrom(module='aux_ops_evaluator', names=[alias(name='eval_observables', asname=None)], level=2), ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2), ImportFrom(module='list_or_dict', names=[alias(name='ListOrDict', asname=None)], level=2), ImportFrom(module='optimizers', names=[alias(name='SLSQP', asname=None), alias(name='Minimizer', asname=None), alias(name='Optimizer', asname=None)], level=2), ImportFrom(module='variational_algorithm', names=[alias(name='VariationalAlgorithm', asname=None), alias(name='VariationalResult', asname=None)], level=2), ImportFrom(module='minimum_eigen_solver', names=[alias(name='MinimumEigensolver', asname=None), alias(name='MinimumEigensolverResult', asname=None)], level=1), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='VQE', bases=[Name(id='VariationalAlgorithm', ctx=Load()), Name(id='MinimumEigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Variational Quantum Eigensolver algorithm.\n\n    `VQE <https://arxiv.org/abs/1304.3061>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the minimum eigenvalue of the Hamiltonian :math:`H` of a given system.\n\n    An instance of VQE requires defining two algorithmic sub-components:\n    a trial state (a.k.a. ansatz) which is a :class:`QuantumCircuit`, and one of the classical\n    :mod:`~qiskit.algorithms.optimizers`. The ansatz is varied, via its set of parameters, by the\n    optimizer, such that it works towards a state, as determined by the parameters applied to the\n    ansatz, that will result in the minimum expectation value being measured of the input operator\n    (Hamiltonian).\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.  As an example, when building the dissociation profile of a molecule,\n    it is likely that using the previous computed optimal solution as the starting\n    initial point for the next interatomic distance is going to reduce the number of iterations\n    necessary for the variational algorithm to converge.  It provides an\n    `initial point tutorial <https://github.com/Qiskit/qiskit-tutorials-community/blob/master\n    /chemistry/h2_vqe_initial_point.ipynb>`__ detailing this use case.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQE will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQE\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    The optimizer can either be one of Qiskit\'s optimizers, such as\n    :class:`~qiskit.algorithms.optimizers.SPSA` or a callable with the following signature:\n\n    .. note::\n\n        The callable _must_ have the argument names ``fun, x0, jac, bounds`` as indicated\n        in the following code block.\n\n    .. code-block::python\n\n        from qiskit.algorithms.optimizers import OptimizerResult\n\n        def my_minimizer(fun, x0, jac=None, bounds=None) -> OptimizerResult:\n            # Note that the callable *must* have these argument names!\n            # Args:\n            #     fun (callable): the function to minimize\n            #     x0 (np.ndarray): the initial point for the optimization\n            #     jac (callable, optional): the gradient of the objective function\n            #     bounds (list, optional): a list of tuples specifying the parameter bounds\n\n            result = OptimizerResult()\n            result.x = # optimal parameters\n            result.fun = # optimal function value\n            return result\n\n    The above signature also allows to directly pass any SciPy minimizer, for instance as\n\n    .. code-block::python\n\n        from functools import partial\n        from scipy.optimize import minimize\n\n        optimizer = partial(minimize, method="L-BFGS-B")\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as Ansatz for the wave function.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQE performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n            If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum_instance')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load())), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQE as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None), FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Preparing the setting of VQE into a string.\n\n        Returns:\n            str: the formatted setting of VQE\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='Optimizer is custom callable\n'))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='compute_minimum_eigenvalue', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQEResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Name(id='eval_time', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalue', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()), op=Add(), right=Num(n=0j))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstate', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=Name(id='result', ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='MinimumEigensolverResult', ctx=Load())), FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This is the objective function to be passed to the optimizer that is used for evaluation.\n\n        Args:\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n\n\n        Returns:\n            Energy of the hamiltonian of each parameter, and, optionally, the expectation\n            converter.\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='end_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))], decorator_list=[]), ClassDef(name='VQEResult', bases=[Name(id='VariationalResult', ctx=Load()), Name(id='MinimumEigensolverResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='VQE Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstate', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[]), FunctionDef(name='_validate_initial_point', args=arguments(args=[arg(arg='point', annotation=None), arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='expected_size', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='preferred_init_points')], keywords=[])]), body=[Assign(targets=[Name(id='point', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='preferred_init_points', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds'), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='bounds', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='lower_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='upper_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store()), iter=Name(id='bounds', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='point', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Name(id='lower_bounds', ctx=Load()), Name(id='upper_bounds', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='expected_size', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])]), Return(value=Name(id='point', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='_validate_bounds', args=arguments(args=[arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds')], keywords=[]), Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load())), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])], orelse=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())))]), Return(value=Name(id='bounds', ctx=Load()))], decorator_list=[], returns=None)])
Expr(value=Str(s='The Variational Quantum Eigensolver algorithm.\n\nSee https://arxiv.org/abs/1304.3061\n'))
ImportFrom(module='__future__', names=[alias(name='annotations', asname=None)], level=0)
Import(names=[alias(name='logging', asname=None)])
ImportFrom(module='time', names=[alias(name='time', asname=None)], level=0)
ImportFrom(module='typing', names=[alias(name='Callable', asname=None), alias(name='Dict', asname=None), alias(name='List', asname=None), alias(name='Optional', asname=None), alias(name='Tuple', asname=None), alias(name='Union', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit.circuit', names=[alias(name='Parameter', asname=None), alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library', names=[alias(name='RealAmplitudes', asname=None)], level=0)
ImportFrom(module='qiskit.opflow', names=[alias(name='CircuitSampler', asname=None), alias(name='CircuitStateFn', asname=None), alias(name='ExpectationBase', asname=None), alias(name='ExpectationFactory', asname=None), alias(name='ListOp', asname=None), alias(name='OperatorBase', asname=None), alias(name='PauliSumOp', asname=None), alias(name='StateFn', asname=None)], level=0)
ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None), alias(name='algorithm_globals', asname=None)], level=0)
ImportFrom(module='qiskit.utils.backend_utils', names=[alias(name='is_aer_provider', asname=None)], level=0)
ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0)
ImportFrom(module='aux_ops_evaluator', names=[alias(name='eval_observables', asname=None)], level=2)
ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2)
ImportFrom(module='list_or_dict', names=[alias(name='ListOrDict', asname=None)], level=2)
ImportFrom(module='optimizers', names=[alias(name='SLSQP', asname=None), alias(name='Minimizer', asname=None), alias(name='Optimizer', asname=None)], level=2)
ImportFrom(module='variational_algorithm', names=[alias(name='VariationalAlgorithm', asname=None), alias(name='VariationalResult', asname=None)], level=2)
ImportFrom(module='minimum_eigen_solver', names=[alias(name='MinimumEigensolver', asname=None), alias(name='MinimumEigensolverResult', asname=None)], level=1)
Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[]))
ClassDef(name='VQE', bases=[Name(id='VariationalAlgorithm', ctx=Load()), Name(id='MinimumEigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The Variational Quantum Eigensolver algorithm.\n\n    `VQE <https://arxiv.org/abs/1304.3061>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the minimum eigenvalue of the Hamiltonian :math:`H` of a given system.\n\n    An instance of VQE requires defining two algorithmic sub-components:\n    a trial state (a.k.a. ansatz) which is a :class:`QuantumCircuit`, and one of the classical\n    :mod:`~qiskit.algorithms.optimizers`. The ansatz is varied, via its set of parameters, by the\n    optimizer, such that it works towards a state, as determined by the parameters applied to the\n    ansatz, that will result in the minimum expectation value being measured of the input operator\n    (Hamiltonian).\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.  As an example, when building the dissociation profile of a molecule,\n    it is likely that using the previous computed optimal solution as the starting\n    initial point for the next interatomic distance is going to reduce the number of iterations\n    necessary for the variational algorithm to converge.  It provides an\n    `initial point tutorial <https://github.com/Qiskit/qiskit-tutorials-community/blob/master\n    /chemistry/h2_vqe_initial_point.ipynb>`__ detailing this use case.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQE will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQE\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    The optimizer can either be one of Qiskit\'s optimizers, such as\n    :class:`~qiskit.algorithms.optimizers.SPSA` or a callable with the following signature:\n\n    .. note::\n\n        The callable _must_ have the argument names ``fun, x0, jac, bounds`` as indicated\n        in the following code block.\n\n    .. code-block::python\n\n        from qiskit.algorithms.optimizers import OptimizerResult\n\n        def my_minimizer(fun, x0, jac=None, bounds=None) -> OptimizerResult:\n            # Note that the callable *must* have these argument names!\n            # Args:\n            #     fun (callable): the function to minimize\n            #     x0 (np.ndarray): the initial point for the optimization\n            #     jac (callable, optional): the gradient of the objective function\n            #     bounds (list, optional): a list of tuples specifying the parameter bounds\n\n            result = OptimizerResult()\n            result.x = # optimal parameters\n            result.fun = # optimal function value\n            return result\n\n    The above signature also allows to directly pass any SciPy minimizer, for instance as\n\n    .. code-block::python\n\n        from functools import partial\n        from scipy.optimize import minimize\n\n        optimizer = partial(minimize, method="L-BFGS-B")\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as Ansatz for the wave function.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQE performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n            If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum_instance')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load())), FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None), FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQE as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None), FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Preparing the setting of VQE into a string.\n\n        Returns:\n            str: the formatted setting of VQE\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='Optimizer is custom callable\n'))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='compute_minimum_eigenvalue', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQEResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Name(id='eval_time', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalue', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()), op=Add(), right=Num(n=0j))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstate', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=Name(id='result', ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='MinimumEigensolverResult', ctx=Load())), FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This is the objective function to be passed to the optimizer that is used for evaluation.\n\n        Args:\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n\n\n        Returns:\n            Energy of the hamiltonian of each parameter, and, optionally, the expectation\n            converter.\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='end_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))], decorator_list=[])
ClassDef(name='VQEResult', bases=[Name(id='VariationalResult', ctx=Load()), Name(id='MinimumEigensolverResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='VQE Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstate', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
FunctionDef(name='_validate_initial_point', args=arguments(args=[arg(arg='point', annotation=None), arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='expected_size', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='preferred_init_points')], keywords=[])]), body=[Assign(targets=[Name(id='point', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='preferred_init_points', ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds'), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='bounds', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='lower_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='upper_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store()), iter=Name(id='bounds', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='point', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Name(id='lower_bounds', ctx=Load()), Name(id='upper_bounds', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='expected_size', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])]), Return(value=Name(id='point', ctx=Load()))], decorator_list=[], returns=None)
FunctionDef(name='_validate_bounds', args=arguments(args=[arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds')], keywords=[]), Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load())), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])], orelse=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())))]), Return(value=Name(id='bounds', ctx=Load()))], decorator_list=[], returns=None)
Str(s='The Variational Quantum Eigensolver algorithm.\n\nSee https://arxiv.org/abs/1304.3061\n')
alias(name='annotations', asname=None)
alias(name='logging', asname=None)
alias(name='time', asname=None)
alias(name='Callable', asname=None)
alias(name='Dict', asname=None)
alias(name='List', asname=None)
alias(name='Optional', asname=None)
alias(name='Tuple', asname=None)
alias(name='Union', asname=None)
alias(name='numpy', asname='np')
alias(name='Parameter', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='RealAmplitudes', asname=None)
alias(name='CircuitSampler', asname=None)
alias(name='CircuitStateFn', asname=None)
alias(name='ExpectationBase', asname=None)
alias(name='ExpectationFactory', asname=None)
alias(name='ListOp', asname=None)
alias(name='OperatorBase', asname=None)
alias(name='PauliSumOp', asname=None)
alias(name='StateFn', asname=None)
alias(name='GradientBase', asname=None)
alias(name='Backend', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='algorithm_globals', asname=None)
alias(name='is_aer_provider', asname=None)
alias(name='validate_min', asname=None)
alias(name='eval_observables', asname=None)
alias(name='AlgorithmError', asname=None)
alias(name='ListOrDict', asname=None)
alias(name='SLSQP', asname=None)
alias(name='Minimizer', asname=None)
alias(name='Optimizer', asname=None)
alias(name='VariationalAlgorithm', asname=None)
alias(name='VariationalResult', asname=None)
alias(name='MinimumEigensolver', asname=None)
alias(name='MinimumEigensolverResult', asname=None)
Name(id='logger', ctx=Store())
Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])
Name(id='VariationalAlgorithm', ctx=Load())
Name(id='MinimumEigensolver', ctx=Load())
Expr(value=Str(s='The Variational Quantum Eigensolver algorithm.\n\n    `VQE <https://arxiv.org/abs/1304.3061>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the minimum eigenvalue of the Hamiltonian :math:`H` of a given system.\n\n    An instance of VQE requires defining two algorithmic sub-components:\n    a trial state (a.k.a. ansatz) which is a :class:`QuantumCircuit`, and one of the classical\n    :mod:`~qiskit.algorithms.optimizers`. The ansatz is varied, via its set of parameters, by the\n    optimizer, such that it works towards a state, as determined by the parameters applied to the\n    ansatz, that will result in the minimum expectation value being measured of the input operator\n    (Hamiltonian).\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.  As an example, when building the dissociation profile of a molecule,\n    it is likely that using the previous computed optimal solution as the starting\n    initial point for the next interatomic distance is going to reduce the number of iterations\n    necessary for the variational algorithm to converge.  It provides an\n    `initial point tutorial <https://github.com/Qiskit/qiskit-tutorials-community/blob/master\n    /chemistry/h2_vqe_initial_point.ipynb>`__ detailing this use case.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQE will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQE\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    The optimizer can either be one of Qiskit\'s optimizers, such as\n    :class:`~qiskit.algorithms.optimizers.SPSA` or a callable with the following signature:\n\n    .. note::\n\n        The callable _must_ have the argument names ``fun, x0, jac, bounds`` as indicated\n        in the following code block.\n\n    .. code-block::python\n\n        from qiskit.algorithms.optimizers import OptimizerResult\n\n        def my_minimizer(fun, x0, jac=None, bounds=None) -> OptimizerResult:\n            # Note that the callable *must* have these argument names!\n            # Args:\n            #     fun (callable): the function to minimize\n            #     x0 (np.ndarray): the initial point for the optimization\n            #     jac (callable, optional): the gradient of the objective function\n            #     bounds (list, optional): a list of tuples specifying the parameter bounds\n\n            result = OptimizerResult()\n            result.x = # optimal parameters\n            result.fun = # optimal function value\n            return result\n\n    The above signature also allows to directly pass any SciPy minimizer, for instance as\n\n    .. code-block::python\n\n        from functools import partial\n        from scipy.optimize import minimize\n\n        optimizer = partial(minimize, method="L-BFGS-B")\n\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as Ansatz for the wave function.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQE performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n            If None is passed, RealAmplitudes is used by default.\n\n        ')), If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the gradient.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum_instance')), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns initial point')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
FunctionDef(name='initial_point', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets initial point')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))], decorator_list=[Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns max_evals_grouped')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='max_evals_grouped', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets max_evals_grouped')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load())), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))], decorator_list=[Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns include_custom')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='include_custom', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')), If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])], decorator_list=[Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns callback')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='callback', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets callback')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))], decorator_list=[Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='_check_operator_ansatz', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.')), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])], decorator_list=[], returns=None)
FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns optimizer')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='Optimizer', ctx=Load()))
FunctionDef(name='optimizer', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')), If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))], decorator_list=[Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())], returns=None)
FunctionDef(name='setting', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Prepare the setting of VQE as a string.')), Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])), Assign(targets=[Name(id='params', ctx=Store())], value=Str(s='')), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=None)
FunctionDef(name='print_settings', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Preparing the setting of VQE into a string.\n\n        Returns:\n            str: the formatted setting of VQE\n        ')), Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n')), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='Optimizer is custom callable\n'))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))]), AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n')), Return(value=Name(id='ret', ctx=Load()))], decorator_list=[], returns=None)
FunctionDef(name='construct_expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")), If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))]), Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])), Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])), Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='expect_op', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')), Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load())), FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None), Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])), Return(value=Name(id='circuits', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
FunctionDef(name='supports_aux_operators', args=arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Return(value=NameConstant(value=True))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='compute_minimum_eigenvalue', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0)), Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))]), Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQEResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Name(id='eval_time', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalue', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()), op=Add(), right=Num(n=0j))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstate', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=Name(id='result', ctx=Load())), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Name(id='MinimumEigensolverResult', ctx=Load()))
FunctionDef(name='get_energy_evaluation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)]), body=[Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This is the objective function to be passed to the optimizer that is used for evaluation.\n\n        Args:\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n\n\n        Returns:\n            Energy of the hamiltonian of each parameter, and, optionally, the expectation\n            converter.\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n\n        ')), Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())), If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])), FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='end_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None), If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[]), Return(value=Name(id='energy_evaluation', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='_get_eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.')), Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))]), Return(value=Name(id='state', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Name(id='VariationalResult', ctx=Load())
Name(id='MinimumEigensolverResult', ctx=Load())
Expr(value=Str(s='VQE Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of cost optimizer evaluations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
FunctionDef(name='cost_function_evals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of cost function evaluations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='return eigen state')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
FunctionDef(name='eigenstate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set eigen state')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='eigenstate', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
arguments(args=[arg(arg='point', annotation=None), arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='expected_size', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='preferred_init_points')], keywords=[])]), body=[Assign(targets=[Name(id='point', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='preferred_init_points', ctx=Load()))], orelse=[])
If(test=Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds'), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='bounds', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load())))], orelse=[]), Assign(targets=[Name(id='lower_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='upper_bounds', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store()), iter=Name(id='bounds', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='point', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Name(id='lower_bounds', ctx=Load()), Name(id='upper_bounds', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='expected_size', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])])
Return(value=Name(id='point', ctx=Load()))
arguments(args=[arg(arg='ansatz', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds')], keywords=[]), Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load())), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])], orelse=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())))])
Return(value=Name(id='bounds', ctx=Load()))
Store()
Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load())
Name(id='__name__', ctx=Load())
Load()
Load()
Str(s='The Variational Quantum Eigensolver algorithm.\n\n    `VQE <https://arxiv.org/abs/1304.3061>`__ is a quantum algorithm that uses a\n    variational technique to find\n    the minimum eigenvalue of the Hamiltonian :math:`H` of a given system.\n\n    An instance of VQE requires defining two algorithmic sub-components:\n    a trial state (a.k.a. ansatz) which is a :class:`QuantumCircuit`, and one of the classical\n    :mod:`~qiskit.algorithms.optimizers`. The ansatz is varied, via its set of parameters, by the\n    optimizer, such that it works towards a state, as determined by the parameters applied to the\n    ansatz, that will result in the minimum expectation value being measured of the input operator\n    (Hamiltonian).\n\n    An optional array of parameter values, via the *initial_point*, may be provided as the\n    starting point for the search of the minimum eigenvalue. This feature is particularly useful\n    such as when there are reasons to believe that the solution point is close to a particular\n    point.  As an example, when building the dissociation profile of a molecule,\n    it is likely that using the previous computed optimal solution as the starting\n    initial point for the next interatomic distance is going to reduce the number of iterations\n    necessary for the variational algorithm to converge.  It provides an\n    `initial point tutorial <https://github.com/Qiskit/qiskit-tutorials-community/blob/master\n    /chemistry/h2_vqe_initial_point.ipynb>`__ detailing this use case.\n\n    The length of the *initial_point* list value must match the number of the parameters\n    expected by the ansatz being used. If the *initial_point* is left at the default\n    of ``None``, then VQE will look to the ansatz for a preferred value, based on its\n    given initial state. If the ansatz returns ``None``,\n    then a random point will be generated within the parameter bounds set, as per above.\n    If the ansatz provides ``None`` as the lower bound, then VQE\n    will default it to :math:`-2\\pi`; similarly, if the ansatz returns ``None``\n    as the upper bound, the default value will be :math:`2\\pi`.\n\n    The optimizer can either be one of Qiskit\'s optimizers, such as\n    :class:`~qiskit.algorithms.optimizers.SPSA` or a callable with the following signature:\n\n    .. note::\n\n        The callable _must_ have the argument names ``fun, x0, jac, bounds`` as indicated\n        in the following code block.\n\n    .. code-block::python\n\n        from qiskit.algorithms.optimizers import OptimizerResult\n\n        def my_minimizer(fun, x0, jac=None, bounds=None) -> OptimizerResult:\n            # Note that the callable *must* have these argument names!\n            # Args:\n            #     fun (callable): the function to minimize\n            #     x0 (np.ndarray): the initial point for the optimization\n            #     jac (callable, optional): the gradient of the objective function\n            #     bounds (list, optional): a list of tuples specifying the parameter bounds\n\n            result = OptimizerResult()\n            result.x = # optimal parameters\n            result.fun = # optimal function value\n            return result\n\n    The above signature also allows to directly pass any SciPy minimizer, for instance as\n\n    .. code-block::python\n\n        from functools import partial\n        from scipy.optimize import minimize\n\n        optimizer = partial(minimize, method="L-BFGS-B")\n\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load())), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=False), Num(n=1), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as Ansatz for the wave function.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQE performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        '))
Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[]))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None))
If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())], value=Name(id='callback', ctx=Load()))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the ansatz.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n            If None is passed, RealAmplitudes is used by default.\n\n        '))
If(test=Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Attribute(value=Name(id='ansatz', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the gradient.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the gradient.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))
Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns quantum instance.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets quantum_instance'))
If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))]))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns initial point'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets initial point'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())], value=Name(id='initial_point', ctx=Load()))
Attribute(value=Name(id='initial_point', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns max_evals_grouped'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets max_evals_grouped'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())], value=Name(id='max_evals_grouped', ctx=Load()))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[]))
Attribute(value=Name(id='max_evals_grouped', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns include_custom'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        '))
If(test=Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))], orelse=[])
Attribute(value=Name(id='include_custom', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns callback'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets callback'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())], value=Name(id='callback', ctx=Load()))
Attribute(value=Name(id='callback', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='exp', ctx=Load()))
Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Check that the number of qubits of operator and ansatz match.'))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])], orelse=[])
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns optimizer'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='Optimizer', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        '))
If(test=Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))], orelse=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())], value=Name(id='optimizer', ctx=Load()))
Attribute(value=Name(id='optimizer', ctx=Load()), attr='setter', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Prepare the setting of VQE as a string.'))
Assign(targets=[Name(id='ret', ctx=Store())], value=JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))
Assign(targets=[Name(id='params', ctx=Store())], value=Str(s=''))
For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])], orelse=[])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)]))
Return(value=Name(id='ret', ctx=Load()))
Name(id='property', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Preparing the setting of VQE into a string.\n\n        Returns:\n            str: the formatted setting of VQE\n        '))
Assign(targets=[Name(id='ret', ctx=Store())], value=Str(s='\n'))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='Optimizer is custom callable\n'))], orelse=[AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='===============================================================\n'))
Return(value=Name(id='ret', ctx=Load()))
arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)])
Expr(value=Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        "))
If(test=Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))])
Assign(targets=[Name(id='wave_function', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='observable_meas', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[]))
Assign(targets=[Name(id='ansatz_circuit_op', ctx=Store())], value=Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[]))
If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='expect_op', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        '))
Assign(targets=[Name(id='expect_op', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='circuits', ctx=Store())], value=List(elts=[], ctx=Load()))
FunctionDef(name='extract_circuits', args=arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])], decorator_list=[], returns=None)
Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[]))
Return(value=Name(id='circuits', ctx=Load()))
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='cls', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Return(value=NameConstant(value=True))
Name(id='classmethod', ctx=Load())
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())], value=NameConstant(value=True))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='initial_point', ctx=Store())], value=Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
If(test=Name(id='aux_operators', ctx=Load()), body=[Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))]), For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[]), Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))], orelse=[Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())], value=Num(n=0))
Assign(targets=[Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))]))
Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]))
If(test=Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))], orelse=[Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))])
Assign(targets=[Name(id='eval_time', ctx=Store())], value=BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load())))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='VQEResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())], value=Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())], value=Name(id='eval_time', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalue', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()), op=Add(), right=Num(n=0j)))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='eigenstate', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())], value=Name(id='result', ctx=Load()))
If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])), Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))], orelse=[])
Return(value=Name(id='result', ctx=Load()))
Name(id='MinimumEigensolverResult', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load())), arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=False)])
Expr(value=Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This is the objective function to be passed to the optimizer that is used for evaluation.\n\n        Args:\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n\n\n        Returns:\n            Energy of the hamiltonian of each parameter, and, optionally, the expectation\n            converter.\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n\n        '))
Assign(targets=[Name(id='num_parameters', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()))
If(test=Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='ansatz_params', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()))
Assign(targets=[Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))]))
FunctionDef(name='energy_evaluation', args=arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])), Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='end_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])), Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))], decorator_list=[], returns=None)
If(test=Name(id='return_expectation', ctx=Load()), body=[Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))], orelse=[])
Return(value=Name(id='energy_evaluation', ctx=Load()))
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='optimal_parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the simulation outcome of the ansatz, provided with parameters.'))
Assign(targets=[Name(id='optimal_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='state_fn', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[]))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))], orelse=[Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))])
Return(value=Name(id='state', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Str(s='VQE Result.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns number of cost optimizer evaluations'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets number of cost function evaluations'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='cost_function_evals', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='return eigen state'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='set eigen state'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='eigenstate', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arg(arg='point', annotation=None)
arg(arg='ansatz', annotation=None)
Name(id='expected_size', ctx=Store())
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
BoolOp(op=And(), values=[Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='preferred_init_points')], keywords=[])])
Assign(targets=[Name(id='point', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='preferred_init_points', ctx=Load()))
Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='bounds', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds'), NameConstant(value=None)], keywords=[]))
If(test=Compare(left=Name(id='bounds', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load())))], orelse=[])
Assign(targets=[Name(id='lower_bounds', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='upper_bounds', ctx=Store())], value=List(elts=[], ctx=Load()))
For(target=Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store()), iter=Name(id='bounds', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))], orelse=[])
Assign(targets=[Name(id='point', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Name(id='lower_bounds', ctx=Load()), Name(id='upper_bounds', ctx=Load())], keywords=[]))
If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='expected_size', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])
Name(id='point', ctx=Load())
arg(arg='ansatz', annotation=None)
BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds')], keywords=[]), Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Assign(targets=[Name(id='bounds', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()))
If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())))
Name(id='bounds', ctx=Load())
Name(id='logging', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='initial_point', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load()))
arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))
arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))
arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=False)
Num(n=1)
NameConstant(value=None)
NameConstant(value=None)
Str(s='\n\n        Args:\n            ansatz: A parameterized circuit used as Ansatz for the wave function.\n            optimizer: A classical optimizer. Can either be a Qiskit optimizer or a callable\n                that takes an array as input and returns a Qiskit or SciPy optimization result.\n            initial_point: An optional initial point (i.e. initial parameter values)\n                for the optimizer. If ``None`` then VQE will look to the ansatz for a preferred\n                point and if not will simply compute a random one.\n            gradient: An optional gradient function or operator for optimizer.\n            expectation: The Expectation converter for taking the average value of the\n                Observable over the ansatz state function. When ``None`` (the default) an\n                :class:`~qiskit.opflow.expectations.ExpectationFactory` is used to select\n                an appropriate expectation based on the operator and backend. When using Aer\n                qasm_simulator backend, with paulis, it is however much faster to leverage custom\n                Aer function for the computation but, although VQE performs much faster\n                with it, the outcome is ideal, with no shot noise, like using a state vector\n                simulator. If you are just looking for the quickest performance when choosing Aer\n                qasm_simulator and the lack of shot noise is not an issue then set `include_custom`\n                parameter here to ``True`` (defaults to ``False``).\n            include_custom: When `expectation` parameter here is None setting this to ``True`` will\n                allow the factory to include the custom Aer pauli expectation.\n            max_evals_grouped: Max number of evaluations performed simultaneously. Signals the\n                given optimizer that more than one set of parameters can be supplied so that\n                potentially the expectation values can be computed in parallel. Typically this is\n                possible when a finite difference gradient is used by the optimizer such that\n                multiple points to compute the gradient can be passed and if computed in parallel\n                improve overall execution time. Deprecated if a gradient operator or function is\n                given.\n            callback: a callback that can access the intermediate data during the optimization.\n                Four parameter values are passed to the callback as follows during each evaluation\n                by the optimizer for its current set of parameters as it works towards the minimum.\n                These are: the evaluation count, the optimizer parameters for the\n                ansatz, the evaluated mean and the evaluated standard deviation.`\n            quantum_instance: Quantum Instance or Backend\n\n        ')
Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='max_evals_grouped'), Name(id='max_evals_grouped', ctx=Load()), Num(n=1)], keywords=[])
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())
Name(id='max_evals_grouped', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())
Name(id='expectation', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())
Name(id='include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Store())
Name(id='ansatz', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Store())
Name(id='optimizer', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Store())
Name(id='initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())
Name(id='gradient', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
NameConstant(value=None)
Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_time', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Num(n=0)
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='callback', ctx=Store())
Name(id='callback', ctx=Load())
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='Returns the ansatz.')
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='ansatz', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
Str(s='Sets the ansatz.\n\n        Args:\n            ansatz: The parameterized circuit used as an ansatz.\n            If None is passed, RealAmplitudes is used by default.\n\n        ')
Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='ansatz', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
Name(id='ansatz', ctx=Load())
Name(id='ansatz', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns the gradient.')
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Sets the gradient.')
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())
Name(id='gradient', ctx=Load())
Name(id='gradient', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns quantum instance.')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Sets quantum_instance')
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Store())
Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))])
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns initial point')
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Str(s='Sets initial point')
Attribute(value=Name(id='self', ctx=Load()), attr='_initial_point', ctx=Store())
Name(id='initial_point', ctx=Load())
Name(id='initial_point', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns max_evals_grouped')
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='max_evals_grouped', annotation=Name(id='int', ctx=Load()))
Str(s='Sets max_evals_grouped')
Attribute(value=Name(id='self', ctx=Load()), attr='_max_evals_grouped', ctx=Store())
Name(id='max_evals_grouped', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Name(id='max_evals_grouped', ctx=Load())], keywords=[])
Name(id='max_evals_grouped', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns include_custom')
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='include_custom', annotation=Name(id='bool', ctx=Load()))
Str(s='Sets include_custom. If set to another value than the one that was previsously set,\n        the expectation attribute is reset to None.\n        ')
Compare(left=Name(id='include_custom', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())], value=Name(id='include_custom', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())], value=NameConstant(value=None))
Name(id='include_custom', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns callback')
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Sets callback')
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Store())
Name(id='callback', ctx=Load())
Name(id='callback', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='exp', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
Name(id='exp', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
Str(s='Check that the number of qubits of operator and ansatz match.')
BoolOp(op=And(), values=[Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
If(test=Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])], orelse=[])
arg(arg='self', annotation=None)
Str(s='Returns optimizer')
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))
Str(s='Sets the optimizer attribute.\n\n        Args:\n            optimizer: The optimizer to be used. If None is passed, SLSQP is used by default.\n\n        ')
Compare(left=Name(id='optimizer', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[]))
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='optimizer', ctx=Load()), Name(id='Optimizer', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Store())
Name(id='optimizer', ctx=Load())
Name(id='optimizer', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Prepare the setting of VQE as a string.')
Name(id='ret', ctx=Store())
JoinedStr(values=[Str(s='Algorithm: '), FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])
Name(id='params', ctx=Store())
Str(s='')
Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
If(test=Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])], orelse=[])
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)])
Name(id='ret', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='\n        Preparing the setting of VQE into a string.\n\n        Returns:\n            str: the formatted setting of VQE\n        ')
Name(id='ret', ctx=Store())
Str(s='\n')
Name(id='ret', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())], keywords=[])
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[]))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='ansatz has not been set'))
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[])
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=Str(s='Optimizer is custom callable\n'))
AugAssign(target=Name(id='ret', ctx=Store()), op=Add(), value=JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)]))
Name(id='ret', ctx=Store())
Add()
Str(s='===============================================================\n')
Name(id='ret', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=False)
Str(s="\n        Generate the ansatz circuit and expectation value measurement, and return their\n        runnable composition.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to compute the standard\n                deviation of the expectation value.\n\n        Returns:\n            The Operator equalling the measurement of the ansatz :class:`StateFn` by the\n            Observable's expectation :class:`StateFn`, and, optionally, the expectation converter.\n\n        Raises:\n            AlgorithmError: If no operator has been provided.\n            AlgorithmError: If no expectation is passed and None could be inferred via the\n                ExpectationFactory.\n        ")
Compare(left=Name(id='operator', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[]), cause=None)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))]))
Assign(targets=[Name(id='expectation', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load()))
Name(id='wave_function', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Name(id='parameter', ctx=Load())], keywords=[])
Name(id='observable_meas', ctx=Store())
Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])], keywords=[])
Name(id='ansatz_circuit_op', ctx=Store())
Call(func=Name(id='CircuitStateFn', ctx=Load()), args=[Name(id='wave_function', ctx=Load())], keywords=[])
Name(id='expect_op', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load()), args=[], keywords=[])
Name(id='return_expectation', ctx=Load())
Return(value=Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))
Name(id='expect_op', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='parameter', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
Str(s='Return the circuits used to compute the expectation value.\n\n        Args:\n            parameter: Parameters for the ansatz circuit.\n            operator: Qubit operator of the Observable\n\n        Returns:\n            A list of the circuits used to compute the expectation value.\n        ')
Name(id='expect_op', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load()), args=[], keywords=[])
Name(id='circuits', ctx=Store())
List(elts=[], ctx=Load())
arguments(args=[arg(arg='op', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])])
Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[])
Name(id='circuits', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
arg(arg='cls', annotation=None)
NameConstant(value=True)
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Name(id='operator', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='circuit_summary', ctx=Store())
NameConstant(value=True)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Name(id='initial_point', ctx=Store())
Call(func=Name(id='_validate_initial_point', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Name(id='bounds', ctx=Store())
Call(func=Name(id='_validate_bounds', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Name(id='aux_operators', ctx=Load())
Assign(targets=[Name(id='zero_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))], orelse=[Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))])
For(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store()), iter=Name(id='key_op_iterator', ctx=Load()), body=[If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])], orelse=[])
Assign(targets=[Name(id='aux_operators', ctx=Store())], value=Name(id='converted', ctx=Load()))
Assign(targets=[Name(id='aux_operators', ctx=Store())], value=NameConstant(value=None))
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), Name(id='GradientBase', ctx=Load())], keywords=[])
Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))]))
Assign(targets=[Name(id='gradient', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='energy_evaluation', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])
Name(id='start_time', ctx=Store())
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Call(func=Name(id='callable', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())], keywords=[])
Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))
Assign(targets=[Name(id='opt_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))]))
Name(id='eval_time', ctx=Store())
BinOp(left=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]), op=Sub(), right=Name(id='start_time', ctx=Load()))
Name(id='result', ctx=Store())
Call(func=Name(id='VQEResult', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Store())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Store())
Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_value', ctx=Store())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='cost_function_evals', ctx=Store())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='nfev', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimizer_time', ctx=Store())
Name(id='eval_time', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='eigenvalue', ctx=Store())
BinOp(left=Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load()), op=Add(), right=Num(n=0j))
Attribute(value=Name(id='result', ctx=Load()), attr='eigenstate', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals'), Name(id='eval_time', ctx=Load()), Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_ret', ctx=Store())
Name(id='result', ctx=Load())
Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='bound_ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))
Name(id='result', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='operator', annotation=Name(id='OperatorBase', ctx=Load()))
arg(arg='return_expectation', annotation=Name(id='bool', ctx=Load()))
NameConstant(value=False)
Str(s='Returns a function handle to evaluates the energy at given parameters for the ansatz.\n\n        This is the objective function to be passed to the optimizer that is used for evaluation.\n\n        Args:\n            operator: The operator whose energy to evaluate.\n            return_expectation: If True, return the ``ExpectationBase`` expectation converter used\n                in the construction of the expectation value. Useful e.g. to evaluate other\n                operators with the same expectation value converter.\n\n\n        Returns:\n            Energy of the hamiltonian of each parameter, and, optionally, the expectation\n            converter.\n\n        Raises:\n            RuntimeError: If the circuit is not parameterized (i.e. has 0 free parameters).\n\n        ')
Name(id='num_parameters', ctx=Store())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
Compare(left=Name(id='num_parameters', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Raise(exc=Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[]), cause=None)
Name(id='ansatz_params', ctx=Store())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Tuple(elts=[Name(id='expect_op', ctx=Store()), Name(id='expectation', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[keyword(arg='return_expectation', value=NameConstant(value=True))])
arguments(args=[arg(arg='parameters', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='parameter_sets', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[]))
Assign(targets=[Name(id='param_bindings', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='start_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='sampled_expect_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))]))
Assign(targets=[Name(id='means', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])], orelse=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))])
Assign(targets=[Name(id='end_time', ctx=Store())], value=Call(func=Name(id='time', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[]))
Return(value=IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())))
Name(id='return_expectation', ctx=Load())
Return(value=Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load()))
Name(id='energy_evaluation', ctx=Load())
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='optimal_parameters', annotation=None)
Str(s='Get the simulation outcome of the ansatz, provided with parameters.')
Name(id='optimal_circuit', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Name(id='optimal_parameters', ctx=Load())], keywords=[])
Name(id='state_fn', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load()), args=[], keywords=[])
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load()))
Assign(targets=[Name(id='state', ctx=Store())], value=Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load()))
Name(id='state', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='Returns number of cost optimizer evaluations')
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='int', ctx=Load()))
Str(s='Sets number of cost function evaluations')
Attribute(value=Name(id='self', ctx=Load()), attr='_cost_function_evals', ctx=Store())
Name(id='value', ctx=Load())
Name(id='cost_function_evals', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='return eigen state')
Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Str(s='set eigen state')
Attribute(value=Name(id='self', ctx=Load()), attr='_eigenstate', ctx=Store())
Name(id='value', ctx=Load())
Name(id='eigenstate', ctx=Load())
Load()
Store()
Name(id='ansatz', ctx=Load())
Load()
And()
Compare(left=Name(id='point', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='preferred_init_points')], keywords=[])
Name(id='point', ctx=Store())
Attribute(value=Name(id='ansatz', ctx=Load()), attr='preferred_init_points', ctx=Load())
Name(id='point', ctx=Load())
Is()
NameConstant(value=None)
Name(id='bounds', ctx=Store())
Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds'), NameConstant(value=None)], keywords=[])
Compare(left=Name(id='bounds', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='bounds', ctx=Store())], value=BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load())))
Name(id='lower_bounds', ctx=Store())
List(elts=[], ctx=Load())
Name(id='upper_bounds', ctx=Store())
List(elts=[], ctx=Load())
Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store())
Name(id='bounds', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[]))
Name(id='point', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load()), args=[Name(id='lower_bounds', ctx=Load()), Name(id='upper_bounds', ctx=Load())], keywords=[])
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Name(id='expected_size', ctx=Load())])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)
Load()
And()
Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='ansatz', ctx=Load()), Str(s='parameter_bounds')], keywords=[])
Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Name(id='bounds', ctx=Store())
Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load())
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[]), cause=None)
Name(id='bounds', ctx=Store())
BinOp(left=List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load()), op=Mult(), right=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()))
Load()
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Name(id='int', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='validate_min', ctx=Load())
Str(s='max_evals_grouped')
Name(id='max_evals_grouped', ctx=Load())
Num(n=1)
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='quantum_instance', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load()), args=[], keywords=[])
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Name(id='ansatz', ctx=Load())
Is()
NameConstant(value=None)
Name(id='ansatz', ctx=Store())
Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], keywords=[])
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='CircuitSampler', ctx=Load())
Name(id='quantum_instance', ctx=Load())
keyword(arg='param_qobj', value=Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[]))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load())
Name(id='max_evals_grouped', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='bool', ctx=Load())
Name(id='include_custom', ctx=Load())
NotEq()
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Store())
Name(id='include_custom', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Store())
NameConstant(value=None)
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='ExpectationBase', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
And()
Compare(left=Name(id='operator', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())])
Try(body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))], handlers=[ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])], orelse=[], finalbody=[])
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())
Name(id='optimizer', ctx=Load())
Is()
NameConstant(value=None)
Name(id='optimizer', ctx=Store())
Call(func=Name(id='SLSQP', ctx=Load()), args=[], keywords=[])
Name(id='isinstance', ctx=Load())
Name(id='optimizer', ctx=Load())
Name(id='Optimizer', ctx=Load())
Call(func=Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Store()
Str(s='Algorithm: ')
FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load()), conversion=-1, format_spec=None)
Str(s='\n')
Store()
Name(id='key', ctx=Store())
Name(id='value', ctx=Store())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load()), attr='items', ctx=Load())
Compare(left=Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[Eq()], comparators=[Str(s='_')])
If(test=BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))], orelse=[AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))])
Store()
FormattedValue(value=Name(id='params', ctx=Load()), conversion=-1, format_spec=None)
Load()
Store()
Store()
Attribute(value=Str(s='==================== Setting of {} ============================\n'), attr='format', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())
Store()
FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='ret', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='{}'), attr='format', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])], keywords=[])
Name(id='ret', ctx=Store())
Add()
Str(s='ansatz has not been set')
Store()
Name(id='callable', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Name(id='ret', ctx=Store())
Add()
Str(s='Optimizer is custom callable\n')
Name(id='ret', ctx=Store())
Add()
JoinedStr(values=[FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)])
Store()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='OperatorBase', ctx=Load())
Name(id='bool', ctx=Load())
Name(id='operator', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The operator was never provided.')], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load())
Name(id='operator', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load())
Is()
NameConstant(value=None)
Name(id='expectation', ctx=Store())
Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='operator', ctx=Load())), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())), keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))])
Name(id='expectation', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='expectation', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='assign_parameters', ctx=Load())
Name(id='parameter', ctx=Load())
Store()
Attribute(value=Name(id='expectation', ctx=Load()), attr='convert', ctx=Load())
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[keyword(arg='is_measurement', value=NameConstant(value=True))])
Store()
Name(id='CircuitStateFn', ctx=Load())
Name(id='wave_function', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[]), attr='reduce', ctx=Load())
Load()
Tuple(elts=[Name(id='expect_op', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='OperatorBase', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[]), attr='to_circuit_op', ctx=Load())
Store()
Load()
arg(arg='op', annotation=None)
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='CircuitStateFn', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[]), body=[For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])
Name(id='extract_circuits', ctx=Load())
Name(id='expect_op', ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='OperatorBase', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())), ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='compute_minimum_eigenvalue', ctx=Load())
Name(id='operator', ctx=Load())
Name(id='aux_operators', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_check_operator_ansatz', ctx=Load())
Name(id='operator', ctx=Load())
Store()
Name(id='_validate_initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='initial_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Store()
Name(id='_validate_bounds', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='zero_op', ctx=Store())
Call(func=Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load()), args=[List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_operators', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='converted', ctx=Store())], value=BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='key_op_iterator', ctx=Store())], value=Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='converted', ctx=Store())], value=Dict(keys=[], values=[]))
Tuple(elts=[Name(id='key', ctx=Store()), Name(id='op', ctx=Store())], ctx=Store())
Name(id='key_op_iterator', ctx=Load())
If(test=Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))], orelse=[])
Name(id='aux_operators', ctx=Store())
Name(id='converted', ctx=Load())
Name(id='aux_operators', ctx=Store())
NameConstant(value=None)
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Name(id='GradientBase', ctx=Load())
Name(id='gradient', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))], keywords=[keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))])
Name(id='gradient', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='energy_evaluation', ctx=Store())
Name(id='expectation', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='get_energy_evaluation', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='return_expectation', value=NameConstant(value=True))
Store()
Name(id='time', ctx=Load())
Name(id='callable', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Name(id='opt_result', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))])
Name(id='opt_result', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load()), args=[], keywords=[keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load())), keyword(arg='x0', value=Name(id='initial_point', ctx=Load())), keyword(arg='jac', value=Name(id='gradient', ctx=Load())), keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))])
Store()
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Sub()
Name(id='start_time', ctx=Load())
Store()
Name(id='VQEResult', ctx=Load())
Name(id='result', ctx=Load())
Store()
Name(id='opt_result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Name(id='dict', ctx=Load())
Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())], keywords=[])
Name(id='result', ctx=Load())
Store()
Name(id='opt_result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Name(id='opt_result', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='opt_result', ctx=Load()), attr='fun', ctx=Load())
Add()
Num(n=0j)
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_eigenstate', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_parameters', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Optimization complete in %s seconds.\nFound opt_params %s in %s evals')
Name(id='eval_time', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='aux_operators', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='bound_ansatz', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load()), args=[Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())], keywords=[])
Name(id='aux_values', ctx=Store())
Call(func=Name(id='eval_observables', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), Name(id='bound_ansatz', ctx=Load()), Name(id='aux_operators', ctx=Load())], keywords=[keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))])
Attribute(value=Name(id='result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())
Name(id='aux_values', ctx=Load())
Load()
Name(id='OperatorBase', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='num_parameters', ctx=Load())
Eq()
Num(n=0)
Call(func=Name(id='RuntimeError', ctx=Load()), args=[Str(s='The ansatz must be parameterized, but has 0 free parameters.')], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='expect_op', ctx=Store())
Name(id='expectation', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load())
Name(id='ansatz_params', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='return_expectation', value=NameConstant(value=True))
arg(arg='parameters', annotation=None)
Name(id='parameter_sets', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())], keywords=[])
Name(id='param_bindings', ctx=Store())
Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])
Name(id='start_time', ctx=Store())
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Name(id='sampled_expect_op', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expect_op', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))])
Name(id='means', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='variance', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Name(id='estimator_error', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[]))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[]), body=[AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])
AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]))
Name(id='end_time', ctx=Store())
Call(func=Name(id='time', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s'), Name(id='means', ctx=Load()), BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000)), Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())], keywords=[])
IfExp(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), body=Name(id='means', ctx=Load()), orelse=Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Load()
Tuple(elts=[Name(id='energy_evaluation', ctx=Load()), Name(id='expectation', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Name(id='optimal_parameters', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[]), attr='eval', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Name(id='state', ctx=Store())
Attribute(value=Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load()), attr='data', ctx=Load())
Name(id='state', ctx=Store())
Attribute(value=Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[]), attr='primitive', ctx=Load())
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Name(id='point', ctx=Load())
Is()
NameConstant(value=None)
Name(id='hasattr', ctx=Load())
Name(id='ansatz', ctx=Load())
Str(s='preferred_init_points')
Store()
Name(id='ansatz', ctx=Load())
Load()
Load()
Store()
Name(id='getattr', ctx=Load())
Name(id='ansatz', ctx=Load())
Str(s='parameter_bounds')
NameConstant(value=None)
Name(id='bounds', ctx=Load())
Is()
NameConstant(value=None)
Name(id='bounds', ctx=Store())
BinOp(left=List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load()), op=Mult(), right=Name(id='expected_size', ctx=Load()))
Store()
Load()
Store()
Load()
Name(id='lower', ctx=Store())
Name(id='upper', ctx=Store())
Store()
Load()
Call(func=Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])
Call(func=Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load()), args=[IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], keywords=[])
Store()
Attribute(value=Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load()), attr='uniform', ctx=Load())
Name(id='lower_bounds', ctx=Load())
Name(id='upper_bounds', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[])
NotEq()
Name(id='expected_size', ctx=Load())
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[])
Name(id='hasattr', ctx=Load())
Name(id='ansatz', ctx=Load())
Str(s='parameter_bounds')
Attribute(value=Name(id='ansatz', ctx=Load()), attr='parameter_bounds', ctx=Load())
IsNot()
NameConstant(value=None)
Store()
Name(id='ansatz', ctx=Load())
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[])
NotEq()
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])], keywords=[])
Store()
List(elts=[Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())], ctx=Load())
Mult()
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='print_settings', ctx=Load())
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Load()
Store()
Name(id='RealAmplitudes', ctx=Load())
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Name(id='is_aer_provider', ctx=Load()), args=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())], keywords=[])
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
Load()
Load()
Name(id='operator', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load())
NotEq()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())], value=Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load()))
ExceptHandler(type=Name(id='AttributeError', ctx=Load()), name='ex', body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))])
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='Optimizer', ctx=Load()))
Load()
Load()
Store()
Name(id='SLSQP', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='optimizer', ctx=Load()), attr='set_max_evals_grouped', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='max_evals_grouped', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load()), attr='__name__', ctx=Load())
Store()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='__dict__', ctx=Load())
Load()
Subscript(value=Name(id='key', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Eq()
Str(s='_')
BoolOp(op=And(), values=[Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())]), Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[]))
AugAssign(target=Name(id='params', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')]))
Name(id='params', ctx=Load())
Str(s='==================== Setting of {} ============================\n')
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='setting', ctx=Load())
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Str(s='{}'), attr='format', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load()), args=[], keywords=[keyword(arg='output', value=Str(s='text'))])
Store()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Store()
FormattedValue(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load()), conversion=-1, format_spec=None)
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='The operator was never provided.')
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load())
keyword(arg='operator', value=Name(id='operator', ctx=Load()))
keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()))
keyword(arg='include_custom', value=Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load()))
Store()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Name(id='expectation', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='operator', ctx=Load())
keyword(arg='is_measurement', value=NameConstant(value=True))
Load()
Load()
Call(func=Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='ansatz_circuit_op', ctx=Load())], keywords=[])
Load()
Name(id='expect_op', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
Name(id='OperatorBase', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()))
Load()
Load()
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='parameter', ctx=Load()), Name(id='operator', ctx=Load())], keywords=[])
Load()
Name(id='isinstance', ctx=Load())
Name(id='op', ctx=Load())
Name(id='CircuitStateFn', ctx=Load())
Call(func=Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load()), args=[Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='op', ctx=Load()), Name(id='ListOp', ctx=Load())], keywords=[])
For(target=Name(id='op_i', ctx=Store()), iter=Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load()), body=[Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))], orelse=[])
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()))
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='PauliSumOp', ctx=Load()), attr='from_list', ctx=Load())
List(elts=[Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())], ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='list', ctx=Load())
Name(id='key_op_iterator', ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Name(id='converted', ctx=Store())
BinOp(left=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]))
Name(id='key_op_iterator', ctx=Store())
Call(func=Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
Name(id='converted', ctx=Store())
Dict(keys=[], values=[])
Name(id='key', ctx=Store())
Name(id='op', ctx=Store())
Store()
Load()
Compare(left=Name(id='op', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())], value=IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load())))
Store()
Load()
Store()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()), attr='gradient_wrapper', ctx=Load())
BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
keyword(arg='bind_params', value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[]))
keyword(arg='backend', value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Store()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Load()
NameConstant(value=True)
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load()))
keyword(arg='x0', value=Name(id='initial_point', ctx=Load()))
keyword(arg='jac', value=Name(id='gradient', ctx=Load()))
keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load()), attr='minimize', ctx=Load())
keyword(arg='fun', value=Name(id='energy_evaluation', ctx=Load()))
keyword(arg='x0', value=Name(id='initial_point', ctx=Load()))
keyword(arg='jac', value=Name(id='gradient', ctx=Load()))
keyword(arg='bounds', value=Name(id='bounds', ctx=Load()))
Name(id='time', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='zip', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Attribute(value=Name(id='opt_result', ctx=Load()), attr='x', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='opt_result', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='bind_parameters', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='optimal_point', ctx=Load())
Store()
Name(id='eval_observables', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Name(id='bound_ansatz', ctx=Load())
Name(id='aux_operators', ctx=Load())
keyword(arg='expectation', value=Name(id='expectation', ctx=Load()))
Name(id='result', ctx=Load())
Store()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='RuntimeError', ctx=Load())
Str(s='The ansatz must be parameterized, but has 0 free parameters.')
Name(id='self', ctx=Load())
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='reshape', ctx=Load())
Name(id='parameters', ctx=Load())
Tuple(elts=[UnaryOp(op=USub(), operand=Num(n=1)), Name(id='num_parameters', ctx=Load())], ctx=Load())
Store()
Name(id='dict', ctx=Load())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='ansatz_params', ctx=Load()), Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])], keywords=[])
Store()
Name(id='time', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load())
Name(id='expect_op', ctx=Load())
keyword(arg='params', value=Name(id='param_bindings', ctx=Load()))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Call(func=Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='variance', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])], keywords=[])
Name(id='estimator_error', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))], keywords=[])
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='param_set', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='parameter_sets', ctx=Load())], keywords=[])
AugAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store()), op=Add(), value=Num(n=1))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Add()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[])
Store()
Name(id='time', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Energy evaluation returned %s - %.5f (ms), eval count: %s')
Name(id='means', ctx=Load())
BinOp(left=BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load())), op=Mult(), right=Num(n=1000))
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)])
Name(id='means', ctx=Load())
Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='energy_evaluation', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])], keywords=[])
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='state_fn', ctx=Load()), attr='primitive', ctx=Load())
Load()
Store()
Call(func=Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load()), args=[], keywords=[])
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Store()
List(elts=[Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())], ctx=Load())
Mult()
Name(id='expected_size', ctx=Load())
Store()
Store()
Attribute(value=Name(id='lower_bounds', ctx=Load()), attr='append', ctx=Load())
IfExp(test=Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='lower', ctx=Load()), orelse=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Attribute(value=Name(id='upper_bounds', ctx=Load()), attr='append', ctx=Load())
IfExp(test=Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=Name(id='upper', ctx=Load()), orelse=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Attribute(value=Name(id='algorithm_globals', ctx=Load()), attr='random', ctx=Load())
Load()
Load()
Load()
Name(id='len', ctx=Load())
Name(id='point', ctx=Load())
Load()
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The dimension of the initial point ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])
Load()
Load()
Name(id='ansatz', ctx=Load())
Load()
Load()
Name(id='len', ctx=Load())
Name(id='bounds', ctx=Load())
Name(id='ansatz', ctx=Load())
Load()
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The number of bounds ('), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=') does not match the number of parameters in the circuit ('), FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None), Str(s=').')])
Tuple(elts=[NameConstant(value=None), NameConstant(value=None)], ctx=Load())
Load()
Name(id='ansatz', ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='is_aer_provider', ctx=Load())
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='backend', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='operator', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Store())
Attribute(value=Name(id='operator', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='AttributeError', ctx=Load())
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[]), cause=Name(id='ex', ctx=Load()))
Load()
Name(id='Optimizer', ctx=Load())
Load()
Name(id='optimizer', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='__class__', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='key', ctx=Load())
Index(value=Num(n=0))
Load()
And()
Compare(left=Str(s='initial_point'), ops=[In()], comparators=[Name(id='key', ctx=Load())])
Compare(left=Name(id='value', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Name(id='params', ctx=Store())
Add()
Call(func=Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load()), args=[Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), Str(s='Random seed')], keywords=[])
Name(id='params', ctx=Store())
Add()
JoinedStr(values=[Str(s='-- '), FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None), Str(s='\n')])
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Str(s='{}')
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='draw', ctx=Load())
keyword(arg='output', value=Str(s='text'))
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load()), attr='setting', ctx=Load())
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Name(id='ExpectationFactory', ctx=Load())
Load()
Name(id='operator', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_include_custom', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='observable_meas', ctx=Load()), attr='compose', ctx=Load())
Name(id='ansatz_circuit_op', ctx=Load())
Load()
Load()
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='construct_expectation', ctx=Load())
Name(id='parameter', ctx=Load())
Name(id='operator', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='circuits', ctx=Load()), attr='append', ctx=Load())
Attribute(value=Name(id='op', ctx=Load()), attr='primitive', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='op', ctx=Load())
Name(id='ListOp', ctx=Load())
Name(id='op_i', ctx=Store())
Attribute(value=Name(id='op', ctx=Load()), attr='oplist', ctx=Load())
Expr(value=Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[]))
Load()
Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='PauliSumOp', ctx=Load())
Load()
Tuple(elts=[BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Num(n=0)], ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='enumerate', ctx=Load())
Name(id='aux_operators', ctx=Load())
Store()
List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load())
Mult()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='aux_operators', ctx=Load()), attr='items', ctx=Load())
Store()
Store()
Store()
Name(id='op', ctx=Load())
IsNot()
NameConstant(value=None)
Subscript(value=Name(id='converted', ctx=Load()), slice=Index(value=Name(id='key', ctx=Load())), ctx=Store())
IfExp(test=Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=Name(id='zero_op', ctx=Load()), orelse=Name(id='op', ctx=Load()))
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Load()
UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[]))
MatMult()
Call(func=Name(id='StateFn', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='energy_evaluation', ctx=Load())
Name(id='initial_point', ctx=Load())
Name(id='gradient', ctx=Load())
Name(id='bounds', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='optimizer', ctx=Load())
Load()
Name(id='energy_evaluation', ctx=Load())
Name(id='initial_point', ctx=Load())
Name(id='gradient', ctx=Load())
Name(id='bounds', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='opt_result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='expectation', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='num_parameters', ctx=Load())
Load()
Load()
Name(id='zip', ctx=Load())
Name(id='ansatz_params', ctx=Load())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load()), args=[], keywords=[])
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load())
Load()
Load()
Name(id='param_bindings', ctx=Load())
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='sampled_expect_op', ctx=Load()), attr='eval', ctx=Load())
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
Call(func=Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load()), args=[Name(id='sampled_expect_op', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=Name(id='variance', ctx=Load()), op=Div(), right=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load()))
Name(id='i', ctx=Store())
Name(id='param_set', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='parameter_sets', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Store())
Add()
Num(n=1)
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load()), Name(id='param_set', ctx=Load()), Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Name(id='len', ctx=Load())
Name(id='means', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Load()
BinOp(left=Name(id='end_time', ctx=Load()), op=Sub(), right=Name(id='start_time', ctx=Load()))
Mult()
Num(n=1000)
Name(id='self', ctx=Load())
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='means', ctx=Load())], keywords=[])
Gt()
Num(n=1)
Load()
Name(id='means', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load()), attr='convert', ctx=Load())
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='optimal_circuit', ctx=Load())], keywords=[])
Load()
Name(id='state_fn', ctx=Load())
Load()
Attribute(value=Name(id='state_fn', ctx=Load()), attr='to_dict_fn', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='Dict', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='super', ctx=Load())
Load()
Load()
Tuple(elts=[BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))], ctx=Load())
Load()
Load()
Name(id='lower_bounds', ctx=Load())
Load()
Compare(left=Name(id='lower', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Name(id='lower', ctx=Load())
BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Name(id='upper_bounds', ctx=Load())
Load()
Compare(left=Name(id='upper', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Name(id='upper', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Name(id='algorithm_globals', ctx=Load())
Load()
Load()
Load()
Load()
Str(s='The dimension of the initial point (')
FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Str(s=') does not match the number of parameters in the circuit (')
FormattedValue(value=Name(id='expected_size', ctx=Load()), conversion=-1, format_spec=None)
Str(s=').')
Load()
Load()
Load()
Load()
Load()
Str(s='The number of bounds (')
FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Str(s=') does not match the number of parameters in the circuit (')
FormattedValue(value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load()), conversion=-1, format_spec=None)
Str(s=').')
NameConstant(value=None)
NameConstant(value=None)
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load()))
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Name(id='quantum_instance', ctx=Load())
Load()
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Store()
Name(id='operator', ctx=Load())
Load()
Load()
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')], keywords=[])
Name(id='ex', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Num(n=0)
Str(s='initial_point')
In()
Name(id='key', ctx=Load())
Name(id='value', ctx=Load())
Is()
NameConstant(value=None)
Store()
Attribute(value=Str(s='-- {}: {}\n'), attr='format', ctx=Load())
Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load())
Str(s='Random seed')
Store()
Str(s='-- ')
FormattedValue(value=Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()), conversion=-1, format_spec=None)
Str(s=': ')
FormattedValue(value=Name(id='value', ctx=Load()), conversion=-1, format_spec=None)
Str(s='\n')
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Str(s='text')
Attribute(value=Name(id='self', ctx=Load()), attr='_optimizer', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='observable_meas', ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='OperatorBase', ctx=Load()), Name(id='ExpectationBase', ctx=Load())], ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='Parameter', ctx=Load())), ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='circuits', ctx=Load())
Load()
Name(id='op', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='op', ctx=Load())
Load()
Call(func=Name(id='extract_circuits', ctx=Load()), args=[Name(id='op_i', ctx=Load())], keywords=[])
Name(id='ListOrDict', ctx=Load())
Index(value=Name(id='OperatorBase', ctx=Load()))
Load()
Load()
Load()
BinOp(left=Str(s='I'), op=Mult(), right=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()))
Num(n=0)
Load()
Load()
Load()
Name(id='zero_op', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='aux_operators', ctx=Load())
Load()
Load()
Name(id='converted', ctx=Load())
Index(value=Name(id='key', ctx=Load()))
Store()
Compare(left=Name(id='op', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Name(id='zero_op', ctx=Load())
Name(id='op', ctx=Load())
Name(id='self', ctx=Load())
Load()
Invert()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='operator', ctx=Load())], keywords=[])
Name(id='StateFn', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Name(id='list', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
USub()
Num(n=1)
Load()
Load()
Load()
Attribute(value=Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[]), attr='tolist', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='sampled_expect_op', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='expectation', ctx=Load()), attr='compute_variance', ctx=Load())
Name(id='sampled_expect_op', ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='variance', ctx=Load())
Div()
Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load()), attr='shots', ctx=Load())
Store()
Store()
Load()
Load()
Name(id='self', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_callback', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_eval_count', ctx=Load())
Name(id='param_set', ctx=Load())
Subscript(value=Name(id='means', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Subscript(value=Name(id='estimator_error', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Name(id='end_time', ctx=Load())
Sub()
Name(id='start_time', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='means', ctx=Load())
Load()
Num(n=0)
Name(id='np', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit_sampler', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='optimal_circuit', ctx=Load())
Load()
Name(id='state_fn', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Load()
Load()
Name(id='lower', ctx=Load())
IsNot()
NameConstant(value=None)
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Name(id='upper', ctx=Load())
IsNot()
NameConstant(value=None)
Load()
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='point', ctx=Load())], keywords=[])
Name(id='expected_size', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='bounds', ctx=Load())], keywords=[])
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_parameters', ctx=Load())
Load()
Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='Minimizer', ctx=Load())], ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='GradientBase', ctx=Load()), Name(id='Callable', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Tuple(elts=[List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='The number of qubits of the ansatz does not match the operator, and the ansatz does not allow setting the number of qubits using `num_qubits`.')
Load()
Load()
Load()
Load()
Str(s='-- {}: {}\n')
Load()
Name(id='key', ctx=Load())
Slice(lower=Num(n=1), upper=None, step=None)
Load()
Subscript(value=Name(id='key', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load())
Name(id='value', ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='Parameter', ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Name(id='ExpectationBase', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='Parameter', ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='extract_circuits', ctx=Load())
Name(id='op_i', ctx=Load())
Load()
Name(id='OperatorBase', ctx=Load())
Str(s='I')
Mult()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='key', ctx=Load())
Name(id='op', ctx=Load())
Eq()
Num(n=0)
Load()
Load()
Load()
Name(id='StateFn', ctx=Load())
Name(id='operator', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Call(func=Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Name(id='expectation', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), attr='run_config', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='means', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='estimator_error', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='str', ctx=Load())
Name(id='int', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
USub()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='point', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='bounds', ctx=Load())
Name(id='ansatz', ctx=Load())
Load()
Name(id='Optimizer', ctx=Load())
Name(id='Minimizer', ctx=Load())
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Name(id='GradientBase', ctx=Load())
Name(id='Callable', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
List(elts=[Name(id='int', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Load()
Load()
Load()
Num(n=1)
Name(id='key', ctx=Load())
Slice(lower=Num(n=1), upper=None, step=None)
Load()
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='Parameter', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='Parameter', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='parameter_sets', ctx=Load()), attr='transpose', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Load()
USub()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Num(n=1)
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='parameter_sets', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
  metric  value
0     NC      0
DONE!
