Python 3.7.8
Module(body=[Expr(value=Str(s="Shor's factoring algorithm.")), Import(names=[alias(name='array', asname=None)]), Import(names=[alias(name='fractions', asname=None)]), Import(names=[alias(name='logging', asname=None)]), Import(names=[alias(name='math', asname=None)]), Import(names=[alias(name='sys', asname=None)]), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None)], level=0), ImportFrom(module='qiskit.circuit', names=[alias(name='Gate', asname=None), alias(name='Instruction', asname=None), alias(name='ParameterVector', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library', names=[alias(name='QFT', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.quantum_info', names=[alias(name='partial_trace', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='summarize_circuits', asname=None)], level=0), ImportFrom(module='qiskit.utils.arithmetic', names=[alias(name='is_power', asname=None)], level=0), ImportFrom(module='qiskit.utils.quantum_instance', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0), ImportFrom(module='algorithm_result', names=[alias(name='AlgorithmResult', asname=None)], level=2), ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='Shor', bases=[], keywords=[], body=[Expr(value=Str(s="Shor's factoring algorithm.\n\n    Shor's Factoring algorithm is one of the most well-known quantum algorithms and finds the\n    prime factors for input integer :math:`N` in polynomial time.\n\n    Adapted from https://github.com/ttlion/ShorAlgQiskit\n\n    See also https://arxiv.org/abs/quant-ph/0205095\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Name(id='quantum_instance', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum instance.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_get_angles', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='n', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the array of angles to be used in the addition in Fourier Space.')), Assign(targets=[Name(id='bits_little_endian', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=BinOp(left=Name(id='angles', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='_phi_add_gate', args=arguments(args=[arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Gate that performs addition by a in Fourier Space.')), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])], keywords=[keyword(arg='name', value=Str(s='phi_add_a'))])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='angle', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='Gate', ctx=Load())), FunctionDef(name='_double_controlled_phi_add_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Creates a circuit which implements double-controlled modular addition by a.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=2), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))])), Assign(targets=[Name(id='cc_phi_add_a', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load()), args=[Num(n=2)], keywords=[])), Assign(targets=[Name(id='cc_iphi_add_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iphi_add_N', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c_phi_add_N', ctx=Load()), List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_iphi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_controlled_multiple_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular multiplication by a as an instruction.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='x_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load()), Str(s='x')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='x_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='cmult_a_mod_N'))])), Assign(targets=[Name(id='angle_params', ctx=Store())], value=Call(func=Name(id='ParameterVector', ctx=Load()), args=[Str(s='angles')], keywords=[keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))])), Assign(targets=[Name(id='modulo_adder', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load()), args=[Name(id='angle_params', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), FunctionDef(name='append_adder', args=arguments(args=[arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='constant', annotation=Name(id='int', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='partial_constant', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load()))), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=None), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_inv', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())]), body=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))]), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='modulo_adder_inv', ctx=Store())], value=Call(func=Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load())), FunctionDef(name='_power_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular exponentiation a^x as an instruction.')), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))])), Assign(targets=[Name(id='qft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])), Assign(targets=[Name(id='iphi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='c_phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load()), args=[Num(n=1)], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]), body=[Assign(targets=[Name(id='partial_a', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_multiplier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load())), FunctionDef(name='_validate_input', args=arguments(args=[arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check parameters of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Raises:\n            ValueError: Invalid input\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='N'), Name(id='N', ctx=Load()), Num(n=3)], keywords=[])), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='a'), Name(id='a', ctx=Load()), Num(n=2)], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[]), cause=None)], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=None), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct quantum part of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            Quantum circuit.\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_power', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='up_qreg', ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='up_cqreg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='modinv', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='m', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the modular multiplicative inverse of a with respect to the modulus m.')), FunctionDef(name='egcd', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='x', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='g', ctx=Load()), ops=[NotEq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[]), cause=None)], orelse=[]), Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='m', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='_get_factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Apply the continued fractions to find r and the gcd to find the desired factors.')), Assign(targets=[Name(id='x_final', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='measurement', ctx=Load()), Num(n=2)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='In decimal, x_final value for this result is: %s.'), Name(id='x_final', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='x_final', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='x_final value is <= 0, there are no continued fractions.'))], orelse=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=NameConstant(value=None)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[]))]), Assign(targets=[Name(id='T_upper', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='T_upper', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Name(id='x_final', ctx=Load()), op=Div(), right=Name(id='T', ctx=Load()))), Assign(targets=[Name(id='i', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='i')], keywords=[])), Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='f')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[])), Assign(targets=[Name(id='exponential', ctx=Store())], value=Num(n=0.0)), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='denominator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Num(n=1)), If(test=Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])), Continue()], orelse=[]), If(test=Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)]), body=[Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))], orelse=[Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cannot find factors from measurement %s because %s'), Name(id='measurement', ctx=Load()), BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])], keywords=[])), Return(value=NameConstant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='_calculate_continued_fraction', args=arguments(args=[arg(arg='b', annotation=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculate the continued fraction of x/T from the current terms of expansion b.')), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=Num(n=0)), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))))], orelse=[]), AugAssign(target=Name(id='x_over_T', ctx=Store()), op=Add(), value=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='frac', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Approximation number %s of continued fractions:'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Numerator:%s \t\t Denominator: %s.'), Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load()), Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='factor', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2)]), body=[Expr(value=Str(s='Execute the algorithm.\n\n        The input integer :math:`N` to be factored is expected to be odd and greater than 2.\n        Even though this implementation is general, its capability will be limited by the\n        capacity of the simulator/hardware. Another input integer :math:`a`  can also be supplied,\n        which needs to be a co-prime smaller than :math:`N` .\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Returns:\n            ShorResult: results of the algorithm.\n\n        Raises:\n            ValueError: Invalid input\n            AlgorithmError: If a quantum instance or backend has not been provided\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='ShorResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='tf', ctx=Store()), Name(id='b', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())], value=Call(func=Name(id='is_power', ctx=Load()), args=[Name(id='N', ctx=Load())], keywords=[keyword(arg='return_decomposition', value=NameConstant(value=True))])), If(test=Name(id='tf', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])), For(target=Name(id='measurement', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='ShorResult'))], decorator_list=[]), ClassDef(name='ShorResult', bases=[Name(id='AlgorithmResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Shor Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Num(n=0))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns factors')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set factors')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='factors', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns total counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set total counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='total_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns successful counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set successful counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='successful_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])])
Expr(value=Str(s="Shor's factoring algorithm."))
Import(names=[alias(name='array', asname=None)])
Import(names=[alias(name='fractions', asname=None)])
Import(names=[alias(name='logging', asname=None)])
Import(names=[alias(name='math', asname=None)])
Import(names=[alias(name='sys', asname=None)])
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None)], level=0)
ImportFrom(module='qiskit.circuit', names=[alias(name='Gate', asname=None), alias(name='Instruction', asname=None), alias(name='ParameterVector', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library', names=[alias(name='QFT', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.quantum_info', names=[alias(name='partial_trace', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='summarize_circuits', asname=None)], level=0)
ImportFrom(module='qiskit.utils.arithmetic', names=[alias(name='is_power', asname=None)], level=0)
ImportFrom(module='qiskit.utils.quantum_instance', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0)
ImportFrom(module='algorithm_result', names=[alias(name='AlgorithmResult', asname=None)], level=2)
ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2)
Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[]))
ClassDef(name='Shor', bases=[], keywords=[], body=[Expr(value=Str(s="Shor's factoring algorithm.\n\n    Shor's Factoring algorithm is one of the most well-known quantum algorithms and finds the\n    prime factors for input integer :math:`N` in polynomial time.\n\n    Adapted from https://github.com/ttlion/ShorAlgQiskit\n\n    See also https://arxiv.org/abs/quant-ph/0205095\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Name(id='quantum_instance', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum instance.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_get_angles', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='n', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the array of angles to be used in the addition in Fourier Space.')), Assign(targets=[Name(id='bits_little_endian', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=BinOp(left=Name(id='angles', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='_phi_add_gate', args=arguments(args=[arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Gate that performs addition by a in Fourier Space.')), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])], keywords=[keyword(arg='name', value=Str(s='phi_add_a'))])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='angle', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='Gate', ctx=Load())), FunctionDef(name='_double_controlled_phi_add_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Creates a circuit which implements double-controlled modular addition by a.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=2), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))])), Assign(targets=[Name(id='cc_phi_add_a', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load()), args=[Num(n=2)], keywords=[])), Assign(targets=[Name(id='cc_iphi_add_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iphi_add_N', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c_phi_add_N', ctx=Load()), List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_iphi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_controlled_multiple_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular multiplication by a as an instruction.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='x_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load()), Str(s='x')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='x_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='cmult_a_mod_N'))])), Assign(targets=[Name(id='angle_params', ctx=Store())], value=Call(func=Name(id='ParameterVector', ctx=Load()), args=[Str(s='angles')], keywords=[keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))])), Assign(targets=[Name(id='modulo_adder', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load()), args=[Name(id='angle_params', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), FunctionDef(name='append_adder', args=arguments(args=[arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='constant', annotation=Name(id='int', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='partial_constant', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load()))), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=None), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_inv', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())]), body=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))]), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='modulo_adder_inv', ctx=Store())], value=Call(func=Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load())), FunctionDef(name='_power_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular exponentiation a^x as an instruction.')), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))])), Assign(targets=[Name(id='qft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])), Assign(targets=[Name(id='iphi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='c_phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load()), args=[Num(n=1)], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]), body=[Assign(targets=[Name(id='partial_a', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_multiplier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load())), FunctionDef(name='_validate_input', args=arguments(args=[arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check parameters of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Raises:\n            ValueError: Invalid input\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='N'), Name(id='N', ctx=Load()), Num(n=3)], keywords=[])), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='a'), Name(id='a', ctx=Load()), Num(n=2)], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[]), cause=None)], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=None), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct quantum part of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            Quantum circuit.\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_power', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='up_qreg', ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='up_cqreg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='modinv', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='m', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the modular multiplicative inverse of a with respect to the modulus m.')), FunctionDef(name='egcd', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='x', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='g', ctx=Load()), ops=[NotEq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[]), cause=None)], orelse=[]), Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='m', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='_get_factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Apply the continued fractions to find r and the gcd to find the desired factors.')), Assign(targets=[Name(id='x_final', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='measurement', ctx=Load()), Num(n=2)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='In decimal, x_final value for this result is: %s.'), Name(id='x_final', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='x_final', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='x_final value is <= 0, there are no continued fractions.'))], orelse=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=NameConstant(value=None)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[]))]), Assign(targets=[Name(id='T_upper', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='T_upper', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Name(id='x_final', ctx=Load()), op=Div(), right=Name(id='T', ctx=Load()))), Assign(targets=[Name(id='i', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='i')], keywords=[])), Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='f')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[])), Assign(targets=[Name(id='exponential', ctx=Store())], value=Num(n=0.0)), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='denominator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Num(n=1)), If(test=Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])), Continue()], orelse=[]), If(test=Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)]), body=[Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))], orelse=[Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cannot find factors from measurement %s because %s'), Name(id='measurement', ctx=Load()), BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])], keywords=[])), Return(value=NameConstant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='_calculate_continued_fraction', args=arguments(args=[arg(arg='b', annotation=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculate the continued fraction of x/T from the current terms of expansion b.')), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=Num(n=0)), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))))], orelse=[]), AugAssign(target=Name(id='x_over_T', ctx=Store()), op=Add(), value=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='frac', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Approximation number %s of continued fractions:'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Numerator:%s \t\t Denominator: %s.'), Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load()), Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='factor', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2)]), body=[Expr(value=Str(s='Execute the algorithm.\n\n        The input integer :math:`N` to be factored is expected to be odd and greater than 2.\n        Even though this implementation is general, its capability will be limited by the\n        capacity of the simulator/hardware. Another input integer :math:`a`  can also be supplied,\n        which needs to be a co-prime smaller than :math:`N` .\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Returns:\n            ShorResult: results of the algorithm.\n\n        Raises:\n            ValueError: Invalid input\n            AlgorithmError: If a quantum instance or backend has not been provided\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='ShorResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='tf', ctx=Store()), Name(id='b', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())], value=Call(func=Name(id='is_power', ctx=Load()), args=[Name(id='N', ctx=Load())], keywords=[keyword(arg='return_decomposition', value=NameConstant(value=True))])), If(test=Name(id='tf', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])), For(target=Name(id='measurement', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='ShorResult'))], decorator_list=[])
ClassDef(name='ShorResult', bases=[Name(id='AlgorithmResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Shor Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Num(n=0))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns factors')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set factors')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='factors', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns total counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set total counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='total_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns successful counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set successful counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='successful_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
Str(s="Shor's factoring algorithm.")
alias(name='array', asname=None)
alias(name='fractions', asname=None)
alias(name='logging', asname=None)
alias(name='math', asname=None)
alias(name='sys', asname=None)
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='List', asname=None)
alias(name='Tuple', asname=None)
alias(name='numpy', asname='np')
alias(name='ClassicalRegister', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='QuantumRegister', asname=None)
alias(name='Gate', asname=None)
alias(name='Instruction', asname=None)
alias(name='ParameterVector', asname=None)
alias(name='QFT', asname=None)
alias(name='Backend', asname=None)
alias(name='partial_trace', asname=None)
alias(name='summarize_circuits', asname=None)
alias(name='is_power', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='validate_min', asname=None)
alias(name='AlgorithmResult', asname=None)
alias(name='AlgorithmError', asname=None)
Name(id='logger', ctx=Store())
Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])
Expr(value=Str(s="Shor's factoring algorithm.\n\n    Shor's Factoring algorithm is one of the most well-known quantum algorithms and finds the\n    prime factors for input integer :math:`N` in polynomial time.\n\n    Adapted from https://github.com/ttlion/ShorAlgQiskit\n\n    See also https://arxiv.org/abs/quant-ph/0205095\n    "))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Name(id='quantum_instance', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum instance.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='_get_angles', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='n', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the array of angles to be used in the addition in Fourier Space.')), Assign(targets=[Name(id='bits_little_endian', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=BinOp(left=Name(id='angles', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
FunctionDef(name='_phi_add_gate', args=arguments(args=[arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Gate that performs addition by a in Fourier Space.')), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])], keywords=[keyword(arg='name', value=Str(s='phi_add_a'))])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='angle', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='Gate', ctx=Load()))
FunctionDef(name='_double_controlled_phi_add_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Creates a circuit which implements double-controlled modular addition by a.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=2), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))])), Assign(targets=[Name(id='cc_phi_add_a', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load()), args=[Num(n=2)], keywords=[])), Assign(targets=[Name(id='cc_iphi_add_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iphi_add_N', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c_phi_add_N', ctx=Load()), List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_iphi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='_controlled_multiple_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular multiplication by a as an instruction.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='x_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load()), Str(s='x')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='x_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='cmult_a_mod_N'))])), Assign(targets=[Name(id='angle_params', ctx=Store())], value=Call(func=Name(id='ParameterVector', ctx=Load()), args=[Str(s='angles')], keywords=[keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))])), Assign(targets=[Name(id='modulo_adder', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load()), args=[Name(id='angle_params', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), FunctionDef(name='append_adder', args=arguments(args=[arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='constant', annotation=Name(id='int', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='partial_constant', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load()))), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=None), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_inv', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())]), body=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))]), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='modulo_adder_inv', ctx=Store())], value=Call(func=Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load()))
FunctionDef(name='_power_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular exponentiation a^x as an instruction.')), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))])), Assign(targets=[Name(id='qft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])), Assign(targets=[Name(id='iphi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='c_phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load()), args=[Num(n=1)], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]), body=[Assign(targets=[Name(id='partial_a', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_multiplier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load()))
FunctionDef(name='_validate_input', args=arguments(args=[arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check parameters of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Raises:\n            ValueError: Invalid input\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='N'), Name(id='N', ctx=Load()), Num(n=3)], keywords=[])), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='a'), Name(id='a', ctx=Load()), Num(n=2)], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[]), cause=None)], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=None)
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct quantum part of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            Quantum circuit.\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_power', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='up_qreg', ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='up_cqreg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='modinv', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='m', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the modular multiplicative inverse of a with respect to the modulus m.')), FunctionDef(name='egcd', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='x', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='g', ctx=Load()), ops=[NotEq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[]), cause=None)], orelse=[]), Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='m', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='_get_factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Apply the continued fractions to find r and the gcd to find the desired factors.')), Assign(targets=[Name(id='x_final', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='measurement', ctx=Load()), Num(n=2)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='In decimal, x_final value for this result is: %s.'), Name(id='x_final', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='x_final', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='x_final value is <= 0, there are no continued fractions.'))], orelse=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=NameConstant(value=None)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[]))]), Assign(targets=[Name(id='T_upper', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='T_upper', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Name(id='x_final', ctx=Load()), op=Div(), right=Name(id='T', ctx=Load()))), Assign(targets=[Name(id='i', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='i')], keywords=[])), Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='f')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[])), Assign(targets=[Name(id='exponential', ctx=Store())], value=Num(n=0.0)), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='denominator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Num(n=1)), If(test=Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])), Continue()], orelse=[]), If(test=Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)]), body=[Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))], orelse=[Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cannot find factors from measurement %s because %s'), Name(id='measurement', ctx=Load()), BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])], keywords=[])), Return(value=NameConstant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='_calculate_continued_fraction', args=arguments(args=[arg(arg='b', annotation=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculate the continued fraction of x/T from the current terms of expansion b.')), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=Num(n=0)), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))))], orelse=[]), AugAssign(target=Name(id='x_over_T', ctx=Store()), op=Add(), value=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='frac', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Approximation number %s of continued fractions:'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Numerator:%s \t\t Denominator: %s.'), Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load()), Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='factor', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2)]), body=[Expr(value=Str(s='Execute the algorithm.\n\n        The input integer :math:`N` to be factored is expected to be odd and greater than 2.\n        Even though this implementation is general, its capability will be limited by the\n        capacity of the simulator/hardware. Another input integer :math:`a`  can also be supplied,\n        which needs to be a co-prime smaller than :math:`N` .\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Returns:\n            ShorResult: results of the algorithm.\n\n        Raises:\n            ValueError: Invalid input\n            AlgorithmError: If a quantum instance or backend has not been provided\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='ShorResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='tf', ctx=Store()), Name(id='b', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())], value=Call(func=Name(id='is_power', ctx=Load()), args=[Name(id='N', ctx=Load())], keywords=[keyword(arg='return_decomposition', value=NameConstant(value=True))])), If(test=Name(id='tf', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])), For(target=Name(id='measurement', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='ShorResult'))
Name(id='AlgorithmResult', ctx=Load())
Expr(value=Str(s='Shor Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Num(n=0))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns factors')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set factors')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='factors', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns total counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set total counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='total_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns successful counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set successful counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='successful_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
Store()
Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load())
Name(id='__name__', ctx=Load())
Str(s="Shor's factoring algorithm.\n\n    Shor's Factoring algorithm is one of the most well-known quantum algorithms and finds the\n    prime factors for input integer :math:`N` in polynomial time.\n\n    Adapted from https://github.com/ttlion/ShorAlgQiskit\n\n    See also https://arxiv.org/abs/quant-ph/0205095\n    ")
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='\n        Args:\n            quantum_instance: Quantum Instance or Backend\n\n        '))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None))
If(test=Name(id='quantum_instance', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns quantum instance.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets quantum instance.'))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='n', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Calculates the array of angles to be used in the addition in Fourier Space.'))
Assign(targets=[Name(id='bits_little_endian', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])], orelse=[])
Return(value=BinOp(left=Name(id='angles', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Name(id='staticmethod', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
arguments(args=[arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Gate that performs addition by a in Fourier Space.'))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])], keywords=[keyword(arg='name', value=Str(s='phi_add_a'))]))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='angle', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[])
Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load()), args=[], keywords=[]))
Name(id='staticmethod', ctx=Load())
Name(id='Gate', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Creates a circuit which implements double-controlled modular addition by a.'))
Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=2), Str(s='ctrl')], keywords=[]))
Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), Str(s='b')], keywords=[]))
Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))]))
Assign(targets=[Name(id='cc_phi_add_a', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load()), args=[Num(n=2)], keywords=[]))
Assign(targets=[Name(id='cc_iphi_add_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iphi_add_N', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c_phi_add_N', ctx=Load()), List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_iphi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Return(value=Name(id='circuit', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Implements modular multiplication by a as an instruction.'))
Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='ctrl')], keywords=[]))
Assign(targets=[Name(id='x_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load()), Str(s='x')], keywords=[]))
Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)), Str(s='b')], keywords=[]))
Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='x_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='cmult_a_mod_N'))]))
Assign(targets=[Name(id='angle_params', ctx=Store())], value=Call(func=Name(id='ParameterVector', ctx=Load()), args=[Str(s='angles')], keywords=[keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))]))
Assign(targets=[Name(id='modulo_adder', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load()), args=[Name(id='angle_params', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[]))
FunctionDef(name='append_adder', args=arguments(args=[arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='constant', annotation=Name(id='int', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='partial_constant', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load()))), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=None)
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='a_inv', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())]), body=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))]), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='modulo_adder_inv', ctx=Store())], value=Call(func=Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))
Name(id='Instruction', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Implements modular exponentiation a^x as an instruction.'))
Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))]))
Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))]))
Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))]))
Assign(targets=[Name(id='qft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]))
Assign(targets=[Name(id='iphi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='c_phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load()), args=[Num(n=1)], keywords=[]))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]), body=[Assign(targets=[Name(id='partial_a', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_multiplier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])
Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))
Name(id='Instruction', ctx=Load())
arguments(args=[arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Check parameters of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Raises:\n            ValueError: Invalid input\n\n        '))
Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='N'), Name(id='N', ctx=Load()), Num(n=3)], keywords=[]))
Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='a'), Name(id='a', ctx=Load()), Num(n=2)], keywords=[]))
If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[]), cause=None)], orelse=[])
If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[]), cause=None)], orelse=[])
Name(id='staticmethod', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2), NameConstant(value=False)])
Expr(value=Str(s='Construct quantum part of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            Quantum circuit.\n\n        '))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))]))
Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))]))
Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Assign(targets=[Name(id='modulo_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_power', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='up_qreg', ctx=Load())], keywords=[]))
If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='up_cqreg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]))
Return(value=Name(id='circuit', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='m', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the modular multiplicative inverse of a with respect to the modulus m.'))
FunctionDef(name='egcd', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()))
Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='x', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='g', ctx=Load()), ops=[NotEq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[]), cause=None)], orelse=[])
Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='m', ctx=Load())))
Name(id='staticmethod', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Apply the continued fractions to find r and the gcd to find the desired factors.'))
Assign(targets=[Name(id='x_final', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='measurement', ctx=Load()), Num(n=2)], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='In decimal, x_final value for this result is: %s.'), Name(id='x_final', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='x_final', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='x_final value is <= 0, there are no continued fractions.'))], orelse=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=NameConstant(value=None)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[]))])
Assign(targets=[Name(id='T_upper', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='measurement', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='T_upper', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Name(id='x_final', ctx=Load()), op=Div(), right=Name(id='T', ctx=Load())))
Assign(targets=[Name(id='i', ctx=Store())], value=Num(n=0))
Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='i')], keywords=[]))
Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='f')], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))
Assign(targets=[Name(id='exponential', ctx=Store())], value=Num(n=0.0))
While(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='denominator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Num(n=1)), If(test=Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])), Continue()], orelse=[]), If(test=Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)]), body=[Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))], orelse=[Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])])], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cannot find factors from measurement %s because %s'), Name(id='measurement', ctx=Load()), BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])], keywords=[]))
Return(value=NameConstant(value=None))
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='b', annotation=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Calculate the continued fraction of x/T from the current terms of expansion b.'))
Assign(targets=[Name(id='x_over_T', ctx=Store())], value=Num(n=0))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))))], orelse=[])
AugAssign(target=Name(id='x_over_T', ctx=Store()), op=Add(), value=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='frac', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Approximation number %s of continued fractions:'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Numerator:%s \t\t Denominator: %s.'), Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load()), Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())], keywords=[]))
Return(value=Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load()))
Name(id='staticmethod', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2)])
Expr(value=Str(s='Execute the algorithm.\n\n        The input integer :math:`N` to be factored is expected to be odd and greater than 2.\n        Even though this implementation is general, its capability will be limited by the\n        capacity of the simulator/hardware. Another input integer :math:`a`  can also be supplied,\n        which needs to be a co-prime smaller than :math:`N` .\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Returns:\n            ShorResult: results of the algorithm.\n\n        Raises:\n            ValueError: Invalid input\n            AlgorithmError: If a quantum instance or backend has not been provided\n\n        '))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='ShorResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Tuple(elts=[Name(id='tf', ctx=Store()), Name(id='b', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())], value=Call(func=Name(id='is_power', ctx=Load()), args=[Name(id='N', ctx=Load())], keywords=[keyword(arg='return_decomposition', value=NameConstant(value=True))]))
If(test=Name(id='tf', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))], orelse=[])
If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])), For(target=Name(id='measurement', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])
Return(value=Name(id='result', ctx=Load()))
Str(s='ShorResult')
Load()
Str(s='Shor Result.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Num(n=0))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Num(n=0))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='returns factors'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='set factors'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='factors', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='returns total counts'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='set total counts'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='total_counts', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='returns successful counts'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='set successful counts'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='successful_counts', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
Name(id='logging', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='\n        Args:\n            quantum_instance: Quantum Instance or Backend\n\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
NameConstant(value=None)
Name(id='quantum_instance', ctx=Load())
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
arg(arg='self', annotation=None)
Str(s='Returns quantum instance.')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Sets quantum instance.')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='n', annotation=Name(id='int', ctx=Load()))
Str(s='Calculates the array of angles to be used in the addition in Fourier Space.')
Name(id='bits_little_endian', ctx=Store())
Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Name(id='angles', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])
BinOp(left=Name(id='angles', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Gate that performs addition by a in Fourier Space.')
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])], keywords=[keyword(arg='name', value=Str(s='phi_add_a'))])
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='angle', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load()), args=[], keywords=[])
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load()))
arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load()))
arg(arg='qft', annotation=Name(id='Gate', ctx=Load()))
arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))
Str(s='Creates a circuit which implements double-controlled modular addition by a.')
Name(id='ctrl_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=2), Str(s='ctrl')], keywords=[])
Name(id='b_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), Str(s='b')], keywords=[])
Name(id='flag_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))])
Name(id='cc_phi_add_a', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load()), args=[Num(n=2)], keywords=[])
Name(id='cc_iphi_add_a', ctx=Store())
Call(func=Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iphi_add_N', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c_phi_add_N', ctx=Load()), List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_iphi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Name(id='circuit', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='n', annotation=Name(id='int', ctx=Load()))
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load()))
arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load()))
arg(arg='qft', annotation=Name(id='Gate', ctx=Load()))
arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))
Str(s='Implements modular multiplication by a as an instruction.')
Name(id='ctrl_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='ctrl')], keywords=[])
Name(id='x_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load()), Str(s='x')], keywords=[])
Name(id='b_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)), Str(s='b')], keywords=[])
Name(id='flag_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='x_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='cmult_a_mod_N'))])
Name(id='angle_params', ctx=Store())
Call(func=Name(id='ParameterVector', ctx=Load()), args=[Str(s='angles')], keywords=[keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))])
Name(id='modulo_adder', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load()), args=[Name(id='angle_params', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])
arguments(args=[arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='constant', annotation=Name(id='int', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='partial_constant', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load())))
Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]))
Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Name(id='a_inv', ctx=Store())
IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())]), body=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))]), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))
Name(id='modulo_adder_inv', ctx=Store())
Call(func=Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
Name(id='i', ctx=Store())
Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], keywords=[])
Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[])
Load()
arg(arg='self', annotation=None)
arg(arg='n', annotation=Name(id='int', ctx=Load()))
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
Str(s='Implements modular exponentiation a^x as an instruction.')
Name(id='up_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])
Name(id='down_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])
Name(id='aux_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))])
Name(id='qft', ctx=Store())
Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load()), args=[], keywords=[])
Name(id='iqft', ctx=Store())
Call(func=Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
Name(id='phi_add_N', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])
Name(id='iphi_add_N', ctx=Store())
Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
Name(id='c_phi_add_N', ctx=Store())
Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load()), args=[Num(n=1)], keywords=[])
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])
Assign(targets=[Name(id='partial_a', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='modulo_multiplier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[])
Load()
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
Str(s='Check parameters of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Raises:\n            ValueError: Invalid input\n\n        ')
Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='N'), Name(id='N', ctx=Load()), Num(n=3)], keywords=[])
Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='a'), Name(id='a', ctx=Load()), Num(n=2)], keywords=[])
BoolOp(op=Or(), values=[Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[]), cause=None)
BoolOp(op=Or(), values=[Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[]), cause=None)
Load()
arg(arg='self', annotation=None)
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))
Num(n=2)
NameConstant(value=False)
Str(s='Construct quantum part of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            Quantum circuit.\n\n        ')
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])
Name(id='n', ctx=Store())
Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])
Name(id='up_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])
Name(id='down_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])
Name(id='aux_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='modulo_power', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_power', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])
Name(id='iqft', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='up_qreg', ctx=Load())], keywords=[])
Name(id='measurement', ctx=Load())
Assign(targets=[Name(id='up_cqreg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[])
Name(id='circuit', ctx=Load())
Load()
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='m', annotation=Name(id='int', ctx=Load()))
Str(s='Returns the modular multiplicative inverse of a with respect to the modulus m.')
arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))])
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Tuple(elts=[Name(id='g', ctx=Store()), Name(id='x', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())
Call(func=Name(id='egcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load())], keywords=[])
Compare(left=Name(id='g', ctx=Load()), ops=[NotEq()], comparators=[Num(n=1)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[]), cause=None)
BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='m', ctx=Load()))
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='measurement', annotation=Name(id='str', ctx=Load()))
Str(s='Apply the continued fractions to find r and the gcd to find the desired factors.')
Name(id='x_final', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Name(id='measurement', ctx=Load()), Num(n=2)], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='In decimal, x_final value for this result is: %s.'), Name(id='x_final', ctx=Load())], keywords=[])
Compare(left=Name(id='x_final', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)])
Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='x_final value is <= 0, there are no continued fractions.'))
Assign(targets=[Name(id='fail_reason', ctx=Store())], value=NameConstant(value=None))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[]))
Name(id='T_upper', ctx=Store())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='measurement', ctx=Load())], keywords=[])
Name(id='T', ctx=Store())
Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='T_upper', ctx=Load())], keywords=[])
Name(id='x_over_T', ctx=Store())
BinOp(left=Name(id='x_final', ctx=Load()), op=Div(), right=Name(id='T', ctx=Load()))
Name(id='i', ctx=Store())
Num(n=0)
Name(id='b', ctx=Store())
Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='i')], keywords=[])
Name(id='t', ctx=Store())
Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='f')], keywords=[])
Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[])
Name(id='exponential', ctx=Store())
Num(n=0.0)
BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))], orelse=[])
Assign(targets=[Name(id='denominator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))
AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Num(n=1))
If(test=Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])), Continue()], orelse=[])
If(test=Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)]), body=[Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))], orelse=[])
If(test=Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))], orelse=[Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cannot find factors from measurement %s because %s'), Name(id='measurement', ctx=Load()), BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])], keywords=[])
NameConstant(value=None)
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Load()
arg(arg='b', annotation=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()))
Str(s='Calculate the continued fraction of x/T from the current terms of expansion b.')
Name(id='x_over_T', ctx=Store())
Num(n=0)
Name(id='i', ctx=Store())
Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])], keywords=[])
Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))))
Name(id='x_over_T', ctx=Store())
Add()
Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='frac', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Approximation number %s of continued fractions:'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Numerator:%s \t\t Denominator: %s.'), Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load()), Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())], keywords=[])
Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
Num(n=2)
Str(s='Execute the algorithm.\n\n        The input integer :math:`N` to be factored is expected to be odd and greater than 2.\n        Even though this implementation is general, its capability will be limited by the\n        capacity of the simulator/hardware. Another input integer :math:`a`  can also be supplied,\n        which needs to be a co-prime smaller than :math:`N` .\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Returns:\n            ShorResult: results of the algorithm.\n\n        Raises:\n            ValueError: Invalid input\n            AlgorithmError: If a quantum instance or backend has not been provided\n\n        ')
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)
Name(id='result', ctx=Store())
Call(func=Name(id='ShorResult', ctx=Load()), args=[], keywords=[])
Tuple(elts=[Name(id='tf', ctx=Store()), Name(id='b', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())
Call(func=Name(id='is_power', ctx=Load()), args=[Name(id='N', ctx=Load())], keywords=[keyword(arg='return_decomposition', value=NameConstant(value=True))])
Name(id='tf', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))
UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[]))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))])
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[]))
For(target=Name(id='measurement', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])
Name(id='result', ctx=Load())
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())
Num(n=0)
Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())
Num(n=0)
arg(arg='self', annotation=None)
Str(s='returns factors')
Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='set factors')
Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())
Name(id='value', ctx=Load())
Name(id='factors', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='returns total counts')
Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='int', ctx=Load()))
Str(s='set total counts')
Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())
Name(id='value', ctx=Load())
Name(id='total_counts', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='returns successful counts')
Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='int', ctx=Load()))
Str(s='set successful counts')
Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())
Name(id='value', ctx=Load())
Name(id='successful_counts', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Store()
Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load())
Name(id='n', ctx=Load())
Store()
Name(id='range', ctx=Load())
Name(id='n', ctx=Load())
Name(id='j', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load())))
If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])
Name(id='angles', ctx=Load())
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())
Store()
Name(id='QuantumCircuit', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])
keyword(arg='name', value=Str(s='phi_add_a'))
Name(id='i', ctx=Store())
Name(id='angle', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='angles', ctx=Load())
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
Num(n=2)
Str(s='ctrl')
Store()
Name(id='QuantumRegister', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])
Str(s='b')
Store()
Name(id='QuantumRegister', ctx=Load())
Num(n=1)
Str(s='flag')
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='ctrl_qreg', ctx=Load())
Name(id='b_qreg', ctx=Load())
Name(id='flag_qreg', ctx=Load())
keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))
Store()
Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load())
Num(n=2)
Store()
Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='cc_phi_add_a', ctx=Load())
List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iphi_add_N', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iqft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load())
Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='c_phi_add_N', ctx=Load())
List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='cc_iphi_add_a', ctx=Load())
List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iqft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load())
Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load())
Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load())
Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='cc_phi_add_a', ctx=Load())
List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
Num(n=1)
Str(s='ctrl')
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='n', ctx=Load())
Str(s='x')
Store()
Name(id='QuantumRegister', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))
Str(s='b')
Store()
Name(id='QuantumRegister', ctx=Load())
Num(n=1)
Str(s='flag')
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='ctrl_qreg', ctx=Load())
Name(id='x_qreg', ctx=Load())
Name(id='b_qreg', ctx=Load())
Name(id='flag_qreg', ctx=Load())
keyword(arg='name', value=Str(s='cmult_a_mod_N'))
Store()
Name(id='ParameterVector', ctx=Load())
Str(s='angles')
keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load())
Name(id='angle_params', ctx=Load())
Name(id='c_phi_add_N', ctx=Load())
Name(id='iphi_add_N', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='iqft', ctx=Load())
arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='constant', annotation=Name(id='int', ctx=Load()))
arg(arg='idx', annotation=Name(id='int', ctx=Load()))
Name(id='partial_constant', ctx=Store())
BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load()))
Name(id='angles', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Name(id='bound', ctx=Store())
Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Store()
Name(id='range', ctx=Load())
Name(id='n', ctx=Load())
Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iqft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Store()
Name(id='range', ctx=Load())
Name(id='n', ctx=Load())
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Store()
Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())])
Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))])
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load())
Store()
Name(id='reversed', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iqft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
keyword(arg='name', value=Str(s='up'))
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='n', ctx=Load())
keyword(arg='name', value=Str(s='down'))
Store()
Name(id='QuantumRegister', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))
keyword(arg='name', value=Str(s='aux'))
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='up_qreg', ctx=Load())
Name(id='down_qreg', ctx=Load())
Name(id='aux_qreg', ctx=Load())
keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))
Store()
Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load())
Store()
Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Store()
Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load())
Store()
Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load())
Num(n=1)
Store()
Name(id='range', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
Name(id='partial_a', ctx=Store())
Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[])
Name(id='modulo_multiplier', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='validate_min', ctx=Load())
Str(s='N')
Name(id='N', ctx=Load())
Num(n=3)
Name(id='validate_min', ctx=Load())
Str(s='a')
Name(id='a', ctx=Load())
Num(n=2)
Or()
Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)])
Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[])
Or()
Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())])
Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[])
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='bool', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load())
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Store()
Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
keyword(arg='name', value=Str(s='up'))
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='n', ctx=Load())
keyword(arg='name', value=Str(s='down'))
Store()
Name(id='QuantumRegister', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))
keyword(arg='name', value=Str(s='aux'))
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='up_qreg', ctx=Load())
Name(id='down_qreg', ctx=Load())
Name(id='aux_qreg', ctx=Load())
keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))
Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load())
Name(id='up_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load())
Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load())
Name(id='n', ctx=Load())
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='modulo_power', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iqft', ctx=Load())
Name(id='up_qreg', ctx=Load())
Load()
Name(id='up_cqreg', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[])
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='b', annotation=Name(id='int', ctx=Load()))
Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))
Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[]))
Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='g', ctx=Store())
Name(id='x', ctx=Store())
Name(id='_', ctx=Store())
Store()
Name(id='egcd', ctx=Load())
Name(id='a', ctx=Load())
Name(id='m', ctx=Load())
Name(id='g', ctx=Load())
NotEq()
Num(n=1)
Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[])
Name(id='x', ctx=Load())
Mod()
Name(id='m', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='str', ctx=Load())
Store()
Name(id='int', ctx=Load())
Name(id='measurement', ctx=Load())
Num(n=2)
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='In decimal, x_final value for this result is: %s.')
Name(id='x_final', ctx=Load())
Name(id='x_final', ctx=Load())
LtE()
Num(n=0)
Name(id='fail_reason', ctx=Store())
Str(s='x_final value is <= 0, there are no continued fractions.')
Name(id='fail_reason', ctx=Store())
NameConstant(value=None)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[])
Store()
Name(id='len', ctx=Load())
Name(id='measurement', ctx=Load())
Store()
Name(id='pow', ctx=Load())
Num(n=2)
Name(id='T_upper', ctx=Load())
Store()
Name(id='x_final', ctx=Load())
Div()
Name(id='T', ctx=Load())
Store()
Store()
Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load())
Str(s='i')
Store()
Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load())
Str(s='f')
Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])
Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load())
BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Store()
And()
Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())])
Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))
Name(id='denominator', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])
Name(id='i', ctx=Store())
Add()
Num(n=1)
Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[]))
Continue()
Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)])
Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))
Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)])
Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))
Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]))
Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))
Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Cannot find factors from measurement %s because %s')
Name(id='measurement', ctx=Load())
BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load())
Store()
Store()
Name(id='reversed', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])
Name(id='x_over_T', ctx=Store())
BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load())))
Store()
Name(id='b', ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Approximation number %s of continued fractions:')
Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Numerator:%s \t\t Denominator: %s.')
Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load())
Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())
Name(id='frac', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load())
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[])
Store()
Name(id='ShorResult', ctx=Load())
Name(id='tf', ctx=Store())
Name(id='b', ctx=Store())
Name(id='p', ctx=Store())
Store()
Name(id='is_power', ctx=Load())
Name(id='N', ctx=Load())
keyword(arg='return_decomposition', value=NameConstant(value=True))
Load()
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])
Not()
Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[]))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[]))
Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[]))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))]))
Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])
Name(id='measurement', ctx=Store())
Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[]))
If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])
Load()
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load())
Name(id='n', ctx=Load())
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='range', ctx=Load())
BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))
Name(id='k', ctx=Store())
BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))
Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')])
AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='len', ctx=Load())
Name(id='angles', ctx=Load())
Str(s='phi_add_a')
Store()
Store()
Load()
Load()
Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load())
Name(id='angle', ctx=Load())
Name(id='i', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='len', ctx=Load())
Name(id='angles', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Str(s='ccphi_add_a_mod_N')
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])
Load()
Name(id='cc_phi_add_a', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='flag_qreg', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='flag_qreg', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='n', ctx=Load())
Add()
Num(n=1)
Load()
Load()
Load()
Load()
Load()
Load()
Str(s='cmult_a_mod_N')
Load()
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Store()
BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load()))
Mod()
Name(id='N', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load())
Name(id='partial_constant', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))
Store()
Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load())
Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='bound', ctx=Load())
List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='append_adder', ctx=Load())
Name(id='modulo_adder', ctx=Load())
Name(id='a', ctx=Load())
Name(id='i', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load())
Name(id='ctrl_qreg', ctx=Load())
Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load())
GtE()
Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())
Name(id='pow', ctx=Load())
Name(id='a', ctx=Load())
UnaryOp(op=USub(), operand=Num(n=1))
keyword(arg='mod', value=Name(id='N', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load())
Name(id='a', ctx=Load())
Name(id='N', ctx=Load())
Name(id='modulo_adder', ctx=Load())
Load()
Load()
Name(id='range', ctx=Load())
Name(id='n', ctx=Load())
Name(id='append_adder', ctx=Load())
Name(id='modulo_adder_inv', ctx=Load())
Name(id='a_inv', ctx=Load())
Name(id='i', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
Str(s='up')
Load()
Load()
Str(s='down')
Load()
Name(id='n', ctx=Load())
Add()
Num(n=2)
Str(s='aux')
Load()
Load()
Load()
Load()
JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)])
Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))])
Load()
Name(id='qft', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load())
Name(id='N', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))
Name(id='phi_add_N', ctx=Load())
Load()
Name(id='phi_add_N', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
Store()
Name(id='pow', ctx=Load())
Name(id='a', ctx=Load())
Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[])
Name(id='N', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load())
Name(id='n', ctx=Load())
Name(id='N', ctx=Load())
Name(id='partial_a', ctx=Load())
Name(id='c_phi_add_N', ctx=Load())
Name(id='iphi_add_N', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='iqft', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='modulo_multiplier', ctx=Load())
List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='N', ctx=Load())
Lt()
Num(n=1)
BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2))
Eq()
Num(n=0)
Name(id='ValueError', ctx=Load())
Str(s='The input needs to be an odd integer greater than 1.')
Name(id='a', ctx=Load())
GtE()
Name(id='N', ctx=Load())
Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])
NotEq()
Num(n=1)
Name(id='ValueError', ctx=Load())
Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='N', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
Str(s='up')
Load()
Load()
Str(s='down')
Load()
Name(id='n', ctx=Load())
Add()
Num(n=2)
Str(s='aux')
Load()
Load()
Load()
Load()
JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')])
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='down_qreg', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[])
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='ClassicalRegister', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
keyword(arg='name', value=Str(s='m'))
Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load())
Name(id='up_cqreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load())
Name(id='up_qreg', ctx=Load())
Name(id='up_cqreg', ctx=Load())
Name(id='logger', ctx=Load())
Load()
Name(id='summarize_circuits', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='a', ctx=Load())
Eq()
Num(n=0)
Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load())
Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())
Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])
Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Store()
Store()
Store()
Load()
Load()
Load()
Load()
Name(id='ValueError', ctx=Load())
Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Store()
Store()
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Running continued fractions for this case.')
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='array', ctx=Load())
Load()
Name(id='array', ctx=Load())
Load()
Name(id='b', ctx=Load())
Load()
Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load())
Name(id='x_over_T', ctx=Load())
Name(id='t', ctx=Load())
Load()
Name(id='x_over_T', ctx=Load())
Sub()
Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Name(id='i', ctx=Load())
Lt()
Name(id='N', ctx=Load())
Name(id='fail_reason', ctx=Load())
Is()
NameConstant(value=None)
Name(id='i', ctx=Load())
Gt()
Num(n=0)
Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load())
Name(id='b', ctx=Load())
Store()
BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2))
Eq()
Num(n=1)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])
Name(id='denominator', ctx=Load())
Lt()
Num(n=1000)
Name(id='exponential', ctx=Store())
Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[])
Name(id='exponential', ctx=Load())
Gt()
Num(n=1000000000)
Name(id='fail_reason', ctx=Store())
Str(s='denominator of continued fraction is too big.')
Name(id='putting_plus', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Name(id='putting_minus', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Name(id='one_factor', ctx=Store())
Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])
Name(id='other_factor', ctx=Store())
Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])
Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[]))
If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])
Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))
Name(id='logger', ctx=Load())
Load()
Load()
Or()
Name(id='fail_reason', ctx=Load())
Str(s='it took too many attempts.')
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='array', ctx=Load())
Load()
Load()
Name(id='range', ctx=Load())
BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))
Store()
Num(n=1)
Div()
BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))
Load()
Num(n=0)
Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='b', ctx=Load())
Name(id='logger', ctx=Load())
Load()
Name(id='frac', ctx=Load())
Load()
Name(id='frac', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')
Load()
Store()
Store()
Store()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='The input integer is a power: %s=%s^%s.')
Name(id='N', ctx=Load())
Name(id='b', ctx=Load())
Name(id='p', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load())
Name(id='b', ctx=Load())
Name(id='result', ctx=Load())
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Running with N=%s and a=%s.')
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='n', ctx=Store())
Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])
Name(id='circuit', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])
Name(id='result', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
  Found a method call call at line 450
Name(id='complete_state_vec', ctx=Store())
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='up_qreg_density_mat', ctx=Store())
Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])
Name(id='up_qreg_density_mat_diag', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])
Name(id='counts', ctx=Store())
Dict(keys=[], values=[])
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[])
If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])
Name(id='circuit', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])
Name(id='counts', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='result', ctx=Load())
Store()
Name(id='len', ctx=Load())
Name(id='counts', ctx=Load())
Store()
Name(id='list', ctx=Load())
Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])
Name(id='factors', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])
Name(id='factors', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1)))
If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())
Load()
Load()
USub()
Num(n=1)
Load()
Load()
Name(id='i', ctx=Load())
Add()
Num(n=1)
Store()
Name(id='i', ctx=Load())
Sub()
Name(id='j', ctx=Load())
Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load())
Eq()
Str(s='1')
Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())
Add()
Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[])
Load()
Load()
Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load())
Name(id='angles', ctx=Load())
Load()
Load()
Name(id='ctrl_qreg', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Load()
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Num(n=0)
Load()
Load()
Name(id='flag_qreg', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Load()
Load()
Name(id='ctrl_qreg', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Num(n=0)
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Load()
Name(id='ctrl_qreg', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Load()
Load()
Name(id='n', ctx=Load())
Add()
Num(n=1)
Load()
Load()
Load()
Load()
Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])
Mult()
Name(id='constant', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='n', ctx=Load())
Add()
Num(n=1)
Name(id='adder', ctx=Load())
Load()
Name(id='angle_params', ctx=Load())
Name(id='angles', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load())
Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load())
Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='x_qreg', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='b_qreg', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Load()
Name(id='sys', ctx=Load())
Load()
Num(n=3)
Num(n=8)
Load()
Load()
Load()
USub()
Num(n=1)
Name(id='N', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None)
Str(s='^x mod ')
FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)
Name(id='QFT', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))
keyword(arg='do_swaps', value=NameConstant(value=False))
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='n', ctx=Load())
Add()
Num(n=1)
Load()
Load()
Load()
Load()
Load()
Name(id='pow', ctx=Load())
Num(n=2)
Name(id='i', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())
Load()
Load()
Load()
Name(id='N', ctx=Load())
Mod()
Num(n=2)
Load()
Load()
Load()
Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load())
Name(id='a', ctx=Load())
Name(id='N', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Str(s='Shor(N=')
FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)
Str(s=', a=')
FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None)
Str(s=')')
Load()
Load()
Load()
Num(n=0)
Load()
Load()
Load()
Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
Str(s='m')
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='b', ctx=Load())
Num(n=0)
Num(n=1)
Load()
Name(id='g', ctx=Store())
Name(id='y', ctx=Store())
Name(id='x', ctx=Store())
Store()
Name(id='egcd', ctx=Load())
BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load()))
Name(id='a', ctx=Load())
Name(id='g', ctx=Load())
BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load())))
Name(id='y', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Load()
Load()
Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load())
Name(id='a', ctx=Load())
Name(id='m', ctx=Load())
Name(id='g', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='math', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='b', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])
Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load())
BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Name(id='self', ctx=Load())
Load()
Load()
Name(id='denominator', ctx=Load())
Mod()
Num(n=2)
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Odd denominator, will try next iteration of continued fractions.')
Load()
Store()
Name(id='pow', ctx=Load())
Name(id='a', ctx=Load())
BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))
Load()
Store()
Store()
Name(id='int', ctx=Load())
BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))
Store()
Name(id='int', ctx=Load())
BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))
Store()
Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load())
Name(id='putting_plus', ctx=Load())
Name(id='N', ctx=Load())
Store()
Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load())
Name(id='putting_minus', ctx=Load())
Name(id='N', ctx=Load())
Name(id='any', ctx=Load())
GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])
Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))
Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[])
Load()
Load()
Load()
Name(id='int', ctx=Load())
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])
Sub()
Num(n=1)
Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load())
Add()
Name(id='x_over_T', ctx=Load())
Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load())
Name(id='x_over_T', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
keyword(arg='N', value=Name(id='N', ctx=Load()))
keyword(arg='a', value=Name(id='a', ctx=Load()))
keyword(arg='measurement', value=NameConstant(value=False))
Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load())
Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Name(id='partial_trace', ctx=Load())
Name(id='complete_state_vec', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load())
Name(id='up_qreg_density_mat', ctx=Load())
Store()
Name(id='i', ctx=Store())
Name(id='v', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='up_qreg_density_mat_diag', ctx=Load())
UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]))
Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
keyword(arg='N', value=Name(id='N', ctx=Load()))
keyword(arg='a', value=Name(id='a', ctx=Load()))
keyword(arg='measurement', value=NameConstant(value=True))
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='------> Analyzing result %s.')
Name(id='measurement', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load())
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Name(id='measurement', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())
BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))
Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())])
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))
Name(id='super', ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])
Slice(lower=Num(n=2), upper=None, step=None)
Load()
Load()
Load()
Load()
Name(id='bits_little_endian', ctx=Load())
Index(value=Name(id='j', ctx=Load()))
Load()
Name(id='angles', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Store()
Name(id='pow', ctx=Load())
Num(n=2)
UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='ParameterVector', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='ParameterVector', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
USub()
Num(n=1)
Load()
Load()
Load()
Load()
USub()
Num(n=1)
USub()
Num(n=1)
USub()
Num(n=1)
Load()
Load()
Load()
Name(id='pow', ctx=Load())
Num(n=2)
Name(id='idx', ctx=Load())
Name(id='N', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='ctrl_qreg', ctx=Load())
Load()
Name(id='x_qreg', ctx=Load())
Index(value=Name(id='idx', ctx=Load()))
Load()
Name(id='b_qreg', ctx=Load())
Load()
Name(id='flag_qreg', ctx=Load())
Load()
Load()
Load()
Name(id='i', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
Load()
Load()
Name(id='a', ctx=Load())
Name(id='N', ctx=Load())
Load()
Name(id='n', ctx=Load())
Add()
Num(n=1)
NameConstant(value=False)
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='up_qreg', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='down_qreg', ctx=Load())
Load()
Name(id='aux_qreg', ctx=Load())
Load()
Load()
Name(id='math', ctx=Load())
Load()
Load()
Load()
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[])
Load()
Load()
Load()
Load()
Load()
Store()
Store()
Store()
Load()
Name(id='b', ctx=Load())
Mod()
Name(id='a', ctx=Load())
Load()
Load()
Name(id='x', ctx=Load())
Sub()
BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))
Load()
Load()
Load()
Load()
Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.')
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Name(id='b', ctx=Load())
Load()
Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load())
BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))
Name(id='t', ctx=Load())
Load()
BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))
Sub()
Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Name(id='denominator', ctx=Load())
Div()
Num(n=2)
Load()
Name(id='exponential', ctx=Load())
Add()
Num(n=1)
Load()
Name(id='exponential', ctx=Load())
Sub()
Num(n=1)
Name(id='math', ctx=Load())
Load()
Load()
Load()
Name(id='math', ctx=Load())
Load()
Load()
Load()
Load()
Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])])
comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Found just trivial factors, not good enough.')
Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())
Eq()
Num(n=0)
Name(id='fail_reason', ctx=Store())
Str(s='the continued fractions found exactly x_final/(2^(2n)).')
Name(id='sorted', ctx=Load())
Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='b', ctx=Load())
Name(id='b', ctx=Load())
Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))
Load()
Load()
Name(id='fractions', ctx=Load())
Load()
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Name(id='N', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
NameConstant(value=False)
Name(id='logger', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='range', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))
Name(id='np', ctx=Load())
Load()
Load()
Store()
Store()
Load()
Load()
Not()
Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())
BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2))
Name(id='self', ctx=Load())
Load()
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
NameConstant(value=True)
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
  Found a method call call at line 462
Load()
Load()
Name(id='counts', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Found factors %s from measurement %s.')
Name(id='factors', ctx=Load())
Name(id='measurement', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load())
Add()
Num(n=1)
Name(id='factors', ctx=Load())
NotIn()
Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[])
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='bin', ctx=Load())
Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])
Num(n=2)
Load()
Name(id='j', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
USub()
Name(id='k', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='idx', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='QFT', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])
Load()
Load()
Load()
BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load()))
Mult()
Name(id='y', ctx=Load())
Load()
Load()
Name(id='math', ctx=Load())
Load()
Num(n=1)
Div()
Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())
Load()
Num(n=1)
Div()
Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())
Name(id='b', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='factor', ctx=Load())
In()
Set(elts=[Num(n=1), Name(id='N', ctx=Load())])
Name(id='factor', ctx=Store())
Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())
Name(id='logger', ctx=Load())
Load()
Name(id='t', ctx=Load())
Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1)))
Load()
Store()
Load()
Name(id='one_factor', ctx=Load())
Name(id='other_factor', ctx=Load())
Load()
Load()
Load()
Load()
BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load()))
Add()
Num(n=2)
Load()
Name(id='v', ctx=Load())
Eq()
Num(n=0)
Name(id='counts', ctx=Load())
Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]))
Store()
Name(id='v', ctx=Load())
Pow()
Num(n=2)
Load()
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load())
Name(id='factors', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Name(id='a', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='len', ctx=Load())
Name(id='up_qreg', ctx=Load())
Name(id='b', ctx=Load())
FloorDiv()
Name(id='a', ctx=Load())
Load()
Load()
Name(id='t', ctx=Load())
Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1)))
Load()
Name(id='t', ctx=Load())
Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1)))
Load()
Load()
Name(id='i', ctx=Load())
Load()
Num(n=1)
Name(id='N', ctx=Load())
Store()
Name(id='one_factor', ctx=Load())
Name(id='other_factor', ctx=Load())
Load()
Load()
Load()
BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))
Load()
Load()
Name(id='i', ctx=Load())
Add()
Num(n=1)
Load()
Load()
Num(n=4)
Mult()
Name(id='n', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))
Load()
BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Sub()
Num(n=1)
Load()
Load()
Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Name(id='i', ctx=Load())
Sub()
Num(n=1)
Name(id='i', ctx=Load())
Sub()
Num(n=1)
Load()
Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[])
Slice(lower=Num(n=2), upper=None, step=None)
Load()
Load()
Name(id='bin', ctx=Load())
Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])
Num(n=2)
Load()
Name(id='int', ctx=Load())
Name(id='i', ctx=Load())
Load()
Load()
Module(body=[Expr(value=Str(s="Shor's factoring algorithm.")), Import(names=[alias(name='array', asname=None)]), Import(names=[alias(name='fractions', asname=None)]), Import(names=[alias(name='logging', asname=None)]), Import(names=[alias(name='math', asname=None)]), Import(names=[alias(name='sys', asname=None)]), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None)], level=0), ImportFrom(module='qiskit.circuit', names=[alias(name='Gate', asname=None), alias(name='Instruction', asname=None), alias(name='ParameterVector', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library', names=[alias(name='QFT', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.quantum_info', names=[alias(name='partial_trace', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='summarize_circuits', asname=None)], level=0), ImportFrom(module='qiskit.utils.arithmetic', names=[alias(name='is_power', asname=None)], level=0), ImportFrom(module='qiskit.utils.quantum_instance', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0), ImportFrom(module='algorithm_result', names=[alias(name='AlgorithmResult', asname=None)], level=2), ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='Shor', bases=[], keywords=[], body=[Expr(value=Str(s="Shor's factoring algorithm.\n\n    Shor's Factoring algorithm is one of the most well-known quantum algorithms and finds the\n    prime factors for input integer :math:`N` in polynomial time.\n\n    Adapted from https://github.com/ttlion/ShorAlgQiskit\n\n    See also https://arxiv.org/abs/quant-ph/0205095\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Name(id='quantum_instance', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum instance.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_get_angles', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='n', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the array of angles to be used in the addition in Fourier Space.')), Assign(targets=[Name(id='bits_little_endian', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=BinOp(left=Name(id='angles', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='_phi_add_gate', args=arguments(args=[arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Gate that performs addition by a in Fourier Space.')), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])], keywords=[keyword(arg='name', value=Str(s='phi_add_a'))])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='angle', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='Gate', ctx=Load())), FunctionDef(name='_double_controlled_phi_add_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Creates a circuit which implements double-controlled modular addition by a.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=2), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))])), Assign(targets=[Name(id='cc_phi_add_a', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load()), args=[Num(n=2)], keywords=[])), Assign(targets=[Name(id='cc_iphi_add_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iphi_add_N', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c_phi_add_N', ctx=Load()), List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_iphi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_controlled_multiple_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular multiplication by a as an instruction.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='x_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load()), Str(s='x')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='x_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='cmult_a_mod_N'))])), Assign(targets=[Name(id='angle_params', ctx=Store())], value=Call(func=Name(id='ParameterVector', ctx=Load()), args=[Str(s='angles')], keywords=[keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))])), Assign(targets=[Name(id='modulo_adder', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load()), args=[Name(id='angle_params', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), FunctionDef(name='append_adder', args=arguments(args=[arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='constant', annotation=Name(id='int', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='partial_constant', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load()))), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=None), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_inv', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())]), body=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))]), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='modulo_adder_inv', ctx=Store())], value=Call(func=Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load())), FunctionDef(name='_power_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular exponentiation a^x as an instruction.')), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))])), Assign(targets=[Name(id='qft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])), Assign(targets=[Name(id='iphi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='c_phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load()), args=[Num(n=1)], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]), body=[Assign(targets=[Name(id='partial_a', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_multiplier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load())), FunctionDef(name='_validate_input', args=arguments(args=[arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check parameters of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Raises:\n            ValueError: Invalid input\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='N'), Name(id='N', ctx=Load()), Num(n=3)], keywords=[])), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='a'), Name(id='a', ctx=Load()), Num(n=2)], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[]), cause=None)], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=None), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct quantum part of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            Quantum circuit.\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_power', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='up_qreg', ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='up_cqreg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='modinv', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='m', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the modular multiplicative inverse of a with respect to the modulus m.')), FunctionDef(name='egcd', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='x', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='g', ctx=Load()), ops=[NotEq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[]), cause=None)], orelse=[]), Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='m', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='_get_factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Apply the continued fractions to find r and the gcd to find the desired factors.')), Assign(targets=[Name(id='x_final', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='measurement', ctx=Load()), Num(n=2)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='In decimal, x_final value for this result is: %s.'), Name(id='x_final', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='x_final', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='x_final value is <= 0, there are no continued fractions.'))], orelse=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=NameConstant(value=None)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[]))]), Assign(targets=[Name(id='T_upper', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='T_upper', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Name(id='x_final', ctx=Load()), op=Div(), right=Name(id='T', ctx=Load()))), Assign(targets=[Name(id='i', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='i')], keywords=[])), Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='f')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[])), Assign(targets=[Name(id='exponential', ctx=Store())], value=Num(n=0.0)), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='denominator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Num(n=1)), If(test=Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])), Continue()], orelse=[]), If(test=Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)]), body=[Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))], orelse=[Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cannot find factors from measurement %s because %s'), Name(id='measurement', ctx=Load()), BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])], keywords=[])), Return(value=NameConstant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='_calculate_continued_fraction', args=arguments(args=[arg(arg='b', annotation=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculate the continued fraction of x/T from the current terms of expansion b.')), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=Num(n=0)), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))))], orelse=[]), AugAssign(target=Name(id='x_over_T', ctx=Store()), op=Add(), value=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='frac', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Approximation number %s of continued fractions:'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Numerator:%s \t\t Denominator: %s.'), Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load()), Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='factor', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2)]), body=[Expr(value=Str(s='Execute the algorithm.\n\n        The input integer :math:`N` to be factored is expected to be odd and greater than 2.\n        Even though this implementation is general, its capability will be limited by the\n        capacity of the simulator/hardware. Another input integer :math:`a`  can also be supplied,\n        which needs to be a co-prime smaller than :math:`N` .\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Returns:\n            ShorResult: results of the algorithm.\n\n        Raises:\n            ValueError: Invalid input\n            AlgorithmError: If a quantum instance or backend has not been provided\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='ShorResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='tf', ctx=Store()), Name(id='b', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())], value=Call(func=Name(id='is_power', ctx=Load()), args=[Name(id='N', ctx=Load())], keywords=[keyword(arg='return_decomposition', value=NameConstant(value=True))])), If(test=Name(id='tf', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])), For(target=Name(id='measurement', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='ShorResult'))], decorator_list=[]), ClassDef(name='ShorResult', bases=[Name(id='AlgorithmResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Shor Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Num(n=0))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns factors')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set factors')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='factors', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns total counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set total counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='total_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns successful counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set successful counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='successful_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])])
Expr(value=Str(s="Shor's factoring algorithm."))
Import(names=[alias(name='array', asname=None)])
Import(names=[alias(name='fractions', asname=None)])
Import(names=[alias(name='logging', asname=None)])
Import(names=[alias(name='math', asname=None)])
Import(names=[alias(name='sys', asname=None)])
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None)], level=0)
ImportFrom(module='qiskit.circuit', names=[alias(name='Gate', asname=None), alias(name='Instruction', asname=None), alias(name='ParameterVector', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library', names=[alias(name='QFT', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.quantum_info', names=[alias(name='partial_trace', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='summarize_circuits', asname=None)], level=0)
ImportFrom(module='qiskit.utils.arithmetic', names=[alias(name='is_power', asname=None)], level=0)
ImportFrom(module='qiskit.utils.quantum_instance', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0)
ImportFrom(module='algorithm_result', names=[alias(name='AlgorithmResult', asname=None)], level=2)
ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2)
Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[]))
ClassDef(name='Shor', bases=[], keywords=[], body=[Expr(value=Str(s="Shor's factoring algorithm.\n\n    Shor's Factoring algorithm is one of the most well-known quantum algorithms and finds the\n    prime factors for input integer :math:`N` in polynomial time.\n\n    Adapted from https://github.com/ttlion/ShorAlgQiskit\n\n    See also https://arxiv.org/abs/quant-ph/0205095\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Name(id='quantum_instance', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum instance.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_get_angles', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='n', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the array of angles to be used in the addition in Fourier Space.')), Assign(targets=[Name(id='bits_little_endian', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=BinOp(left=Name(id='angles', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), FunctionDef(name='_phi_add_gate', args=arguments(args=[arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Gate that performs addition by a in Fourier Space.')), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])], keywords=[keyword(arg='name', value=Str(s='phi_add_a'))])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='angle', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='Gate', ctx=Load())), FunctionDef(name='_double_controlled_phi_add_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Creates a circuit which implements double-controlled modular addition by a.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=2), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))])), Assign(targets=[Name(id='cc_phi_add_a', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load()), args=[Num(n=2)], keywords=[])), Assign(targets=[Name(id='cc_iphi_add_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iphi_add_N', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c_phi_add_N', ctx=Load()), List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_iphi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_controlled_multiple_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular multiplication by a as an instruction.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='x_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load()), Str(s='x')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='x_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='cmult_a_mod_N'))])), Assign(targets=[Name(id='angle_params', ctx=Store())], value=Call(func=Name(id='ParameterVector', ctx=Load()), args=[Str(s='angles')], keywords=[keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))])), Assign(targets=[Name(id='modulo_adder', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load()), args=[Name(id='angle_params', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), FunctionDef(name='append_adder', args=arguments(args=[arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='constant', annotation=Name(id='int', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='partial_constant', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load()))), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=None), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_inv', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())]), body=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))]), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='modulo_adder_inv', ctx=Store())], value=Call(func=Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load())), FunctionDef(name='_power_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular exponentiation a^x as an instruction.')), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))])), Assign(targets=[Name(id='qft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])), Assign(targets=[Name(id='iphi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='c_phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load()), args=[Num(n=1)], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]), body=[Assign(targets=[Name(id='partial_a', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_multiplier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load())), FunctionDef(name='_validate_input', args=arguments(args=[arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check parameters of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Raises:\n            ValueError: Invalid input\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='N'), Name(id='N', ctx=Load()), Num(n=3)], keywords=[])), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='a'), Name(id='a', ctx=Load()), Num(n=2)], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[]), cause=None)], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=None), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct quantum part of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            Quantum circuit.\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_power', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='up_qreg', ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='up_cqreg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='modinv', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='m', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the modular multiplicative inverse of a with respect to the modulus m.')), FunctionDef(name='egcd', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='x', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='g', ctx=Load()), ops=[NotEq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[]), cause=None)], orelse=[]), Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='m', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='_get_factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Apply the continued fractions to find r and the gcd to find the desired factors.')), Assign(targets=[Name(id='x_final', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='measurement', ctx=Load()), Num(n=2)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='In decimal, x_final value for this result is: %s.'), Name(id='x_final', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='x_final', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='x_final value is <= 0, there are no continued fractions.'))], orelse=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=NameConstant(value=None)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[]))]), Assign(targets=[Name(id='T_upper', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='T_upper', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Name(id='x_final', ctx=Load()), op=Div(), right=Name(id='T', ctx=Load()))), Assign(targets=[Name(id='i', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='i')], keywords=[])), Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='f')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[])), Assign(targets=[Name(id='exponential', ctx=Store())], value=Num(n=0.0)), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='denominator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Num(n=1)), If(test=Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])), Continue()], orelse=[]), If(test=Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)]), body=[Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))], orelse=[Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cannot find factors from measurement %s because %s'), Name(id='measurement', ctx=Load()), BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])], keywords=[])), Return(value=NameConstant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='_calculate_continued_fraction', args=arguments(args=[arg(arg='b', annotation=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculate the continued fraction of x/T from the current terms of expansion b.')), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=Num(n=0)), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))))], orelse=[]), AugAssign(target=Name(id='x_over_T', ctx=Store()), op=Add(), value=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='frac', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Approximation number %s of continued fractions:'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Numerator:%s \t\t Denominator: %s.'), Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load()), Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='factor', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2)]), body=[Expr(value=Str(s='Execute the algorithm.\n\n        The input integer :math:`N` to be factored is expected to be odd and greater than 2.\n        Even though this implementation is general, its capability will be limited by the\n        capacity of the simulator/hardware. Another input integer :math:`a`  can also be supplied,\n        which needs to be a co-prime smaller than :math:`N` .\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Returns:\n            ShorResult: results of the algorithm.\n\n        Raises:\n            ValueError: Invalid input\n            AlgorithmError: If a quantum instance or backend has not been provided\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='ShorResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='tf', ctx=Store()), Name(id='b', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())], value=Call(func=Name(id='is_power', ctx=Load()), args=[Name(id='N', ctx=Load())], keywords=[keyword(arg='return_decomposition', value=NameConstant(value=True))])), If(test=Name(id='tf', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])), For(target=Name(id='measurement', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='ShorResult'))], decorator_list=[])
ClassDef(name='ShorResult', bases=[Name(id='AlgorithmResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Shor Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Num(n=0))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns factors')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set factors')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='factors', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns total counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set total counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='total_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns successful counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set successful counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='successful_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
Str(s="Shor's factoring algorithm.")
alias(name='array', asname=None)
alias(name='fractions', asname=None)
alias(name='logging', asname=None)
alias(name='math', asname=None)
alias(name='sys', asname=None)
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='List', asname=None)
alias(name='Tuple', asname=None)
alias(name='numpy', asname='np')
alias(name='ClassicalRegister', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='QuantumRegister', asname=None)
alias(name='Gate', asname=None)
alias(name='Instruction', asname=None)
alias(name='ParameterVector', asname=None)
alias(name='QFT', asname=None)
alias(name='Backend', asname=None)
alias(name='partial_trace', asname=None)
alias(name='summarize_circuits', asname=None)
alias(name='is_power', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='validate_min', asname=None)
alias(name='AlgorithmResult', asname=None)
alias(name='AlgorithmError', asname=None)
Name(id='logger', ctx=Store())
Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])
Expr(value=Str(s="Shor's factoring algorithm.\n\n    Shor's Factoring algorithm is one of the most well-known quantum algorithms and finds the\n    prime factors for input integer :math:`N` in polynomial time.\n\n    Adapted from https://github.com/ttlion/ShorAlgQiskit\n\n    See also https://arxiv.org/abs/quant-ph/0205095\n    "))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            quantum_instance: Quantum Instance or Backend\n\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None)), If(test=Name(id='quantum_instance', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns quantum instance.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets quantum instance.')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='_get_angles', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='n', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the array of angles to be used in the addition in Fourier Space.')), Assign(targets=[Name(id='bits_little_endian', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])], orelse=[]), Return(value=BinOp(left=Name(id='angles', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
FunctionDef(name='_phi_add_gate', args=arguments(args=[arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Gate that performs addition by a in Fourier Space.')), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])], keywords=[keyword(arg='name', value=Str(s='phi_add_a'))])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='angle', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='Gate', ctx=Load()))
FunctionDef(name='_double_controlled_phi_add_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Creates a circuit which implements double-controlled modular addition by a.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=2), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))])), Assign(targets=[Name(id='cc_phi_add_a', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load()), args=[Num(n=2)], keywords=[])), Assign(targets=[Name(id='cc_iphi_add_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iphi_add_N', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c_phi_add_N', ctx=Load()), List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_iphi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='_controlled_multiple_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular multiplication by a as an instruction.')), Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='ctrl')], keywords=[])), Assign(targets=[Name(id='x_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load()), Str(s='x')], keywords=[])), Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)), Str(s='b')], keywords=[])), Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='x_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='cmult_a_mod_N'))])), Assign(targets=[Name(id='angle_params', ctx=Store())], value=Call(func=Name(id='ParameterVector', ctx=Load()), args=[Str(s='angles')], keywords=[keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))])), Assign(targets=[Name(id='modulo_adder', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load()), args=[Name(id='angle_params', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), FunctionDef(name='append_adder', args=arguments(args=[arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='constant', annotation=Name(id='int', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='partial_constant', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load()))), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=None), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_inv', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())]), body=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))]), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))), Assign(targets=[Name(id='modulo_adder_inv', ctx=Store())], value=Call(func=Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load()))
FunctionDef(name='_power_mod_N', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Implements modular exponentiation a^x as an instruction.')), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))])), Assign(targets=[Name(id='qft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])), Assign(targets=[Name(id='iphi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='c_phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load()), args=[Num(n=1)], keywords=[])), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]), body=[Assign(targets=[Name(id='partial_a', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_multiplier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Name(id='Instruction', ctx=Load()))
FunctionDef(name='_validate_input', args=arguments(args=[arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Check parameters of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Raises:\n            ValueError: Invalid input\n\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='N'), Name(id='N', ctx=Load()), Num(n=3)], keywords=[])), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='a'), Name(id='a', ctx=Load()), Num(n=2)], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[]), cause=None)], orelse=[]), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[]), cause=None)], orelse=[])], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=None)
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct quantum part of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            Quantum circuit.\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])), Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])), Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_power', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='up_qreg', ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='up_cqreg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='modinv', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='m', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the modular multiplicative inverse of a with respect to the modulus m.')), FunctionDef(name='egcd', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())), Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='x', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='g', ctx=Load()), ops=[NotEq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[]), cause=None)], orelse=[]), Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='m', ctx=Load())))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='_get_factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Apply the continued fractions to find r and the gcd to find the desired factors.')), Assign(targets=[Name(id='x_final', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='measurement', ctx=Load()), Num(n=2)], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='In decimal, x_final value for this result is: %s.'), Name(id='x_final', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='x_final', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='x_final value is <= 0, there are no continued fractions.'))], orelse=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=NameConstant(value=None)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[]))]), Assign(targets=[Name(id='T_upper', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='T_upper', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Name(id='x_final', ctx=Load()), op=Div(), right=Name(id='T', ctx=Load()))), Assign(targets=[Name(id='i', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='i')], keywords=[])), Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='f')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[])), Assign(targets=[Name(id='exponential', ctx=Store())], value=Num(n=0.0)), While(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='denominator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Num(n=1)), If(test=Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])), Continue()], orelse=[]), If(test=Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)]), body=[Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))], orelse=[Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cannot find factors from measurement %s because %s'), Name(id='measurement', ctx=Load()), BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])], keywords=[])), Return(value=NameConstant(value=None))], decorator_list=[], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='_calculate_continued_fraction', args=arguments(args=[arg(arg='b', annotation=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculate the continued fraction of x/T from the current terms of expansion b.')), Assign(targets=[Name(id='x_over_T', ctx=Store())], value=Num(n=0)), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))))], orelse=[]), AugAssign(target=Name(id='x_over_T', ctx=Store()), op=Add(), value=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='frac', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Approximation number %s of continued fractions:'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Numerator:%s \t\t Denominator: %s.'), Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load()), Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())], keywords=[])), Return(value=Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='factor', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2)]), body=[Expr(value=Str(s='Execute the algorithm.\n\n        The input integer :math:`N` to be factored is expected to be odd and greater than 2.\n        Even though this implementation is general, its capability will be limited by the\n        capacity of the simulator/hardware. Another input integer :math:`a`  can also be supplied,\n        which needs to be a co-prime smaller than :math:`N` .\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Returns:\n            ShorResult: results of the algorithm.\n\n        Raises:\n            ValueError: Invalid input\n            AlgorithmError: If a quantum instance or backend has not been provided\n\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='ShorResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='tf', ctx=Store()), Name(id='b', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())], value=Call(func=Name(id='is_power', ctx=Load()), args=[Name(id='N', ctx=Load())], keywords=[keyword(arg='return_decomposition', value=NameConstant(value=True))])), If(test=Name(id='tf', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))], orelse=[]), If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])), For(target=Name(id='measurement', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[]), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='ShorResult'))
Name(id='AlgorithmResult', ctx=Load())
Expr(value=Str(s='Shor Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Num(n=0)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Num(n=0))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns factors')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='factors', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set factors')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='factors', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns total counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='total_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set total counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='total_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='returns successful counts')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='successful_counts', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='set successful counts')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='successful_counts', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
Store()
Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load())
Name(id='__name__', ctx=Load())
Str(s="Shor's factoring algorithm.\n\n    Shor's Factoring algorithm is one of the most well-known quantum algorithms and finds the\n    prime factors for input integer :math:`N` in polynomial time.\n\n    Adapted from https://github.com/ttlion/ShorAlgQiskit\n\n    See also https://arxiv.org/abs/quant-ph/0205095\n    ")
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='\n        Args:\n            quantum_instance: Quantum Instance or Backend\n\n        '))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=NameConstant(value=None))
If(test=Name(id='quantum_instance', ctx=Load()), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], orelse=[])
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns quantum instance.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets quantum instance.'))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='n', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Calculates the array of angles to be used in the addition in Fourier Space.'))
Assign(targets=[Name(id='bits_little_endian', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])], orelse=[])
Return(value=BinOp(left=Name(id='angles', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Name(id='staticmethod', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
arguments(args=[arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Gate that performs addition by a in Fourier Space.'))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])], keywords=[keyword(arg='name', value=Str(s='phi_add_a'))]))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='angle', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[])
Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load()), args=[], keywords=[]))
Name(id='staticmethod', ctx=Load())
Name(id='Gate', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Creates a circuit which implements double-controlled modular addition by a.'))
Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=2), Str(s='ctrl')], keywords=[]))
Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), Str(s='b')], keywords=[]))
Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))]))
Assign(targets=[Name(id='cc_phi_add_a', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load()), args=[Num(n=2)], keywords=[]))
Assign(targets=[Name(id='cc_iphi_add_a', ctx=Store())], value=Call(func=Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iphi_add_N', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c_phi_add_N', ctx=Load()), List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_iphi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Return(value=Name(id='circuit', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load())), arg(arg='qft', annotation=Name(id='Gate', ctx=Load())), arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Implements modular multiplication by a as an instruction.'))
Assign(targets=[Name(id='ctrl_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='ctrl')], keywords=[]))
Assign(targets=[Name(id='x_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load()), Str(s='x')], keywords=[]))
Assign(targets=[Name(id='b_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)), Str(s='b')], keywords=[]))
Assign(targets=[Name(id='flag_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='x_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='cmult_a_mod_N'))]))
Assign(targets=[Name(id='angle_params', ctx=Store())], value=Call(func=Name(id='ParameterVector', ctx=Load()), args=[Str(s='angles')], keywords=[keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))]))
Assign(targets=[Name(id='modulo_adder', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load()), args=[Name(id='angle_params', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[]))
FunctionDef(name='append_adder', args=arguments(args=[arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='constant', annotation=Name(id='int', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='partial_constant', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load()))), Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], decorator_list=[], returns=None)
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='a_inv', ctx=Store())], value=IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())]), body=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))]), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])))
Assign(targets=[Name(id='modulo_adder_inv', ctx=Store())], value=Call(func=Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[]))
Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))
Name(id='Instruction', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='n', annotation=Name(id='int', ctx=Load())), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Implements modular exponentiation a^x as an instruction.'))
Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))]))
Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))]))
Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))]))
Assign(targets=[Name(id='qft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]))
Assign(targets=[Name(id='iphi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='c_phi_add_N', ctx=Store())], value=Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load()), args=[Num(n=1)], keywords=[]))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]), body=[Assign(targets=[Name(id='partial_a', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='modulo_multiplier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])
Return(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]))
Name(id='Instruction', ctx=Load())
arguments(args=[arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Check parameters of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Raises:\n            ValueError: Invalid input\n\n        '))
Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='N'), Name(id='N', ctx=Load()), Num(n=3)], keywords=[]))
Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='a'), Name(id='a', ctx=Load()), Num(n=2)], keywords=[]))
If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[]), cause=None)], orelse=[])
If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[]), cause=None)], orelse=[])
Name(id='staticmethod', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2), NameConstant(value=False)])
Expr(value=Str(s='Construct quantum part of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            Quantum circuit.\n\n        '))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='up_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))]))
Assign(targets=[Name(id='down_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))]))
Assign(targets=[Name(id='aux_qreg', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Assign(targets=[Name(id='modulo_power', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_power', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='iqft', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='up_qreg', ctx=Load())], keywords=[]))
If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='up_cqreg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[]))
Return(value=Name(id='circuit', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='m', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the modular multiplicative inverse of a with respect to the modulus m.'))
FunctionDef(name='egcd', args=arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()))
Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='x', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='g', ctx=Load()), ops=[NotEq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[]), cause=None)], orelse=[])
Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='m', ctx=Load())))
Name(id='staticmethod', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Apply the continued fractions to find r and the gcd to find the desired factors.'))
Assign(targets=[Name(id='x_final', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Name(id='measurement', ctx=Load()), Num(n=2)], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='In decimal, x_final value for this result is: %s.'), Name(id='x_final', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='x_final', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='x_final value is <= 0, there are no continued fractions.'))], orelse=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=NameConstant(value=None)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[]))])
Assign(targets=[Name(id='T_upper', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='measurement', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='T_upper', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Name(id='x_final', ctx=Load()), op=Div(), right=Name(id='T', ctx=Load())))
Assign(targets=[Name(id='i', ctx=Store())], value=Num(n=0))
Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='i')], keywords=[]))
Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='f')], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))
Assign(targets=[Name(id='exponential', ctx=Store())], value=Num(n=0.0))
While(test=BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))], orelse=[]), Assign(targets=[Name(id='denominator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])), AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Num(n=1)), If(test=Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])), Continue()], orelse=[]), If(test=Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)]), body=[Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))], orelse=[Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])])], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cannot find factors from measurement %s because %s'), Name(id='measurement', ctx=Load()), BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])], keywords=[]))
Return(value=NameConstant(value=None))
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='b', annotation=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Calculate the continued fraction of x/T from the current terms of expansion b.'))
Assign(targets=[Name(id='x_over_T', ctx=Store())], value=Num(n=0))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])], keywords=[]), body=[Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))))], orelse=[])
AugAssign(target=Name(id='x_over_T', ctx=Store()), op=Add(), value=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='frac', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Approximation number %s of continued fractions:'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Numerator:%s \t\t Denominator: %s.'), Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load()), Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())], keywords=[]))
Return(value=Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load()))
Name(id='staticmethod', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='N', annotation=Name(id='int', ctx=Load())), arg(arg='a', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2)])
Expr(value=Str(s='Execute the algorithm.\n\n        The input integer :math:`N` to be factored is expected to be odd and greater than 2.\n        Even though this implementation is general, its capability will be limited by the\n        capacity of the simulator/hardware. Another input integer :math:`a`  can also be supplied,\n        which needs to be a co-prime smaller than :math:`N` .\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Returns:\n            ShorResult: results of the algorithm.\n\n        Raises:\n            ValueError: Invalid input\n            AlgorithmError: If a quantum instance or backend has not been provided\n\n        '))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='ShorResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Tuple(elts=[Name(id='tf', ctx=Store()), Name(id='b', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())], value=Call(func=Name(id='is_power', ctx=Load()), args=[Name(id='N', ctx=Load())], keywords=[keyword(arg='return_decomposition', value=NameConstant(value=True))]))
If(test=Name(id='tf', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))], orelse=[])
If(test=UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))]), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])), For(target=Name(id='measurement', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])], orelse=[])
Return(value=Name(id='result', ctx=Load()))
Str(s='ShorResult')
Load()
Str(s='Shor Result.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Num(n=0))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Num(n=0))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='returns factors'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='set factors'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='factors', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='returns total counts'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='set total counts'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='total_counts', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='returns successful counts'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='set successful counts'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='successful_counts', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
Name(id='logging', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='\n        Args:\n            quantum_instance: Quantum Instance or Backend\n\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
NameConstant(value=None)
Name(id='quantum_instance', ctx=Load())
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
arg(arg='self', annotation=None)
Str(s='Returns quantum instance.')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Sets quantum instance.')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='n', annotation=Name(id='int', ctx=Load()))
Str(s='Calculates the array of angles to be used in the addition in Fourier Space.')
Name(id='bits_little_endian', ctx=Store())
Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Name(id='angles', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
For(target=Name(id='j', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]), body=[Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])], orelse=[])
BinOp(left=Name(id='angles', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Gate that performs addition by a in Fourier Space.')
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])], keywords=[keyword(arg='name', value=Str(s='phi_add_a'))])
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='angle', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load()), args=[], keywords=[])
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='angles', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load()))
arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load()))
arg(arg='qft', annotation=Name(id='Gate', ctx=Load()))
arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))
Str(s='Creates a circuit which implements double-controlled modular addition by a.')
Name(id='ctrl_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=2), Str(s='ctrl')], keywords=[])
Name(id='b_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), Str(s='b')], keywords=[])
Name(id='flag_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))])
Name(id='cc_phi_add_a', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load()), args=[Num(n=2)], keywords=[])
Name(id='cc_iphi_add_a', ctx=Store())
Call(func=Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iphi_add_N', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='c_phi_add_N', ctx=Load()), List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_iphi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='cc_phi_add_a', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Name(id='circuit', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='n', annotation=Name(id='int', ctx=Load()))
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='c_phi_add_N', annotation=Name(id='Gate', ctx=Load()))
arg(arg='iphi_add_N', annotation=Name(id='Gate', ctx=Load()))
arg(arg='qft', annotation=Name(id='Gate', ctx=Load()))
arg(arg='iqft', annotation=Name(id='Gate', ctx=Load()))
Str(s='Implements modular multiplication by a as an instruction.')
Name(id='ctrl_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='ctrl')], keywords=[])
Name(id='x_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load()), Str(s='x')], keywords=[])
Name(id='b_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)), Str(s='b')], keywords=[])
Name(id='flag_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1), Str(s='flag')], keywords=[])
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Name(id='x_qreg', ctx=Load()), Name(id='b_qreg', ctx=Load()), Name(id='flag_qreg', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='cmult_a_mod_N'))])
Name(id='angle_params', ctx=Store())
Call(func=Name(id='ParameterVector', ctx=Load()), args=[Str(s='angles')], keywords=[keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))])
Name(id='modulo_adder', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load()), args=[Name(id='angle_params', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])
arguments(args=[arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='constant', annotation=Name(id='int', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='partial_constant', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load())))
Assign(targets=[Name(id='angles', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]))
Assign(targets=[Name(id='bound', ctx=Store())], value=Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='qft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Name(id='a_inv', ctx=Store())
IfExp(test=Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())]), body=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))]), orelse=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))
Name(id='modulo_adder_inv', ctx=Store())
Call(func=Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
Name(id='i', ctx=Store())
Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])], keywords=[])
Expr(value=Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='b_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[])
Load()
arg(arg='self', annotation=None)
arg(arg='n', annotation=Name(id='int', ctx=Load()))
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
Str(s='Implements modular exponentiation a^x as an instruction.')
Name(id='up_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])
Name(id='down_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])
Name(id='aux_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))])
Name(id='qft', ctx=Store())
Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load()), args=[], keywords=[])
Name(id='iqft', ctx=Store())
Call(func=Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
Name(id='phi_add_N', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])
Name(id='iphi_add_N', ctx=Store())
Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
Name(id='c_phi_add_N', ctx=Store())
Call(func=Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load()), args=[Num(n=1)], keywords=[])
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])
Assign(targets=[Name(id='partial_a', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='modulo_multiplier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[])
Load()
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
Str(s='Check parameters of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Raises:\n            ValueError: Invalid input\n\n        ')
Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='N'), Name(id='N', ctx=Load()), Num(n=3)], keywords=[])
Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='a'), Name(id='a', ctx=Load()), Num(n=2)], keywords=[])
BoolOp(op=Or(), values=[Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)]), Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[]), cause=None)
BoolOp(op=Or(), values=[Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[]), cause=None)
Load()
arg(arg='self', annotation=None)
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))
Num(n=2)
NameConstant(value=False)
Str(s='Construct quantum part of the algorithm.\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n            measurement: Boolean flag to indicate if measurement should be included in the circuit.\n\n        Returns:\n            Quantum circuit.\n\n        ')
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])
Name(id='n', ctx=Store())
Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])
Name(id='up_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='up'))])
Name(id='down_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='down'))])
Name(id='aux_qreg', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[keyword(arg='name', value=Str(s='aux'))])
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='down_qreg', ctx=Load()), Name(id='aux_qreg', ctx=Load())], keywords=[keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load()), args=[Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='modulo_power', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_power', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])
Name(id='iqft', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='iqft', ctx=Load()), Name(id='up_qreg', ctx=Load())], keywords=[])
Name(id='measurement', ctx=Load())
Assign(targets=[Name(id='up_cqreg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])], keywords=[])
Name(id='circuit', ctx=Load())
Load()
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='m', annotation=Name(id='int', ctx=Load()))
Str(s='Returns the modular multiplicative inverse of a with respect to the modulus m.')
arguments(args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))], orelse=[Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))])
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Tuple(elts=[Name(id='g', ctx=Store()), Name(id='x', ctx=Store()), Name(id='_', ctx=Store())], ctx=Store())
Call(func=Name(id='egcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load())], keywords=[])
Compare(left=Name(id='g', ctx=Load()), ops=[NotEq()], comparators=[Num(n=1)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[]), cause=None)
BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='m', ctx=Load()))
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='measurement', annotation=Name(id='str', ctx=Load()))
Str(s='Apply the continued fractions to find r and the gcd to find the desired factors.')
Name(id='x_final', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Name(id='measurement', ctx=Load()), Num(n=2)], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='In decimal, x_final value for this result is: %s.'), Name(id='x_final', ctx=Load())], keywords=[])
Compare(left=Name(id='x_final', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)])
Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='x_final value is <= 0, there are no continued fractions.'))
Assign(targets=[Name(id='fail_reason', ctx=Store())], value=NameConstant(value=None))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[]))
Name(id='T_upper', ctx=Store())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='measurement', ctx=Load())], keywords=[])
Name(id='T', ctx=Store())
Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='T_upper', ctx=Load())], keywords=[])
Name(id='x_over_T', ctx=Store())
BinOp(left=Name(id='x_final', ctx=Load()), op=Div(), right=Name(id='T', ctx=Load()))
Name(id='i', ctx=Store())
Num(n=0)
Name(id='b', ctx=Store())
Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='i')], keywords=[])
Name(id='t', ctx=Store())
Call(func=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()), args=[Str(s='f')], keywords=[])
Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[])
Name(id='exponential', ctx=Store())
Num(n=0.0)
BoolOp(op=And(), values=[Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())]), Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))], orelse=[])
Assign(targets=[Name(id='denominator', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))
AugAssign(target=Name(id='i', ctx=Store()), op=Add(), value=Num(n=1))
If(test=Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])), Continue()], orelse=[])
If(test=Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)]), body=[Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))], orelse=[])
If(test=Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))], orelse=[Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])), Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cannot find factors from measurement %s because %s'), Name(id='measurement', ctx=Load()), BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])], keywords=[])
NameConstant(value=None)
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Load()
arg(arg='b', annotation=Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load()))
Str(s='Calculate the continued fraction of x/T from the current terms of expansion b.')
Name(id='x_over_T', ctx=Store())
Num(n=0)
Name(id='i', ctx=Store())
Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])], keywords=[])
Assign(targets=[Name(id='x_over_T', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))))
Name(id='x_over_T', ctx=Store())
Add()
Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='frac', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Approximation number %s of continued fractions:'), Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Numerator:%s \t\t Denominator: %s.'), Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load()), Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())], keywords=[])
Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='N', annotation=Name(id='int', ctx=Load()))
arg(arg='a', annotation=Name(id='int', ctx=Load()))
Num(n=2)
Str(s='Execute the algorithm.\n\n        The input integer :math:`N` to be factored is expected to be odd and greater than 2.\n        Even though this implementation is general, its capability will be limited by the\n        capacity of the simulator/hardware. Another input integer :math:`a`  can also be supplied,\n        which needs to be a co-prime smaller than :math:`N` .\n\n        Args:\n            N: The odd integer to be factored, has a min. value of 3.\n            a: Any integer that satisfies 1 < a < N and gcd(a, N) = 1.\n\n        Returns:\n            ShorResult: results of the algorithm.\n\n        Raises:\n            ValueError: Invalid input\n            AlgorithmError: If a quantum instance or backend has not been provided\n\n        ')
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[]), cause=None)
Name(id='result', ctx=Store())
Call(func=Name(id='ShorResult', ctx=Load()), args=[], keywords=[])
Tuple(elts=[Name(id='tf', ctx=Store()), Name(id='b', ctx=Store()), Name(id='p', ctx=Store())], ctx=Store())
Call(func=Name(id='is_power', ctx=Load()), args=[Name(id='N', ctx=Load())], keywords=[keyword(arg='return_decomposition', value=NameConstant(value=True))])
Name(id='tf', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]))
UnaryOp(op=Not(), operand=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[]))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])), Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[])), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])], orelse=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))])
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())], value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[]))
For(target=Name(id='measurement', ctx=Store()), iter=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])], orelse=[])
Name(id='result', ctx=Load())
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())
List(elts=[], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())
Num(n=0)
Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())
Num(n=0)
arg(arg='self', annotation=None)
Str(s='returns factors')
Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='set factors')
Attribute(value=Name(id='self', ctx=Load()), attr='_factors', ctx=Store())
Name(id='value', ctx=Load())
Name(id='factors', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='returns total counts')
Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='int', ctx=Load()))
Str(s='set total counts')
Attribute(value=Name(id='self', ctx=Load()), attr='_total_counts', ctx=Store())
Name(id='value', ctx=Load())
Name(id='total_counts', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='returns successful counts')
Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='int', ctx=Load()))
Str(s='set successful counts')
Attribute(value=Name(id='self', ctx=Load()), attr='_successful_counts', ctx=Store())
Name(id='value', ctx=Load())
Name(id='successful_counts', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Store()
Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='zeros', ctx=Load())
Name(id='n', ctx=Load())
Store()
Name(id='range', ctx=Load())
Name(id='n', ctx=Load())
Name(id='j', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Assign(targets=[Name(id='k', ctx=Store())], value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load())))
If(test=Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')]), body=[AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))], orelse=[])
Name(id='angles', ctx=Load())
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())
Store()
Name(id='QuantumCircuit', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])
keyword(arg='name', value=Str(s='phi_add_a'))
Name(id='i', ctx=Store())
Name(id='angle', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='angles', ctx=Load())
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='angle', ctx=Load()), Name(id='i', ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='to_gate', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
Num(n=2)
Str(s='ctrl')
Store()
Name(id='QuantumRegister', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])
Str(s='b')
Store()
Name(id='QuantumRegister', ctx=Load())
Num(n=1)
Str(s='flag')
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='ctrl_qreg', ctx=Load())
Name(id='b_qreg', ctx=Load())
Name(id='flag_qreg', ctx=Load())
keyword(arg='name', value=Str(s='ccphi_add_a_mod_N'))
Store()
Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[]), attr='control', ctx=Load())
Num(n=2)
Store()
Attribute(value=Name(id='cc_phi_add_a', ctx=Load()), attr='inverse', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='cc_phi_add_a', ctx=Load())
List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iphi_add_N', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iqft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load())
Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='c_phi_add_N', ctx=Load())
List(elts=[Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='cc_iphi_add_a', ctx=Load())
List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iqft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load())
Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='cx', ctx=Load())
Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Subscript(value=Name(id='flag_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load())
Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='cc_phi_add_a', ctx=Load())
List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Name(id='Gate', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
Num(n=1)
Str(s='ctrl')
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='n', ctx=Load())
Str(s='x')
Store()
Name(id='QuantumRegister', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))
Str(s='b')
Store()
Name(id='QuantumRegister', ctx=Load())
Num(n=1)
Str(s='flag')
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='ctrl_qreg', ctx=Load())
Name(id='x_qreg', ctx=Load())
Name(id='b_qreg', ctx=Load())
Name(id='flag_qreg', ctx=Load())
keyword(arg='name', value=Str(s='cmult_a_mod_N'))
Store()
Name(id='ParameterVector', ctx=Load())
Str(s='angles')
keyword(arg='length', value=BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1)))
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_double_controlled_phi_add_mod_N', ctx=Load())
Name(id='angle_params', ctx=Load())
Name(id='c_phi_add_N', ctx=Load())
Name(id='iphi_add_N', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='iqft', ctx=Load())
arg(arg='adder', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='constant', annotation=Name(id='int', ctx=Load()))
arg(arg='idx', annotation=Name(id='int', ctx=Load()))
Name(id='partial_constant', ctx=Store())
BinOp(left=BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load())), op=Mod(), right=Name(id='N', ctx=Load()))
Name(id='angles', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='partial_constant', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Name(id='bound', ctx=Store())
Call(func=Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load()), args=[Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='bound', ctx=Load()), List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Store()
Name(id='range', ctx=Load())
Name(id='n', ctx=Load())
Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder', ctx=Load()), Name(id='a', ctx=Load()), Name(id='i', ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iqft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Store()
Name(id='range', ctx=Load())
Name(id='n', ctx=Load())
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load()), args=[Name(id='ctrl_qreg', ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Store()
Compare(left=Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load()), ops=[GtE()], comparators=[Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())])
Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[keyword(arg='mod', value=Name(id='N', ctx=Load()))])
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='modulo_adder', ctx=Load()), attr='inverse', ctx=Load())
Store()
Name(id='reversed', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[])
Call(func=Name(id='append_adder', ctx=Load()), args=[Name(id='modulo_adder_inv', ctx=Load()), Name(id='a_inv', ctx=Load()), Name(id='i', ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iqft', ctx=Load())
Name(id='b_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
keyword(arg='name', value=Str(s='up'))
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='n', ctx=Load())
keyword(arg='name', value=Str(s='down'))
Store()
Name(id='QuantumRegister', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))
keyword(arg='name', value=Str(s='aux'))
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='up_qreg', ctx=Load())
Name(id='down_qreg', ctx=Load())
Name(id='aux_qreg', ctx=Load())
keyword(arg='name', value=JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)]))
Store()
Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))]), attr='to_gate', ctx=Load())
Store()
Attribute(value=Name(id='qft', ctx=Load()), attr='inverse', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load()), args=[Name(id='N', ctx=Load()), BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Store()
Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='inverse', ctx=Load())
Store()
Attribute(value=Name(id='phi_add_N', ctx=Load()), attr='control', ctx=Load())
Num(n=1)
Store()
Name(id='range', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
Name(id='partial_a', ctx=Store())
Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[]), Name(id='N', ctx=Load())], keywords=[])
Name(id='modulo_multiplier', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load()), args=[Name(id='n', ctx=Load()), Name(id='N', ctx=Load()), Name(id='partial_a', ctx=Load()), Name(id='c_phi_add_N', ctx=Load()), Name(id='iphi_add_N', ctx=Load()), Name(id='qft', ctx=Load()), Name(id='iqft', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='modulo_multiplier', ctx=Load()), List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='to_instruction', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='validate_min', ctx=Load())
Str(s='N')
Name(id='N', ctx=Load())
Num(n=3)
Name(id='validate_min', ctx=Load())
Str(s='a')
Name(id='a', ctx=Load())
Num(n=2)
Or()
Compare(left=Name(id='N', ctx=Load()), ops=[Lt()], comparators=[Num(n=1)])
Compare(left=BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=0)])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The input needs to be an odd integer greater than 1.')], keywords=[])
Or()
Compare(left=Name(id='a', ctx=Load()), ops=[GtE()], comparators=[Name(id='N', ctx=Load())])
Compare(left=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), ops=[NotEq()], comparators=[Num(n=1)])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')], keywords=[])
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='bool', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load())
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Store()
Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
keyword(arg='name', value=Str(s='up'))
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='n', ctx=Load())
keyword(arg='name', value=Str(s='down'))
Store()
Name(id='QuantumRegister', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=2))
keyword(arg='name', value=Str(s='aux'))
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='up_qreg', ctx=Load())
Name(id='down_qreg', ctx=Load())
Name(id='aux_qreg', ctx=Load())
keyword(arg='name', value=JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')]))
Attribute(value=Name(id='circuit', ctx=Load()), attr='h', ctx=Load())
Name(id='up_qreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='x', ctx=Load())
Subscript(value=Name(id='down_qreg', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_power_mod_N', ctx=Load())
Name(id='n', ctx=Load())
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='modulo_power', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[]), attr='to_gate', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='iqft', ctx=Load())
Name(id='up_qreg', ctx=Load())
Load()
Name(id='up_cqreg', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[keyword(arg='name', value=Str(s='m'))])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='up_cqreg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='up_qreg', ctx=Load()), Name(id='up_cqreg', ctx=Load())], keywords=[])
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Call(func=Name(id='summarize_circuits', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
arg(arg='a', annotation=Name(id='int', ctx=Load()))
arg(arg='b', annotation=Name(id='int', ctx=Load()))
Compare(left=Name(id='a', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Return(value=Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load()))
Assign(targets=[Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())], value=Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[]))
Return(value=Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load()))
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='g', ctx=Store())
Name(id='x', ctx=Store())
Name(id='_', ctx=Store())
Store()
Name(id='egcd', ctx=Load())
Name(id='a', ctx=Load())
Name(id='m', ctx=Load())
Name(id='g', ctx=Load())
NotEq()
Num(n=1)
Call(func=Name(id='ValueError', ctx=Load()), args=[Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])], keywords=[])
Name(id='x', ctx=Load())
Mod()
Name(id='m', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='str', ctx=Load())
Store()
Name(id='int', ctx=Load())
Name(id='measurement', ctx=Load())
Num(n=2)
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='In decimal, x_final value for this result is: %s.')
Name(id='x_final', ctx=Load())
Name(id='x_final', ctx=Load())
LtE()
Num(n=0)
Name(id='fail_reason', ctx=Store())
Str(s='x_final value is <= 0, there are no continued fractions.')
Name(id='fail_reason', ctx=Store())
NameConstant(value=None)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running continued fractions for this case.')], keywords=[])
Store()
Name(id='len', ctx=Load())
Name(id='measurement', ctx=Load())
Store()
Name(id='pow', ctx=Load())
Num(n=2)
Name(id='T_upper', ctx=Load())
Store()
Name(id='x_final', ctx=Load())
Div()
Name(id='T', ctx=Load())
Store()
Store()
Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load())
Str(s='i')
Store()
Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load())
Str(s='f')
Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])
Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load())
BinOp(left=Name(id='x_over_T', ctx=Load()), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Store()
And()
Compare(left=Name(id='i', ctx=Load()), ops=[Lt()], comparators=[Name(id='N', ctx=Load())])
Compare(left=Name(id='fail_reason', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='i', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[]))
Name(id='denominator', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])
Name(id='i', ctx=Store())
Add()
Num(n=1)
Compare(left=BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2)), ops=[Eq()], comparators=[Num(n=1)])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[]))
Continue()
Compare(left=Name(id='denominator', ctx=Load()), ops=[Lt()], comparators=[Num(n=1000)])
Assign(targets=[Name(id='exponential', ctx=Store())], value=Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[]))
Compare(left=Name(id='exponential', ctx=Load()), ops=[Gt()], comparators=[Num(n=1000000000)])
Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='denominator of continued fraction is too big.'))
Assign(targets=[Name(id='putting_plus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[]))
Assign(targets=[Name(id='putting_minus', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))
Assign(targets=[Name(id='one_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='other_factor', ctx=Store())], value=Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])), If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])], orelse=[Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))])
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Cannot find factors from measurement %s because %s')
Name(id='measurement', ctx=Load())
BoolOp(op=Or(), values=[Name(id='fail_reason', ctx=Load()), Str(s='it took too many attempts.')])
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Attribute(value=Name(id='array', ctx=Load()), attr='array', ctx=Load())
Store()
Store()
Name(id='reversed', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))], keywords=[])
Name(id='x_over_T', ctx=Store())
BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load())))
Store()
Name(id='b', ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Attribute(value=Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[]), attr='limit_denominator', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Approximation number %s of continued fractions:')
Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Numerator:%s \t\t Denominator: %s.')
Attribute(value=Name(id='frac', ctx=Load()), attr='numerator', ctx=Load())
Attribute(value=Name(id='frac', ctx=Load()), attr='denominator', ctx=Load())
Name(id='frac', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_validate_input', ctx=Load())
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')], keywords=[])
Store()
Name(id='ShorResult', ctx=Load())
Name(id='tf', ctx=Store())
Name(id='b', ctx=Store())
Name(id='p', ctx=Store())
Store()
Name(id='is_power', ctx=Load())
Name(id='N', ctx=Load())
keyword(arg='return_decomposition', value=NameConstant(value=True))
Load()
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The input integer is a power: %s=%s^%s.'), Name(id='N', ctx=Load()), Name(id='b', ctx=Load()), Name(id='p', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])
Not()
Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Running with N=%s and a=%s.'), Name(id='N', ctx=Load()), Name(id='a', ctx=Load())], keywords=[])
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='n', ctx=Store())], value=Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[]))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='up_qreg_density_mat', ctx=Store())], value=Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[]))
Assign(targets=[Name(id='up_qreg_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='counts', ctx=Store())], value=Dict(keys=[], values=[]))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[]), body=[If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])], orelse=[])
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))]))
Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Attribute(value=Name(id='result', ctx=Load()), attr='total_counts', ctx=Store())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='counts', ctx=Load())], keywords=[])
Name(id='measurement', ctx=Store())
Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='factors', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[]))
If(test=Name(id='factors', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))), If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])], orelse=[])
Load()
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load())
Name(id='n', ctx=Load())
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Name(id='range', ctx=Load())
BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))
Name(id='k', ctx=Store())
BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))
Compare(left=Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load()), ops=[Eq()], comparators=[Str(s='1')])
AugAssign(target=Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store()), op=Add(), value=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[]))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='len', ctx=Load())
Name(id='angles', ctx=Load())
Str(s='phi_add_a')
Store()
Store()
Load()
Load()
Attribute(value=Name(id='circuit', ctx=Load()), attr='p', ctx=Load())
Name(id='angle', ctx=Load())
Name(id='i', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='len', ctx=Load())
Name(id='angles', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Str(s='ccphi_add_a_mod_N')
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load()), args=[Name(id='angles', ctx=Load())], keywords=[])
Load()
Name(id='cc_phi_add_a', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='flag_qreg', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='flag_qreg', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='n', ctx=Load())
Add()
Num(n=1)
Load()
Load()
Load()
Load()
Load()
Load()
Str(s='cmult_a_mod_N')
Load()
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Store()
BinOp(left=Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[]), op=Mult(), right=Name(id='constant', ctx=Load()))
Mod()
Name(id='N', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load())
Name(id='partial_constant', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))
Store()
Attribute(value=Name(id='adder', ctx=Load()), attr='assign_parameters', ctx=Load())
Dict(keys=[Name(id='angle_params', ctx=Load())], values=[Name(id='angles', ctx=Load())])
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='bound', ctx=Load())
List(elts=[Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load()), Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load()), Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='append_adder', ctx=Load())
Name(id='modulo_adder', ctx=Load())
Name(id='a', ctx=Load())
Name(id='i', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='circuit', ctx=Load()), attr='cswap', ctx=Load())
Name(id='ctrl_qreg', ctx=Load())
Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Subscript(value=Name(id='b_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='sys', ctx=Load()), attr='version_info', ctx=Load())
GtE()
Tuple(elts=[Num(n=3), Num(n=8)], ctx=Load())
Name(id='pow', ctx=Load())
Name(id='a', ctx=Load())
UnaryOp(op=USub(), operand=Num(n=1))
keyword(arg='mod', value=Name(id='N', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='modinv', ctx=Load())
Name(id='a', ctx=Load())
Name(id='N', ctx=Load())
Name(id='modulo_adder', ctx=Load())
Load()
Load()
Name(id='range', ctx=Load())
Name(id='n', ctx=Load())
Name(id='append_adder', ctx=Load())
Name(id='modulo_adder_inv', ctx=Load())
Name(id='a_inv', ctx=Load())
Name(id='i', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
Str(s='up')
Load()
Load()
Str(s='down')
Load()
Name(id='n', ctx=Load())
Add()
Num(n=2)
Str(s='aux')
Load()
Load()
Load()
Load()
JoinedStr(values=[FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s='^x mod '), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)])
Call(func=Name(id='QFT', ctx=Load()), args=[BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[keyword(arg='do_swaps', value=NameConstant(value=False))])
Load()
Name(id='qft', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_angles', ctx=Load())
Name(id='N', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))
Name(id='phi_add_N', ctx=Load())
Load()
Name(id='phi_add_N', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
Store()
Name(id='pow', ctx=Load())
Name(id='a', ctx=Load())
Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='i', ctx=Load())], keywords=[])
Name(id='N', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_controlled_multiple_mod_N', ctx=Load())
Name(id='n', ctx=Load())
Name(id='N', ctx=Load())
Name(id='partial_a', ctx=Load())
Name(id='c_phi_add_N', ctx=Load())
Name(id='iphi_add_N', ctx=Load())
Name(id='qft', ctx=Load())
Name(id='iqft', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='modulo_multiplier', ctx=Load())
List(elts=[Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()), Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load()), Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())], ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='N', ctx=Load())
Lt()
Num(n=1)
BinOp(left=Name(id='N', ctx=Load()), op=Mod(), right=Num(n=2))
Eq()
Num(n=0)
Name(id='ValueError', ctx=Load())
Str(s='The input needs to be an odd integer greater than 1.')
Name(id='a', ctx=Load())
GtE()
Name(id='N', ctx=Load())
Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])
NotEq()
Num(n=1)
Name(id='ValueError', ctx=Load())
Str(s='The integer a needs to satisfy a < N and gcd(a, N) = 1.')
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='N', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
Str(s='up')
Load()
Load()
Str(s='down')
Load()
Name(id='n', ctx=Load())
Add()
Num(n=2)
Str(s='aux')
Load()
Load()
Load()
Load()
JoinedStr(values=[Str(s='Shor(N='), FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None), Str(s=', a='), FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None), Str(s=')')])
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='down_qreg', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Call(func=Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load()), args=[], keywords=[])
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='ClassicalRegister', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
keyword(arg='name', value=Str(s='m'))
Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load())
Name(id='up_cqreg', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load())
Name(id='up_qreg', ctx=Load())
Name(id='up_cqreg', ctx=Load())
Name(id='logger', ctx=Load())
Load()
Name(id='summarize_circuits', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='a', ctx=Load())
Eq()
Num(n=0)
Tuple(elts=[Name(id='b', ctx=Load()), Num(n=0), Num(n=1)], ctx=Load())
Tuple(elts=[Name(id='g', ctx=Store()), Name(id='y', ctx=Store()), Name(id='x', ctx=Store())], ctx=Store())
Call(func=Name(id='egcd', ctx=Load()), args=[BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load())), Name(id='a', ctx=Load())], keywords=[])
Tuple(elts=[Name(id='g', ctx=Load()), BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))), Name(id='y', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='int', ctx=Load()), Name(id='int', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Store()
Store()
Store()
Load()
Load()
Load()
Load()
Name(id='ValueError', ctx=Load())
Call(func=Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='m', ctx=Load()), Name(id='g', ctx=Load())], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Store()
Store()
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Running continued fractions for this case.')
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='array', ctx=Load())
Load()
Name(id='array', ctx=Load())
Load()
Name(id='b', ctx=Load())
Load()
Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load())
Name(id='x_over_T', ctx=Load())
Name(id='t', ctx=Load())
Load()
Name(id='x_over_T', ctx=Load())
Sub()
Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Name(id='i', ctx=Load())
Lt()
Name(id='N', ctx=Load())
Name(id='fail_reason', ctx=Load())
Is()
NameConstant(value=None)
Name(id='i', ctx=Load())
Gt()
Num(n=0)
Call(func=Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_continued_fraction', ctx=Load())
Name(id='b', ctx=Load())
Store()
BinOp(left=Name(id='denominator', ctx=Load()), op=Mod(), right=Num(n=2))
Eq()
Num(n=1)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Odd denominator, will try next iteration of continued fractions.')], keywords=[])
Name(id='denominator', ctx=Load())
Lt()
Num(n=1000)
Name(id='exponential', ctx=Store())
Call(func=Name(id='pow', ctx=Load()), args=[Name(id='a', ctx=Load()), BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))], keywords=[])
Name(id='exponential', ctx=Load())
Gt()
Num(n=1000000000)
Name(id='fail_reason', ctx=Store())
Str(s='denominator of continued fraction is too big.')
Name(id='putting_plus', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Name(id='putting_minus', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Name(id='one_factor', ctx=Store())
Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_plus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])
Name(id='other_factor', ctx=Store())
Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load()), args=[Name(id='putting_minus', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])
Call(func=Name(id='any', ctx=Load()), args=[GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[]))
If(test=Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))], orelse=[])
Return(value=Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[]))
Name(id='logger', ctx=Load())
Load()
Load()
Or()
Name(id='fail_reason', ctx=Load())
Str(s='it took too many attempts.')
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='array', ctx=Load())
Load()
Load()
Name(id='range', ctx=Load())
BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[]), op=Sub(), right=Num(n=1))
Store()
Num(n=1)
Div()
BinOp(left=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load()), op=Add(), right=Name(id='x_over_T', ctx=Load()))
Load()
Num(n=0)
Call(func=Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load()), args=[Name(id='x_over_T', ctx=Load())], keywords=[])
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='b', ctx=Load())
Name(id='logger', ctx=Load())
Load()
Name(id='frac', ctx=Load())
Load()
Name(id='frac', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='A QuantumInstance or Backend must be supplied to run the quantum algorithm.')
Load()
Store()
Store()
Store()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='The input integer is a power: %s=%s^%s.')
Name(id='N', ctx=Load())
Name(id='b', ctx=Load())
Name(id='p', ctx=Load())
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load())
Name(id='b', ctx=Load())
Name(id='result', ctx=Load())
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Running with N=%s and a=%s.')
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='n', ctx=Store())
Call(func=Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load()), args=[], keywords=[])
Name(id='circuit', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=False))])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load()), args=[Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')], keywords=[])
Name(id='result', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='complete_state_vec', ctx=Store())
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='up_qreg_density_mat', ctx=Store())
Call(func=Name(id='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])], keywords=[])
Name(id='up_qreg_density_mat_diag', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='up_qreg_density_mat', ctx=Load())], keywords=[])
Name(id='counts', ctx=Store())
Dict(keys=[], values=[])
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='up_qreg_density_mat_diag', ctx=Load())], keywords=[])
If(test=UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])), body=[Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))], orelse=[])
Name(id='circuit', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[], keywords=[keyword(arg='N', value=Name(id='N', ctx=Load())), keyword(arg='a', value=Name(id='a', ctx=Load())), keyword(arg='measurement', value=NameConstant(value=True))])
Name(id='counts', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='result', ctx=Load())
Store()
Name(id='len', ctx=Load())
Name(id='counts', ctx=Load())
Store()
Name(id='list', ctx=Load())
Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='------> Analyzing result %s.'), Name(id='measurement', ctx=Load())], keywords=[])
Name(id='factors', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load()), args=[Name(id='N', ctx=Load()), Name(id='a', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])
Name(id='factors', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1)))
If(test=Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))], orelse=[])
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())
Load()
Load()
USub()
Num(n=1)
Load()
Load()
Name(id='i', ctx=Load())
Add()
Num(n=1)
Store()
Name(id='i', ctx=Load())
Sub()
Name(id='j', ctx=Load())
Subscript(value=Name(id='bits_little_endian', ctx=Load()), slice=Index(value=Name(id='j', ctx=Load())), ctx=Load())
Eq()
Str(s='1')
Subscript(value=Name(id='angles', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Store())
Add()
Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))], keywords=[])
Load()
Load()
Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='ParameterVector', ctx=Load())], ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_phi_add_gate', ctx=Load())
Name(id='angles', ctx=Load())
Load()
Load()
Name(id='ctrl_qreg', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Load()
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Num(n=0)
Load()
Load()
Name(id='flag_qreg', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Load()
Load()
Name(id='ctrl_qreg', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Num(n=0)
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Load()
Name(id='ctrl_qreg', ctx=Load())
Load()
Name(id='b_qreg', ctx=Load())
Load()
Load()
Name(id='n', ctx=Load())
Add()
Num(n=1)
Load()
Load()
Load()
Load()
Call(func=Name(id='pow', ctx=Load()), args=[Num(n=2), Name(id='idx', ctx=Load()), Name(id='N', ctx=Load())], keywords=[])
Mult()
Name(id='constant', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='n', ctx=Load())
Add()
Num(n=1)
Name(id='adder', ctx=Load())
Load()
Name(id='angle_params', ctx=Load())
Name(id='angles', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Starred(value=Name(id='ctrl_qreg', ctx=Load()), ctx=Load())
Subscript(value=Name(id='x_qreg', ctx=Load()), slice=Index(value=Name(id='idx', ctx=Load())), ctx=Load())
Starred(value=Name(id='b_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='flag_qreg', ctx=Load()), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='x_qreg', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='b_qreg', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Load()
Name(id='sys', ctx=Load())
Load()
Num(n=3)
Num(n=8)
Load()
Load()
Load()
USub()
Num(n=1)
Name(id='N', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None)
Str(s='^x mod ')
FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)
Name(id='QFT', ctx=Load())
BinOp(left=Name(id='n', ctx=Load()), op=Add(), right=Num(n=1))
keyword(arg='do_swaps', value=NameConstant(value=False))
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='n', ctx=Load())
Add()
Num(n=1)
Load()
Load()
Load()
Load()
Load()
Name(id='pow', ctx=Load())
Num(n=2)
Name(id='i', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Subscript(value=Name(id='up_qreg', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Starred(value=Name(id='down_qreg', ctx=Load()), ctx=Load())
Starred(value=Name(id='aux_qreg', ctx=Load()), ctx=Load())
Load()
Load()
Load()
Name(id='N', ctx=Load())
Mod()
Num(n=2)
Load()
Load()
Load()
Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load())
Name(id='a', ctx=Load())
Name(id='N', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Str(s='Shor(N=')
FormattedValue(value=Name(id='N', ctx=Load()), conversion=-1, format_spec=None)
Str(s=', a=')
FormattedValue(value=Name(id='a', ctx=Load()), conversion=-1, format_spec=None)
Str(s=')')
Load()
Load()
Load()
Num(n=0)
Load()
Load()
Load()
Attribute(value=Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[]), attr='inverse', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
Str(s='m')
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='b', ctx=Load())
Num(n=0)
Num(n=1)
Load()
Name(id='g', ctx=Store())
Name(id='y', ctx=Store())
Name(id='x', ctx=Store())
Store()
Name(id='egcd', ctx=Load())
BinOp(left=Name(id='b', ctx=Load()), op=Mod(), right=Name(id='a', ctx=Load()))
Name(id='a', ctx=Load())
Name(id='g', ctx=Load())
BinOp(left=Name(id='x', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load())))
Name(id='y', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Load()
Load()
Attribute(value=Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.'), attr='format', ctx=Load())
Name(id='a', ctx=Load())
Name(id='m', ctx=Load())
Name(id='g', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='math', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='b', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='b', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))], keywords=[])
Attribute(value=Name(id='t', ctx=Load()), attr='append', ctx=Load())
BinOp(left=BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())), op=Sub(), right=Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load()))
Name(id='self', ctx=Load())
Load()
Load()
Name(id='denominator', ctx=Load())
Mod()
Num(n=2)
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Odd denominator, will try next iteration of continued fractions.')
Load()
Store()
Name(id='pow', ctx=Load())
Name(id='a', ctx=Load())
BinOp(left=Name(id='denominator', ctx=Load()), op=Div(), right=Num(n=2))
Load()
Store()
Store()
Name(id='int', ctx=Load())
BinOp(left=Name(id='exponential', ctx=Load()), op=Add(), right=Num(n=1))
Store()
Name(id='int', ctx=Load())
BinOp(left=Name(id='exponential', ctx=Load()), op=Sub(), right=Num(n=1))
Store()
Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load())
Name(id='putting_plus', ctx=Load())
Name(id='N', ctx=Load())
Store()
Attribute(value=Name(id='math', ctx=Load()), attr='gcd', ctx=Load())
Name(id='putting_minus', ctx=Load())
Name(id='N', ctx=Load())
Name(id='any', ctx=Load())
GeneratorExp(elt=Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])]), generators=[comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Found just trivial factors, not good enough.')], keywords=[])
Compare(left=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Assign(targets=[Name(id='fail_reason', ctx=Store())], value=Str(s='the continued fractions found exactly x_final/(2^(2n)).'))
Call(func=Name(id='sorted', ctx=Load()), args=[Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())], keywords=[])
Load()
Load()
Load()
Name(id='int', ctx=Load())
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='b', ctx=Load())], keywords=[])
Sub()
Num(n=1)
Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))), ctx=Load())
Add()
Name(id='x_over_T', ctx=Load())
Attribute(value=Name(id='fractions', ctx=Load()), attr='Fraction', ctx=Load())
Name(id='x_over_T', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='N', ctx=Load()), attr='bit_length', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
keyword(arg='N', value=Name(id='N', ctx=Load()))
keyword(arg='a', value=Name(id='a', ctx=Load()))
keyword(arg='measurement', value=NameConstant(value=False))
Attribute(value=Name(id='logger', ctx=Load()), attr='warning', ctx=Load())
Str(s='The statevector_simulator might lead to subsequent computation using too much memory.')
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Name(id='partial_trace', ctx=Load())
Name(id='complete_state_vec', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load())), BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))], keywords=[])
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='diag', ctx=Load())
Name(id='up_qreg_density_mat', ctx=Load())
Store()
Name(id='i', ctx=Store())
Name(id='v', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='up_qreg_density_mat_diag', ctx=Load())
UnaryOp(op=Not(), operand=Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)]))
Assign(targets=[Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())], value=BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2)))
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
keyword(arg='N', value=Name(id='N', ctx=Load()))
keyword(arg='a', value=Name(id='a', ctx=Load()))
keyword(arg='measurement', value=NameConstant(value=True))
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='------> Analyzing result %s.')
Name(id='measurement', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_factors', ctx=Load())
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Name(id='measurement', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Found factors %s from measurement %s.'), Name(id='factors', ctx=Load()), Name(id='measurement', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Store())
BinOp(left=Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load()), op=Add(), right=Num(n=1))
Compare(left=Name(id='factors', ctx=Load()), ops=[NotIn()], comparators=[Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())])
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[]))
Name(id='super', ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])], keywords=[])
Slice(lower=Num(n=2), upper=None, step=None)
Load()
Load()
Load()
Load()
Name(id='bits_little_endian', ctx=Load())
Index(value=Name(id='j', ctx=Load()))
Load()
Name(id='angles', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Store()
Name(id='pow', ctx=Load())
Num(n=2)
UnaryOp(op=USub(), operand=Name(id='k', ctx=Load()))
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='ParameterVector', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='ParameterVector', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
USub()
Num(n=1)
Load()
Load()
Load()
Load()
USub()
Num(n=1)
USub()
Num(n=1)
USub()
Num(n=1)
Load()
Load()
Load()
Name(id='pow', ctx=Load())
Num(n=2)
Name(id='idx', ctx=Load())
Name(id='N', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='ctrl_qreg', ctx=Load())
Load()
Name(id='x_qreg', ctx=Load())
Index(value=Name(id='idx', ctx=Load()))
Load()
Name(id='b_qreg', ctx=Load())
Load()
Name(id='flag_qreg', ctx=Load())
Load()
Load()
Load()
Name(id='i', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
Load()
Load()
Name(id='a', ctx=Load())
Name(id='N', ctx=Load())
Load()
Name(id='n', ctx=Load())
Add()
Num(n=1)
NameConstant(value=False)
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='up_qreg', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Name(id='down_qreg', ctx=Load())
Load()
Name(id='aux_qreg', ctx=Load())
Load()
Load()
Name(id='math', ctx=Load())
Load()
Load()
Load()
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
Call(func=Name(id='QFT', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])], keywords=[])
Load()
Load()
Load()
Load()
Load()
Store()
Store()
Store()
Load()
Name(id='b', ctx=Load())
Mod()
Name(id='a', ctx=Load())
Load()
Load()
Name(id='x', ctx=Load())
Sub()
BinOp(left=BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load())), op=Mult(), right=Name(id='y', ctx=Load()))
Load()
Load()
Load()
Load()
Str(s='The greatest common divisor of {} and {} is {}, so the modular inverse does not exist.')
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Name(id='b', ctx=Load())
Load()
Attribute(value=Name(id='math', ctx=Load()), attr='floor', ctx=Load())
BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))
Name(id='t', ctx=Load())
Load()
BinOp(left=Num(n=1), op=Div(), right=Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load()))
Sub()
Subscript(value=Name(id='b', ctx=Load()), slice=Index(value=Name(id='i', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Name(id='denominator', ctx=Load())
Div()
Num(n=2)
Load()
Name(id='exponential', ctx=Load())
Add()
Num(n=1)
Load()
Name(id='exponential', ctx=Load())
Sub()
Num(n=1)
Name(id='math', ctx=Load())
Load()
Load()
Load()
Name(id='math', ctx=Load())
Load()
Load()
Load()
Load()
Compare(left=Name(id='factor', ctx=Load()), ops=[In()], comparators=[Set(elts=[Num(n=1), Name(id='N', ctx=Load())])])
comprehension(target=Name(id='factor', ctx=Store()), iter=Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load()), ifs=[], is_async=0)
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Found just trivial factors, not good enough.')
Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())
Eq()
Num(n=0)
Name(id='fail_reason', ctx=Store())
Str(s='the continued fractions found exactly x_final/(2^(2n)).')
Name(id='sorted', ctx=Load())
Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='b', ctx=Load())
Name(id='b', ctx=Load())
Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))
Load()
Load()
Name(id='fractions', ctx=Load())
Load()
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Name(id='N', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
NameConstant(value=False)
Name(id='logger', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='range', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load())), op=Add(), right=Num(n=2))
Name(id='np', ctx=Load())
Load()
Load()
Store()
Store()
Load()
Load()
Not()
Compare(left=Name(id='v', ctx=Load()), ops=[Eq()], comparators=[Num(n=0)])
Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])), ctx=Store())
BinOp(left=Name(id='v', ctx=Load()), op=Pow(), right=Num(n=2))
Name(id='self', ctx=Load())
Load()
Name(id='N', ctx=Load())
Name(id='a', ctx=Load())
NameConstant(value=True)
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Load()
Load()
Name(id='counts', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Found factors %s from measurement %s.')
Name(id='factors', ctx=Load())
Name(id='measurement', ctx=Load())
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='result', ctx=Load()), attr='successful_counts', ctx=Load())
Add()
Num(n=1)
Name(id='factors', ctx=Load())
NotIn()
Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='factors', ctx=Load())], keywords=[])
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='bin', ctx=Load())
Call(func=Name(id='int', ctx=Load()), args=[Name(id='a', ctx=Load())], keywords=[])
Num(n=2)
Load()
Name(id='j', ctx=Load())
Load()
Name(id='i', ctx=Load())
Load()
USub()
Name(id='k', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='idx', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='QFT', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='up_qreg', ctx=Load())], keywords=[])
Load()
Load()
Load()
BinOp(left=Name(id='b', ctx=Load()), op=FloorDiv(), right=Name(id='a', ctx=Load()))
Mult()
Name(id='y', ctx=Load())
Load()
Load()
Name(id='math', ctx=Load())
Load()
Num(n=1)
Div()
Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())
Load()
Num(n=1)
Div()
Subscript(value=Name(id='t', ctx=Load()), slice=Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))), ctx=Load())
Name(id='b', ctx=Load())
Index(value=Name(id='i', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='factor', ctx=Load())
In()
Set(elts=[Num(n=1), Name(id='N', ctx=Load())])
Name(id='factor', ctx=Store())
Tuple(elts=[Name(id='one_factor', ctx=Load()), Name(id='other_factor', ctx=Load())], ctx=Load())
Name(id='logger', ctx=Load())
Load()
Name(id='t', ctx=Load())
Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1)))
Load()
Store()
Load()
Name(id='one_factor', ctx=Load())
Name(id='other_factor', ctx=Load())
Load()
Load()
Load()
Load()
BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
BinOp(left=Num(n=4), op=Mult(), right=Name(id='n', ctx=Load()))
Add()
Num(n=2)
Load()
Name(id='v', ctx=Load())
Eq()
Num(n=0)
Name(id='counts', ctx=Load())
Index(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[]))
Store()
Name(id='v', ctx=Load())
Pow()
Num(n=2)
Load()
Load()
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load()), attr='append', ctx=Load())
Name(id='factors', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Name(id='a', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='len', ctx=Load())
Name(id='up_qreg', ctx=Load())
Name(id='b', ctx=Load())
FloorDiv()
Name(id='a', ctx=Load())
Load()
Load()
Name(id='t', ctx=Load())
Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1)))
Load()
Name(id='t', ctx=Load())
Index(value=BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1)))
Load()
Load()
Name(id='i', ctx=Load())
Load()
Num(n=1)
Name(id='N', ctx=Load())
Store()
Name(id='one_factor', ctx=Load())
Name(id='other_factor', ctx=Load())
Load()
Load()
Load()
BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))
Load()
Load()
Name(id='i', ctx=Load())
Add()
Num(n=1)
Load()
Load()
Num(n=4)
Mult()
Name(id='n', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))], keywords=[])
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='factors', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))
Load()
BinOp(left=Name(id='i', ctx=Load()), op=Sub(), right=Num(n=1))
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Sub()
Num(n=1)
Load()
Load()
Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='n', ctx=Load()))
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Load()
Name(id='i', ctx=Load())
Sub()
Num(n=1)
Name(id='i', ctx=Load())
Sub()
Num(n=1)
Load()
Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())
Load()
Num(n=2)
Mult()
Name(id='n', ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Name(id='bin', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])], keywords=[])
Slice(lower=Num(n=2), upper=None, step=None)
Load()
Load()
Name(id='bin', ctx=Load())
Call(func=Name(id='int', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])
Num(n=2)
Load()
Name(id='int', ctx=Load())
Name(id='i', ctx=Load())
Load()
Load()
  metric  value
0     NC      2
DONE!
