Python 3.7.8
Module(body=[Expr(value=Str(s='The Iterative Quantum Amplitude Estimation Algorithm.')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None), alias(name='Dict', asname=None), alias(name='cast', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='scipy.stats', names=[alias(name='beta', asname=None)], level=0), ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='amplitude_estimator', names=[alias(name='AmplitudeEstimator', asname=None), alias(name='AmplitudeEstimatorResult', asname=None)], level=1), ImportFrom(module='estimation_problem', names=[alias(name='EstimationProblem', asname=None)], level=1), ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2), ClassDef(name='IterativeAmplitudeEstimation', bases=[Name(id='AmplitudeEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s="The Iterative Amplitude Estimation algorithm.\n\n    This class implements the Iterative Quantum Amplitude Estimation (IQAE) algorithm, proposed\n    in [1]. The output of the algorithm is an estimate that,\n    with at least probability :math:`1 - \\alpha`, differs by epsilon to the target value, where\n    both alpha and epsilon can be specified.\n\n    It differs from the original QAE algorithm proposed by Brassard [2] in that it does not rely on\n    Quantum Phase Estimation, but is only based on Grover's algorithm. IQAE iteratively\n    applies carefully selected Grover iterations to find an estimate for the target amplitude.\n\n    References:\n        [1]: Grinko, D., Gacon, J., Zoufal, C., & Woerner, S. (2019).\n             Iterative Quantum Amplitude Estimation.\n             `arXiv:1912.05559 <https://arxiv.org/abs/1912.05559>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon_target', annotation=Name(id='float', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='confint_method', annotation=Name(id='str', ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='beta'), Num(n=2), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        The output of the algorithm is an estimate for the amplitude `a`, that with at least\n        probability 1 - alpha has an error of epsilon. The number of A operator calls scales\n        linearly in 1/epsilon (up to a logarithmic factor).\n\n        Args:\n            epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n            alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n            confint_method: Statistical method used to estimate the confidence intervals in\n                each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n                Clopper-Pearson intervals (default)\n            min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            AlgorithmError: if the method to compute the confidence intervals is not supported\n            ValueError: If the target epsilon is not in (0, 0.5]\n            ValueError: If alpha is not in (0, 1)\n            ValueError: If confint_method is not supported\n        ")), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='confint_method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Str(s='chernoff'), Str(s='beta')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon_target', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Store())], value=Name(id='min_ratio', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Store())], value=Name(id='confint_method', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the target precision ``epsilon_target`` of the algorithm.\n\n        Returns:\n            The target precision (which is half the width of the confidence interval).\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target precision of the algorithm.\n\n        Args:\n            epsilon: Target precision for estimation target `a`.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_find_next_k', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='upper_half_circle', annotation=Name(id='bool', ctx=Load())), arg(arg='theta_interval', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2.0)]), body=[Expr(value=Str(s='Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\n        lies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\n        Args:\n            k: The current power of the Q operator.\n            upper_half_circle: Boolean flag of whether theta_interval lies in the\n                upper half-circle [0, pi] or in the lower one [pi, 2pi].\n            theta_interval: The current confidence interval for the angle theta,\n                i.e. (theta_lower, theta_upper).\n            min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\n        Returns:\n            The next power k, and boolean flag for the extrapolated interval.\n\n        Raises:\n            AlgorithmError: if min_ratio is smaller or equal to 1\n        ')), If(test=Compare(left=Name(id='min_ratio', ctx=Load()), ops=[LtE()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='theta_l', ctx=Store()), Name(id='theta_u', ctx=Store())], ctx=Store())], value=Name(id='theta_interval', ctx=Load())), Assign(targets=[Name(id='old_scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='max_scaling', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))], keywords=[])), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4)))), While(test=Compare(left=Name(id='scaling', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))]), body=[Assign(targets=[Name(id='theta_min', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]))), Assign(targets=[Name(id='theta_max', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])]), AugAssign(target=Name(id='scaling', ctx=Store()), op=Sub(), value=Num(n=4))], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\n        The A operator is the unitary specifying the QAE problem and Q the associated Grover\n        operator.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            k: The power of the Q operator.\n            measurement: Boolean flag to indicate if measurements should be included in the\n                circuits.\n\n        Returns:\n            The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n        ')), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='circuit'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_good_state_probability', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='counts_or_statevector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Get the probability to measure '1' in the last qubit.\n\n        Args:\n            problem: The estimation problem, used to obtain the number of objective qubits and\n                the ``is_good_state`` function.\n            counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n                the statevector returned from the statevector_simulator.\n            num_state_qubits: The number of state qubits.\n\n        Returns:\n            If a dict is given, return (#one-counts, #one-counts/#all-counts),\n            otherwise Pr(measure '1' in the last qubit).\n        ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='counts_or_statevector', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='one_counts', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load()))], orelse=[Assign(targets=[Name(id='statevector', ctx=Store())], value=Name(id='counts_or_statevector', ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])], orelse=[]), Return(value=Name(id='prob', ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='powers', ctx=Store())], value=List(elts=[Num(n=0)], ctx=Load())), Assign(targets=[Name(id='ratios', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='theta_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='a_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='num_one_shots', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_rounds', ctx=Store())], value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[]), op=Add(), right=Num(n=1))), Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevector', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_confidence_interval', ctx=Store())], value=List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta_i_interval', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))], orelse=[Assign(targets=[Name(id='num_iterations', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())), While(test=Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))]), body=[AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1)), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load())), Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))]), If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))]), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='estimation', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='IterativeAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='alpha', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=Name(id='num_oracle_queries', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=Name(id='estimation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='estimation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated_processed', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimate_intervals', ctx=Store())], value=Name(id='a_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta_intervals', ctx=Store())], value=Name(id='theta_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='powers', ctx=Store())], value=Name(id='powers', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='ratios', ctx=Store())], value=Name(id='ratios', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='IterativeAmplitudeEstimationResult'))], decorator_list=[]), ClassDef(name='IterativeAmplitudeEstimationResult', bases=[Name(id='AmplitudeEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The ``IterativeAmplitudeEstimation`` result object.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence level :math:`\\alpha`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence level :math:`\\alpha`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='alpha', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the target half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the estimate in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the estimate in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='estimate_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the angles in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the angles in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the powers of the Grover operator in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='powers', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ratios', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='confidence_interval_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[]), FunctionDef(name='_chernoff_confint', args=arguments(args=[arg(arg='value', annotation=Name(id='float', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='max_rounds', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute the Chernoff confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    The confidence interval is\n\n        [value - eps, value + eps], where eps = sqrt(3 * log(2 * max_rounds/ alpha) / shots)\n\n    but at most [0, 1].\n\n    Args:\n        value: The current estimate.\n        shots: The number of shots.\n        max_rounds: The maximum number of rounds, used to compute epsilon_a.\n        alpha: The confidence level, used to compute epsilon_a.\n\n    Returns:\n        The Chernoff confidence interval.\n    ')), Assign(targets=[Name(id='eps', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])), op=Div(), right=Name(id='shots', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='maximum', ctx=Load()), args=[Num(n=0), BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='eps', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='minimum', ctx=Load()), args=[Num(n=1), BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='eps', ctx=Load()))], keywords=[])), Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_clopper_pearson_confint', args=arguments(args=[arg(arg='counts', annotation=Name(id='int', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute the Clopper-Pearson confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    Args:\n        counts: The number of positive counts.\n        shots: The number of shots.\n        alpha: The confidence level for the confidence interval.\n\n    Returns:\n        The Clopper-Pearson confidence interval.\n    ')), Assign(targets=[Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store())], value=Tuple(elts=[Num(n=0), Num(n=1)], ctx=Load())), If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)), Name(id='counts', ctx=Load()), BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Name(id='shots', ctx=Load())]), body=[Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))), BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1)), BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))])
Expr(value=Str(s='The Iterative Quantum Amplitude Estimation Algorithm.'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None), alias(name='Dict', asname=None), alias(name='cast', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='scipy.stats', names=[alias(name='beta', asname=None)], level=0)
ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='amplitude_estimator', names=[alias(name='AmplitudeEstimator', asname=None), alias(name='AmplitudeEstimatorResult', asname=None)], level=1)
ImportFrom(module='estimation_problem', names=[alias(name='EstimationProblem', asname=None)], level=1)
ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2)
ClassDef(name='IterativeAmplitudeEstimation', bases=[Name(id='AmplitudeEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s="The Iterative Amplitude Estimation algorithm.\n\n    This class implements the Iterative Quantum Amplitude Estimation (IQAE) algorithm, proposed\n    in [1]. The output of the algorithm is an estimate that,\n    with at least probability :math:`1 - \\alpha`, differs by epsilon to the target value, where\n    both alpha and epsilon can be specified.\n\n    It differs from the original QAE algorithm proposed by Brassard [2] in that it does not rely on\n    Quantum Phase Estimation, but is only based on Grover's algorithm. IQAE iteratively\n    applies carefully selected Grover iterations to find an estimate for the target amplitude.\n\n    References:\n        [1]: Grinko, D., Gacon, J., Zoufal, C., & Woerner, S. (2019).\n             Iterative Quantum Amplitude Estimation.\n             `arXiv:1912.05559 <https://arxiv.org/abs/1912.05559>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon_target', annotation=Name(id='float', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='confint_method', annotation=Name(id='str', ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='beta'), Num(n=2), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        The output of the algorithm is an estimate for the amplitude `a`, that with at least\n        probability 1 - alpha has an error of epsilon. The number of A operator calls scales\n        linearly in 1/epsilon (up to a logarithmic factor).\n\n        Args:\n            epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n            alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n            confint_method: Statistical method used to estimate the confidence intervals in\n                each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n                Clopper-Pearson intervals (default)\n            min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            AlgorithmError: if the method to compute the confidence intervals is not supported\n            ValueError: If the target epsilon is not in (0, 0.5]\n            ValueError: If alpha is not in (0, 1)\n            ValueError: If confint_method is not supported\n        ")), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='confint_method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Str(s='chernoff'), Str(s='beta')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon_target', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Store())], value=Name(id='min_ratio', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Store())], value=Name(id='confint_method', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the target precision ``epsilon_target`` of the algorithm.\n\n        Returns:\n            The target precision (which is half the width of the confidence interval).\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target precision of the algorithm.\n\n        Args:\n            epsilon: Target precision for estimation target `a`.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_find_next_k', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='upper_half_circle', annotation=Name(id='bool', ctx=Load())), arg(arg='theta_interval', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2.0)]), body=[Expr(value=Str(s='Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\n        lies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\n        Args:\n            k: The current power of the Q operator.\n            upper_half_circle: Boolean flag of whether theta_interval lies in the\n                upper half-circle [0, pi] or in the lower one [pi, 2pi].\n            theta_interval: The current confidence interval for the angle theta,\n                i.e. (theta_lower, theta_upper).\n            min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\n        Returns:\n            The next power k, and boolean flag for the extrapolated interval.\n\n        Raises:\n            AlgorithmError: if min_ratio is smaller or equal to 1\n        ')), If(test=Compare(left=Name(id='min_ratio', ctx=Load()), ops=[LtE()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='theta_l', ctx=Store()), Name(id='theta_u', ctx=Store())], ctx=Store())], value=Name(id='theta_interval', ctx=Load())), Assign(targets=[Name(id='old_scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='max_scaling', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))], keywords=[])), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4)))), While(test=Compare(left=Name(id='scaling', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))]), body=[Assign(targets=[Name(id='theta_min', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]))), Assign(targets=[Name(id='theta_max', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])]), AugAssign(target=Name(id='scaling', ctx=Store()), op=Sub(), value=Num(n=4))], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\n        The A operator is the unitary specifying the QAE problem and Q the associated Grover\n        operator.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            k: The power of the Q operator.\n            measurement: Boolean flag to indicate if measurements should be included in the\n                circuits.\n\n        Returns:\n            The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n        ')), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='circuit'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_good_state_probability', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='counts_or_statevector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Get the probability to measure '1' in the last qubit.\n\n        Args:\n            problem: The estimation problem, used to obtain the number of objective qubits and\n                the ``is_good_state`` function.\n            counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n                the statevector returned from the statevector_simulator.\n            num_state_qubits: The number of state qubits.\n\n        Returns:\n            If a dict is given, return (#one-counts, #one-counts/#all-counts),\n            otherwise Pr(measure '1' in the last qubit).\n        ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='counts_or_statevector', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='one_counts', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load()))], orelse=[Assign(targets=[Name(id='statevector', ctx=Store())], value=Name(id='counts_or_statevector', ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])], orelse=[]), Return(value=Name(id='prob', ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='powers', ctx=Store())], value=List(elts=[Num(n=0)], ctx=Load())), Assign(targets=[Name(id='ratios', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='theta_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='a_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='num_one_shots', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_rounds', ctx=Store())], value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[]), op=Add(), right=Num(n=1))), Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevector', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_confidence_interval', ctx=Store())], value=List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta_i_interval', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))], orelse=[Assign(targets=[Name(id='num_iterations', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())), While(test=Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))]), body=[AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1)), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load())), Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))]), If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))]), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='estimation', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='IterativeAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='alpha', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=Name(id='num_oracle_queries', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=Name(id='estimation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='estimation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated_processed', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimate_intervals', ctx=Store())], value=Name(id='a_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta_intervals', ctx=Store())], value=Name(id='theta_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='powers', ctx=Store())], value=Name(id='powers', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='ratios', ctx=Store())], value=Name(id='ratios', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='IterativeAmplitudeEstimationResult'))], decorator_list=[])
ClassDef(name='IterativeAmplitudeEstimationResult', bases=[Name(id='AmplitudeEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The ``IterativeAmplitudeEstimation`` result object.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence level :math:`\\alpha`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence level :math:`\\alpha`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='alpha', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the target half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the estimate in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the estimate in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='estimate_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the angles in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the angles in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the powers of the Grover operator in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='powers', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ratios', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='confidence_interval_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
FunctionDef(name='_chernoff_confint', args=arguments(args=[arg(arg='value', annotation=Name(id='float', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='max_rounds', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute the Chernoff confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    The confidence interval is\n\n        [value - eps, value + eps], where eps = sqrt(3 * log(2 * max_rounds/ alpha) / shots)\n\n    but at most [0, 1].\n\n    Args:\n        value: The current estimate.\n        shots: The number of shots.\n        max_rounds: The maximum number of rounds, used to compute epsilon_a.\n        alpha: The confidence level, used to compute epsilon_a.\n\n    Returns:\n        The Chernoff confidence interval.\n    ')), Assign(targets=[Name(id='eps', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])), op=Div(), right=Name(id='shots', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='maximum', ctx=Load()), args=[Num(n=0), BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='eps', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='minimum', ctx=Load()), args=[Num(n=1), BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='eps', ctx=Load()))], keywords=[])), Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='_clopper_pearson_confint', args=arguments(args=[arg(arg='counts', annotation=Name(id='int', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute the Clopper-Pearson confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    Args:\n        counts: The number of positive counts.\n        shots: The number of shots.\n        alpha: The confidence level for the confidence interval.\n\n    Returns:\n        The Clopper-Pearson confidence interval.\n    ')), Assign(targets=[Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store())], value=Tuple(elts=[Num(n=0), Num(n=1)], ctx=Load())), If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)), Name(id='counts', ctx=Load()), BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Name(id='shots', ctx=Load())]), body=[Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))), BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1)), BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='The Iterative Quantum Amplitude Estimation Algorithm.')
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='List', asname=None)
alias(name='Tuple', asname=None)
alias(name='Dict', asname=None)
alias(name='cast', asname=None)
alias(name='numpy', asname='np')
alias(name='beta', asname=None)
alias(name='ClassicalRegister', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='Backend', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='AmplitudeEstimator', asname=None)
alias(name='AmplitudeEstimatorResult', asname=None)
alias(name='EstimationProblem', asname=None)
alias(name='AlgorithmError', asname=None)
Name(id='AmplitudeEstimator', ctx=Load())
Expr(value=Str(s="The Iterative Amplitude Estimation algorithm.\n\n    This class implements the Iterative Quantum Amplitude Estimation (IQAE) algorithm, proposed\n    in [1]. The output of the algorithm is an estimate that,\n    with at least probability :math:`1 - \\alpha`, differs by epsilon to the target value, where\n    both alpha and epsilon can be specified.\n\n    It differs from the original QAE algorithm proposed by Brassard [2] in that it does not rely on\n    Quantum Phase Estimation, but is only based on Grover's algorithm. IQAE iteratively\n    applies carefully selected Grover iterations to find an estimate for the target amplitude.\n\n    References:\n        [1]: Grinko, D., Gacon, J., Zoufal, C., & Woerner, S. (2019).\n             Iterative Quantum Amplitude Estimation.\n             `arXiv:1912.05559 <https://arxiv.org/abs/1912.05559>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    "))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon_target', annotation=Name(id='float', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='confint_method', annotation=Name(id='str', ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='beta'), Num(n=2), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        The output of the algorithm is an estimate for the amplitude `a`, that with at least\n        probability 1 - alpha has an error of epsilon. The number of A operator calls scales\n        linearly in 1/epsilon (up to a logarithmic factor).\n\n        Args:\n            epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n            alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n            confint_method: Statistical method used to estimate the confidence intervals in\n                each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n                Clopper-Pearson intervals (default)\n            min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            AlgorithmError: if the method to compute the confidence intervals is not supported\n            ValueError: If the target epsilon is not in (0, 0.5]\n            ValueError: If alpha is not in (0, 1)\n            ValueError: If confint_method is not supported\n        ")), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='confint_method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Str(s='chernoff'), Str(s='beta')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon_target', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Store())], value=Name(id='min_ratio', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Store())], value=Name(id='confint_method', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the target precision ``epsilon_target`` of the algorithm.\n\n        Returns:\n            The target precision (which is half the width of the confidence interval).\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target precision of the algorithm.\n\n        Args:\n            epsilon: Target precision for estimation target `a`.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='_find_next_k', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='upper_half_circle', annotation=Name(id='bool', ctx=Load())), arg(arg='theta_interval', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2.0)]), body=[Expr(value=Str(s='Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\n        lies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\n        Args:\n            k: The current power of the Q operator.\n            upper_half_circle: Boolean flag of whether theta_interval lies in the\n                upper half-circle [0, pi] or in the lower one [pi, 2pi].\n            theta_interval: The current confidence interval for the angle theta,\n                i.e. (theta_lower, theta_upper).\n            min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\n        Returns:\n            The next power k, and boolean flag for the extrapolated interval.\n\n        Raises:\n            AlgorithmError: if min_ratio is smaller or equal to 1\n        ')), If(test=Compare(left=Name(id='min_ratio', ctx=Load()), ops=[LtE()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='theta_l', ctx=Store()), Name(id='theta_u', ctx=Store())], ctx=Store())], value=Name(id='theta_interval', ctx=Load())), Assign(targets=[Name(id='old_scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='max_scaling', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))], keywords=[])), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4)))), While(test=Compare(left=Name(id='scaling', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))]), body=[Assign(targets=[Name(id='theta_min', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]))), Assign(targets=[Name(id='theta_max', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])]), AugAssign(target=Name(id='scaling', ctx=Store()), op=Sub(), value=Num(n=4))], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\n        The A operator is the unitary specifying the QAE problem and Q the associated Grover\n        operator.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            k: The power of the Q operator.\n            measurement: Boolean flag to indicate if measurements should be included in the\n                circuits.\n\n        Returns:\n            The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n        ')), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='circuit'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='_good_state_probability', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='counts_or_statevector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Get the probability to measure '1' in the last qubit.\n\n        Args:\n            problem: The estimation problem, used to obtain the number of objective qubits and\n                the ``is_good_state`` function.\n            counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n                the statevector returned from the statevector_simulator.\n            num_state_qubits: The number of state qubits.\n\n        Returns:\n            If a dict is given, return (#one-counts, #one-counts/#all-counts),\n            otherwise Pr(measure '1' in the last qubit).\n        ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='counts_or_statevector', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='one_counts', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load()))], orelse=[Assign(targets=[Name(id='statevector', ctx=Store())], value=Name(id='counts_or_statevector', ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])], orelse=[]), Return(value=Name(id='prob', ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='powers', ctx=Store())], value=List(elts=[Num(n=0)], ctx=Load())), Assign(targets=[Name(id='ratios', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='theta_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='a_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='num_one_shots', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_rounds', ctx=Store())], value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[]), op=Add(), right=Num(n=1))), Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevector', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_confidence_interval', ctx=Store())], value=List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta_i_interval', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))], orelse=[Assign(targets=[Name(id='num_iterations', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())), While(test=Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))]), body=[AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1)), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load())), Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))]), If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))]), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='estimation', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='IterativeAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='alpha', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=Name(id='num_oracle_queries', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=Name(id='estimation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='estimation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated_processed', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimate_intervals', ctx=Store())], value=Name(id='a_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta_intervals', ctx=Store())], value=Name(id='theta_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='powers', ctx=Store())], value=Name(id='powers', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='ratios', ctx=Store())], value=Name(id='ratios', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='IterativeAmplitudeEstimationResult'))
Name(id='AmplitudeEstimatorResult', ctx=Load())
Expr(value=Str(s='The ``IterativeAmplitudeEstimation`` result object.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence level :math:`\\alpha`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence level :math:`\\alpha`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='alpha', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the target half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the estimate in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the estimate in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='estimate_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the angles in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the angles in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the powers of the Grover operator in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='powers', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ratios', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='confidence_interval_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
arguments(args=[arg(arg='value', annotation=Name(id='float', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='max_rounds', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Compute the Chernoff confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    The confidence interval is\n\n        [value - eps, value + eps], where eps = sqrt(3 * log(2 * max_rounds/ alpha) / shots)\n\n    but at most [0, 1].\n\n    Args:\n        value: The current estimate.\n        shots: The number of shots.\n        max_rounds: The maximum number of rounds, used to compute epsilon_a.\n        alpha: The confidence level, used to compute epsilon_a.\n\n    Returns:\n        The Chernoff confidence interval.\n    '))
Assign(targets=[Name(id='eps', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])), op=Div(), right=Name(id='shots', ctx=Load()))], keywords=[]))
Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='maximum', ctx=Load()), args=[Num(n=0), BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='eps', ctx=Load()))], keywords=[]))
Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='minimum', ctx=Load()), args=[Num(n=1), BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='eps', ctx=Load()))], keywords=[]))
Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='counts', annotation=Name(id='int', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Compute the Clopper-Pearson confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    Args:\n        counts: The number of positive counts.\n        shots: The number of shots.\n        alpha: The confidence level for the confidence interval.\n\n    Returns:\n        The Clopper-Pearson confidence interval.\n    '))
Assign(targets=[Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store())], value=Tuple(elts=[Num(n=0), Num(n=1)], ctx=Load()))
If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)), Name(id='counts', ctx=Load()), BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))], keywords=[]))], orelse=[])
If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Name(id='shots', ctx=Load())]), body=[Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))), BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1)), BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))], keywords=[]))], orelse=[])
Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Str(s="The Iterative Amplitude Estimation algorithm.\n\n    This class implements the Iterative Quantum Amplitude Estimation (IQAE) algorithm, proposed\n    in [1]. The output of the algorithm is an estimate that,\n    with at least probability :math:`1 - \\alpha`, differs by epsilon to the target value, where\n    both alpha and epsilon can be specified.\n\n    It differs from the original QAE algorithm proposed by Brassard [2] in that it does not rely on\n    Quantum Phase Estimation, but is only based on Grover's algorithm. IQAE iteratively\n    applies carefully selected Grover iterations to find an estimate for the target amplitude.\n\n    References:\n        [1]: Grinko, D., Gacon, J., Zoufal, C., & Woerner, S. (2019).\n             Iterative Quantum Amplitude Estimation.\n             `arXiv:1912.05559 <https://arxiv.org/abs/1912.05559>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")
arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon_target', annotation=Name(id='float', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='confint_method', annotation=Name(id='str', ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='beta'), Num(n=2), NameConstant(value=None)])
Expr(value=Str(s="\n        The output of the algorithm is an estimate for the amplitude `a`, that with at least\n        probability 1 - alpha has an error of epsilon. The number of A operator calls scales\n        linearly in 1/epsilon (up to a logarithmic factor).\n\n        Args:\n            epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n            alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n            confint_method: Statistical method used to estimate the confidence intervals in\n                each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n                Clopper-Pearson intervals (default)\n            min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            AlgorithmError: if the method to compute the confidence intervals is not supported\n            ValueError: If the target epsilon is not in (0, 0.5]\n            ValueError: If alpha is not in (0, 1)\n            ValueError: If confint_method is not supported\n        "))
If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[])
If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[])
If(test=Compare(left=Name(id='confint_method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Str(s='chernoff'), Str(s='beta')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon_target', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='alpha', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Store())], value=Name(id='min_ratio', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Store())], value=Name(id='confint_method', ctx=Load()))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the target precision ``epsilon_target`` of the algorithm.\n\n        Returns:\n            The target precision (which is half the width of the confidence interval).\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the target precision of the algorithm.\n\n        Args:\n            epsilon: Target precision for estimation target `a`.\n        '))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load()))
Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='upper_half_circle', annotation=Name(id='bool', ctx=Load())), arg(arg='theta_interval', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2.0)])
Expr(value=Str(s='Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\n        lies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\n        Args:\n            k: The current power of the Q operator.\n            upper_half_circle: Boolean flag of whether theta_interval lies in the\n                upper half-circle [0, pi] or in the lower one [pi, 2pi].\n            theta_interval: The current confidence interval for the angle theta,\n                i.e. (theta_lower, theta_upper).\n            min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\n        Returns:\n            The next power k, and boolean flag for the extrapolated interval.\n\n        Raises:\n            AlgorithmError: if min_ratio is smaller or equal to 1\n        '))
If(test=Compare(left=Name(id='min_ratio', ctx=Load()), ops=[LtE()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Tuple(elts=[Name(id='theta_l', ctx=Store()), Name(id='theta_u', ctx=Store())], ctx=Store())], value=Name(id='theta_interval', ctx=Load()))
Assign(targets=[Name(id='old_scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2)))
Assign(targets=[Name(id='max_scaling', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))], keywords=[]))
Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4))))
While(test=Compare(left=Name(id='scaling', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))]), body=[Assign(targets=[Name(id='theta_min', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]))), Assign(targets=[Name(id='theta_max', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])]), AugAssign(target=Name(id='scaling', ctx=Store()), op=Sub(), value=Num(n=4))], orelse=[])
Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)])
Expr(value=Str(s='Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\n        The A operator is the unitary specifying the QAE problem and Q the associated Grover\n        operator.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            k: The power of the Q operator.\n            measurement: Boolean flag to indicate if measurements should be included in the\n                circuits.\n\n        Returns:\n            The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n        '))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='circuit'))]))
If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[])
If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[])
Return(value=Name(id='circuit', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='counts_or_statevector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s="Get the probability to measure '1' in the last qubit.\n\n        Args:\n            problem: The estimation problem, used to obtain the number of objective qubits and\n                the ``is_good_state`` function.\n            counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n                the statevector returned from the statevector_simulator.\n            num_state_qubits: The number of state qubits.\n\n        Returns:\n            If a dict is given, return (#one-counts, #one-counts/#all-counts),\n            otherwise Pr(measure '1' in the last qubit).\n        "))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='counts_or_statevector', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='one_counts', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load()))], orelse=[Assign(targets=[Name(id='statevector', ctx=Store())], value=Name(id='counts_or_statevector', ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])], orelse=[]), Return(value=Name(id='prob', ctx=Load()))])
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='powers', ctx=Store())], value=List(elts=[Num(n=0)], ctx=Load()))
Assign(targets=[Name(id='ratios', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='theta_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())], ctx=Load()))
Assign(targets=[Name(id='a_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())], ctx=Load()))
Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))
Assign(targets=[Name(id='num_one_shots', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='max_rounds', ctx=Store())], value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[]), op=Add(), right=Num(n=1)))
Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevector', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_confidence_interval', ctx=Store())], value=List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta_i_interval', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))], orelse=[Assign(targets=[Name(id='num_iterations', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())), While(test=Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))]), body=[AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1)), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load())), Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))]), If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))]), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])])
Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]))
Assign(targets=[Name(id='estimation', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='confidence_interval', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='IterativeAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='alpha', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=Name(id='num_oracle_queries', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=Name(id='estimation', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='estimation', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Name(id='confidence_interval', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated_processed', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimate_intervals', ctx=Store())], value=Name(id='a_intervals', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta_intervals', ctx=Store())], value=Name(id='theta_intervals', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='powers', ctx=Store())], value=Name(id='powers', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='ratios', ctx=Store())], value=Name(id='ratios', ctx=Load()))
Return(value=Name(id='result', ctx=Load()))
Str(s='IterativeAmplitudeEstimationResult')
Load()
Str(s='The ``IterativeAmplitudeEstimation`` result object.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the confidence level :math:`\\alpha`.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the confidence level :math:`\\alpha`.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='alpha', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the target half-width of the confidence interval.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the target half-width of the confidence interval.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the estimated half-width of the confidence interval.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the estimated half-width of the confidence interval.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='epsilon_estimated', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the post-processed estimated half-width of the confidence interval.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the post-processed estimated half-width of the confidence interval.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='epsilon_estimated_processed', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the confidence intervals for the estimate in each iteration.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the confidence intervals for the estimate in each iteration.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='estimate_intervals', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the confidence intervals for the angles in each iteration.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the confidence intervals for the angles in each iteration.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the powers of the Grover operator in each iteration.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the powers of the Grover operator in each iteration.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='powers', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='ratios', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the post-processed confidence interval.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the post-processed confidence interval.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='confidence_interval_processed', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
arg(arg='shots', annotation=Name(id='int', ctx=Load()))
arg(arg='max_rounds', annotation=Name(id='int', ctx=Load()))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
Str(s='Compute the Chernoff confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    The confidence interval is\n\n        [value - eps, value + eps], where eps = sqrt(3 * log(2 * max_rounds/ alpha) / shots)\n\n    but at most [0, 1].\n\n    Args:\n        value: The current estimate.\n        shots: The number of shots.\n        max_rounds: The maximum number of rounds, used to compute epsilon_a.\n        alpha: The confidence level, used to compute epsilon_a.\n\n    Returns:\n        The Chernoff confidence interval.\n    ')
Name(id='eps', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])), op=Div(), right=Name(id='shots', ctx=Load()))], keywords=[])
Name(id='lower', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='maximum', ctx=Load()), args=[Num(n=0), BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='eps', ctx=Load()))], keywords=[])
Name(id='upper', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='minimum', ctx=Load()), args=[Num(n=1), BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='eps', ctx=Load()))], keywords=[])
Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='counts', annotation=Name(id='int', ctx=Load()))
arg(arg='shots', annotation=Name(id='int', ctx=Load()))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
Str(s='Compute the Clopper-Pearson confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    Args:\n        counts: The number of positive counts.\n        shots: The number of shots.\n        alpha: The confidence level for the confidence interval.\n\n    Returns:\n        The Clopper-Pearson confidence interval.\n    ')
Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store())
Tuple(elts=[Num(n=0), Num(n=1)], ctx=Load())
Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)])
Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)), Name(id='counts', ctx=Load()), BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))], keywords=[]))
Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Name(id='shots', ctx=Load())])
Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))), BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1)), BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))], keywords=[]))
Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='epsilon_target', annotation=Name(id='float', ctx=Load()))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
arg(arg='confint_method', annotation=Name(id='str', ctx=Load()))
arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='beta')
Num(n=2)
NameConstant(value=None)
Str(s="\n        The output of the algorithm is an estimate for the amplitude `a`, that with at least\n        probability 1 - alpha has an error of epsilon. The number of A operator calls scales\n        linearly in 1/epsilon (up to a logarithmic factor).\n\n        Args:\n            epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n            alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n            confint_method: Statistical method used to estimate the confidence intervals in\n                each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n                Clopper-Pearson intervals (default)\n            min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            AlgorithmError: if the method to compute the confidence intervals is not supported\n            ValueError: If the target epsilon is not in (0, 0.5]\n            ValueError: If alpha is not in (0, 1)\n            ValueError: If confint_method is not supported\n        ")
UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)]))
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)
UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)]))
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[]), cause=None)
Compare(left=Name(id='confint_method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Str(s='chernoff'), Str(s='beta')])])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())
Name(id='epsilon_target', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())
Name(id='alpha', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Store())
Name(id='min_ratio', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Store())
Name(id='confint_method', ctx=Load())
arg(arg='self', annotation=None)
Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns the target precision ``epsilon_target`` of the algorithm.\n\n        Returns:\n            The target precision (which is half the width of the confidence interval).\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))
Str(s='Set the target precision of the algorithm.\n\n        Args:\n            epsilon: Target precision for estimation target `a`.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())
Name(id='epsilon', ctx=Load())
Name(id='epsilon_target', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='k', annotation=Name(id='int', ctx=Load()))
arg(arg='upper_half_circle', annotation=Name(id='bool', ctx=Load()))
arg(arg='theta_interval', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))
Num(n=2.0)
Str(s='Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\n        lies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\n        Args:\n            k: The current power of the Q operator.\n            upper_half_circle: Boolean flag of whether theta_interval lies in the\n                upper half-circle [0, pi] or in the lower one [pi, 2pi].\n            theta_interval: The current confidence interval for the angle theta,\n                i.e. (theta_lower, theta_upper).\n            min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\n        Returns:\n            The next power k, and boolean flag for the extrapolated interval.\n\n        Raises:\n            AlgorithmError: if min_ratio is smaller or equal to 1\n        ')
Compare(left=Name(id='min_ratio', ctx=Load()), ops=[LtE()], comparators=[Num(n=1)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[]), cause=None)
Tuple(elts=[Name(id='theta_l', ctx=Store()), Name(id='theta_u', ctx=Store())], ctx=Store())
Name(id='theta_interval', ctx=Load())
Name(id='old_scaling', ctx=Store())
BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))
Name(id='max_scaling', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))], keywords=[])
Name(id='scaling', ctx=Store())
BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4)))
Compare(left=Name(id='scaling', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))])
Assign(targets=[Name(id='theta_min', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[])))
Assign(targets=[Name(id='theta_max', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[])))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])])
AugAssign(target=Name(id='scaling', ctx=Store()), op=Sub(), value=Num(n=4))
Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
arg(arg='k', annotation=Name(id='int', ctx=Load()))
arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))
Num(n=0)
NameConstant(value=False)
Str(s='Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\n        The A operator is the unitary specifying the QAE problem and Q the associated Grover\n        operator.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            k: The power of the Q operator.\n            measurement: Boolean flag to indicate if measurements should be included in the\n                circuits.\n\n        Returns:\n            The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n        ')
Name(id='num_qubits', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='circuit'))])
Name(id='measurement', ctx=Load())
Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
Name(id='measurement', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))
Name(id='circuit', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='problem', annotation=Name(id='EstimationProblem', ctx=Load()))
arg(arg='counts_or_statevector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))
Str(s="Get the probability to measure '1' in the last qubit.\n\n        Args:\n            problem: The estimation problem, used to obtain the number of objective qubits and\n                the ``is_good_state`` function.\n            counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n                the statevector returned from the statevector_simulator.\n            num_state_qubits: The number of state qubits.\n\n        Returns:\n            If a dict is given, return (#one-counts, #one-counts/#all-counts),\n            otherwise Pr(measure '1' in the last qubit).\n        ")
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='counts_or_statevector', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])
Assign(targets=[Name(id='one_counts', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])], orelse=[])
Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load()))
Assign(targets=[Name(id='statevector', ctx=Store())], value=Name(id='counts_or_statevector', ctx=Load()))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='prob', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])], orelse=[])
Return(value=Name(id='prob', ctx=Load()))
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
Name(id='powers', ctx=Store())
List(elts=[Num(n=0)], ctx=Load())
Name(id='ratios', ctx=Store())
List(elts=[], ctx=Load())
Name(id='theta_intervals', ctx=Store())
List(elts=[List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())], ctx=Load())
Name(id='a_intervals', ctx=Store())
List(elts=[List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())], ctx=Load())
Name(id='num_oracle_queries', ctx=Store())
Num(n=0)
Name(id='num_one_shots', ctx=Store())
List(elts=[], ctx=Load())
Name(id='max_rounds', ctx=Store())
BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[]), op=Add(), right=Num(n=1))
Name(id='upper_half_circle', ctx=Store())
NameConstant(value=True)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))]))
Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='statevector', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load())))
Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='a_confidence_interval', ctx=Store())], value=List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load()))
Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='theta_i_interval', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)]))
Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))
Assign(targets=[Name(id='num_iterations', ctx=Store())], value=Num(n=0))
Assign(targets=[Name(id='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))
While(test=Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))]), body=[AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1)), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load())), Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))]), If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))]), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])
Name(id='confidence_interval', ctx=Store())
Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Name(id='estimation', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='confidence_interval', ctx=Load())], keywords=[])
Name(id='result', ctx=Store())
Call(func=Name(id='IterativeAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='alpha', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())
Name(id='num_oracle_queries', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())
Name(id='estimation', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated', ctx=Store())
BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))
Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())
Name(id='confidence_interval', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())
Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='estimation', ctx=Load())], keywords=[])
Name(id='confidence_interval', ctx=Store())
Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())
Name(id='confidence_interval', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated_processed', ctx=Store())
BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))
Attribute(value=Name(id='result', ctx=Load()), attr='estimate_intervals', ctx=Store())
Name(id='a_intervals', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='theta_intervals', ctx=Store())
Name(id='theta_intervals', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='powers', ctx=Store())
Name(id='powers', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='ratios', ctx=Store())
Name(id='ratios', ctx=Load())
Name(id='result', ctx=Load())
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='Return the confidence level :math:`\\alpha`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the confidence level :math:`\\alpha`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())
Name(id='value', ctx=Load())
Name(id='alpha', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the target half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the target half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())
Name(id='value', ctx=Load())
Name(id='epsilon_target', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the estimated half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the estimated half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())
Name(id='value', ctx=Load())
Name(id='epsilon_estimated', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the post-processed estimated half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the post-processed estimated half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())
Name(id='value', ctx=Load())
Name(id='epsilon_estimated_processed', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the confidence intervals for the estimate in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Set the confidence intervals for the estimate in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())
Name(id='value', ctx=Load())
Name(id='estimate_intervals', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the confidence intervals for the angles in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Set the confidence intervals for the angles in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())
Name(id='value', ctx=Load())
Name(id='theta_intervals', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the powers of the Grover operator in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Str(s='Set the powers of the Grover operator in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())
Name(id='value', ctx=Load())
Name(id='powers', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Str(s='Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())
Name(id='value', ctx=Load())
Name(id='ratios', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the post-processed confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Load())
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Set the post-processed confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())
Name(id='value', ctx=Load())
Name(id='confidence_interval_processed', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])), op=Div(), right=Name(id='shots', ctx=Load()))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='maximum', ctx=Load())
Num(n=0)
BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='eps', ctx=Load()))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='minimum', ctx=Load())
Num(n=1)
BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='eps', ctx=Load()))
Name(id='lower', ctx=Load())
Name(id='upper', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Name(id='lower', ctx=Store())
Name(id='upper', ctx=Store())
Store()
Num(n=0)
Num(n=1)
Load()
Name(id='counts', ctx=Load())
NotEq()
Num(n=0)
Name(id='lower', ctx=Store())
Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)), Name(id='counts', ctx=Load()), BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))], keywords=[])
Name(id='counts', ctx=Load())
NotEq()
Name(id='shots', ctx=Load())
Name(id='upper', ctx=Store())
Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))), BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1)), BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))], keywords=[])
Name(id='lower', ctx=Load())
Name(id='upper', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Name(id='str', ctx=Load())
Name(id='float', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Not()
Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)])
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[])
Not()
Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)])
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[])
Name(id='confint_method', ctx=Load())
NotIn()
Set(elts=[Str(s='chernoff'), Str(s='beta')])
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[])
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='int', ctx=Load())
Name(id='bool', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='float', ctx=Load())
Name(id='min_ratio', ctx=Load())
LtE()
Num(n=1)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[])
Name(id='theta_l', ctx=Store())
Name(id='theta_u', ctx=Store())
Store()
Load()
Store()
BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load()))
Add()
Num(n=2)
Store()
Name(id='int', ctx=Load())
BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))
Store()
Name(id='max_scaling', ctx=Load())
Sub()
BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4))
Name(id='scaling', ctx=Load())
GtE()
BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))
Name(id='theta_min', ctx=Store())
BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]))
Name(id='theta_max', ctx=Store())
BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]))
BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])])
Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True))
Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])
Name(id='scaling', ctx=Store())
Sub()
Num(n=4)
Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])
Name(id='upper_half_circle', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())
Name(id='EstimationProblem', ctx=Load())
Name(id='int', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Name(id='max', ctx=Load())
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load())
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='num_qubits', ctx=Load())
keyword(arg='name', value=Str(s='circuit'))
Load()
Name(id='c', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())
keyword(arg='inplace', value=NameConstant(value=True))
Name(id='k', ctx=Load())
NotEq()
Num(n=0)
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Load()
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])
Load()
Name(id='EstimationProblem', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='int', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='counts_or_statevector', ctx=Load())
Name(id='dict', ctx=Load())
Name(id='one_counts', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])
Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load())
Name(id='statevector', ctx=Store())
Name(id='counts_or_statevector', ctx=Load())
Name(id='num_qubits', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='prob', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])
Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)]))
If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])
Name(id='prob', ctx=Load())
Load()
Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Name(id='EstimationProblem', ctx=Load())
Store()
Num(n=0)
Load()
Store()
Load()
Store()
List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())
Load()
Store()
List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())
Load()
Store()
Store()
Load()
Store()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[])
Add()
Num(n=1)
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='circuit', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))])
Name(id='ret', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
  Found a method call call at line 301
Name(id='statevector', ctx=Store())
Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='num_qubits', ctx=Store())
BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))
Name(id='prob', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])
Name(id='prob', ctx=Store())
Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[])
Name(id='a_confidence_interval', ctx=Store())
List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load())
Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[])
Name(id='theta_i_interval', ctx=Store())
ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)])
Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[])
Name(id='num_oracle_queries', ctx=Store())
Num(n=0)
Name(id='num_iterations', ctx=Store())
Num(n=0)
Name(id='shots', ctx=Store())
Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())
Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))])
AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1))
Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))]))
Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))]))
Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load())))
Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]))
AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load())))
Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1))
Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load()))
Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load()))
If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[])
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))])
If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))])
Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2)))
Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load())))
Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load())))
Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[]))
Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2)))
Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2)))
Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))
Store()
Name(id='tuple', ctx=Load())
Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load())
Name(id='confidence_interval', ctx=Load())
Store()
Name(id='IterativeAmplitudeEstimationResult', ctx=Load())
Name(id='result', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Div()
Num(n=2)
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='estimation', ctx=Load())
Store()
Name(id='tuple', ctx=Load())
GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Div()
Num(n=2)
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Load()
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[]))
Div()
Name(id='shots', ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='value', ctx=Load())
Sub()
Name(id='eps', ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='value', ctx=Load())
Add()
Name(id='eps', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Store()
Load()
Store()
Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load())
BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))
Name(id='counts', ctx=Load())
BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))
Load()
Load()
Store()
Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))
BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1))
BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))
Load()
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Num(n=0)
Lt()
LtE()
Name(id='epsilon_target', ctx=Load())
Num(n=0.5)
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])
Num(n=0)
Lt()
Lt()
Name(id='alpha', ctx=Load())
Num(n=1)
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])
Load()
Str(s='chernoff')
Str(s='beta')
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='min_ratio must be larger than 1 to ensure convergence')
Store()
Store()
Num(n=4)
Mult()
Name(id='k', ctx=Load())
Load()
Num(n=1)
Div()
BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load())))
Load()
BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2))
Mod()
Num(n=4)
Load()
Name(id='min_ratio', ctx=Load())
Mult()
Name(id='old_scaling', ctx=Load())
Store()
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))
Sub()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[])
Store()
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))
Sub()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[])
And()
Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)])
Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])
Name(id='upper_half_circle', ctx=Store())
NameConstant(value=True)
Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load())
BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])])
Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False))
Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))
Store()
Name(id='int', ctx=Load())
Name(id='k', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='bool', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Load()
Str(s='circuit')
Store()
Name(id='ClassicalRegister', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load())
Name(id='c', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
NameConstant(value=True)
Load()
Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])
keyword(arg='inplace', value=NameConstant(value=True))
Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Store()
Name(id='state', ctx=Store())
Name(id='counts', ctx=Store())
Store()
Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load())
Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[])
AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))
Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])
BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))
Load()
Store()
Load()
Store()
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])
Store()
Name(id='i', ctx=Store())
Name(id='amplitude', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='statevector', ctx=Load())
Name(id='bitstr', ctx=Store())
Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Name(id='objectives', ctx=Store())
ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])
Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[])
Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))
Load()
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Num(n=0)
BinOp(left=Num(n=1), op=Div(), right=Num(n=4))
Load()
Num(n=0.0)
Num(n=1.0)
Load()
Name(id='int', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='estimation_problem', ctx=Load())
keyword(arg='k', value=Num(n=0))
keyword(arg='measurement', value=NameConstant(value=False))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load())
Sub()
Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Name(id='statevector', ctx=Load())
Name(id='num_qubits', ctx=Load())
Store()
Name(id='cast', ctx=Load())
Name(id='float', ctx=Load())
Name(id='prob', ctx=Load())
Store()
Name(id='prob', ctx=Load())
Name(id='prob', ctx=Load())
Load()
Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load())
Name(id='a_confidence_interval', ctx=Load())
Store()
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)
Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load())
Name(id='theta_i_interval', ctx=Load())
Store()
Store()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load())
Load()
BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Gt()
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Name(id='num_iterations', ctx=Store())
Add()
Num(n=1)
Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])
Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])
Name(id='circuit', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])
Name(id='ret', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
  Found a method call call at line 342
Name(id='counts', ctx=Store())
Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='num_qubits', ctx=Store())
BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))
Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])
Name(id='num_oracle_queries', ctx=Store())
Add()
BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))
Name(id='j', ctx=Store())
Num(n=1)
Name(id='round_shots', ctx=Store())
Name(id='shots', ctx=Load())
Name(id='round_one_counts', ctx=Store())
Name(id='one_counts', ctx=Load())
Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)])
While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')])
Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))
Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))
Name(id='upper_half_circle', ctx=Load())
Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))
Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))
Name(id='scaling', ctx=Store())
BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))
Name(id='theta_u', ctx=Store())
BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))
Name(id='theta_l', ctx=Store())
BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))
Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])
Name(id='a_u', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='a_l', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='a_u', ctx=Store())
Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])
Name(id='a_l', ctx=Store())
Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[])
Load()
Name(id='a_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Sub()
Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Load()
Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])
comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)
Load()
Load()
Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Sub()
Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Num(n=3)
Mult()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='beta', ctx=Load())
Load()
Name(id='alpha', ctx=Load())
Div()
Num(n=2)
Load()
BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))
Add()
Num(n=1)
Name(id='beta', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))
Name(id='counts', ctx=Load())
Add()
Num(n=1)
Name(id='shots', ctx=Load())
Sub()
Name(id='counts', ctx=Load())
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Str(s='The target epsilon must be in (0, 0.5], but is ')
FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None)
Str(s='.')
Load()
Load()
Str(s='The confidence level alpha must be in (0, 1), but is ')
FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)
Load()
Str(s='The confidence interval method must be chernoff or beta, but is ')
FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None)
Str(s='.')
Name(id='super', ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Load()
Load()
Num(n=2)
Mult()
BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))
Name(id='max_scaling', ctx=Load())
Sub()
Num(n=2)
Load()
Load()
Name(id='scaling', ctx=Load())
Mult()
Name(id='theta_l', ctx=Load())
Name(id='int', ctx=Load())
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))
Name(id='scaling', ctx=Load())
Mult()
Name(id='theta_u', ctx=Load())
Name(id='int', ctx=Load())
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))
Name(id='theta_min', ctx=Load())
LtE()
LtE()
Name(id='theta_max', ctx=Load())
Num(n=0.5)
Name(id='theta_min', ctx=Load())
LtE()
Num(n=0.5)
Store()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[])
Name(id='upper_half_circle', ctx=Load())
Load()
And()
Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)])
Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])
Name(id='upper_half_circle', ctx=Store())
NameConstant(value=False)
Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Name(id='len', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load())
Name(id='k', ctx=Load())
NameConstant(value=True)
Name(id='circuit', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='c', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Store()
Store()
Name(id='counts_or_statevector', ctx=Load())
Load()
Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load())
Name(id='state', ctx=Load())
Name(id='one_counts', ctx=Store())
Add()
Name(id='counts', ctx=Load())
Name(id='int', ctx=Load())
Name(id='one_counts', ctx=Load())
Name(id='one_counts', ctx=Load())
Div()
Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])
Store()
Store()
Load()
Load()
Store()
Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load())
Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Store()
Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load())
comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)
Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load())
Name(id='objectives', ctx=Load())
Name(id='prob', ctx=Store())
BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)))
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Load()
Num(n=1)
Div()
Num(n=4)
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[])
Div()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[])
Load()
Name(id='self', ctx=Load())
Load()
Load()
Num(n=0)
NameConstant(value=False)
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='ret', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='a_intervals', ctx=Load())
Load()
Load()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2))
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Name(id='a_i', ctx=Store())
Name(id='a_confidence_interval', ctx=Load())
Name(id='theta_intervals', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Sub()
Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load())
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Store()
Name(id='k', ctx=Store())
Name(id='upper_half_circle', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load())
Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Name(id='upper_half_circle', ctx=Load())
Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))
Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load())
Name(id='k', ctx=Load())
Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Name(id='k', ctx=Load())
keyword(arg='measurement', value=NameConstant(value=True))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load())
Sub()
Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Name(id='one_counts', ctx=Store())
Name(id='prob', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Name(id='counts', ctx=Load())
Name(id='num_qubits', ctx=Load())
Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load())
Name(id='one_counts', ctx=Load())
Store()
Name(id='shots', ctx=Load())
Mult()
Name(id='k', ctx=Load())
Store()
Store()
Load()
Store()
Load()
Name(id='num_iterations', ctx=Load())
Gt()
Num(n=1)
BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])])
Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1)))
AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load()))
AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load())
Eq()
Str(s='chernoff')
Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())
Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[])
Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())
Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[])
Load()
Name(id='theta_min_i', ctx=Store())
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Name(id='theta_max_i', ctx=Store())
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Name(id='theta_min_i', ctx=Store())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Name(id='theta_max_i', ctx=Store())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Store()
BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load()))
Add()
Num(n=2)
Store()
BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load()))
Div()
Name(id='scaling', ctx=Load())
Store()
BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load()))
Div()
Name(id='scaling', ctx=Load())
Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load())
List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[])
Pow()
Num(n=2)
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[])
Pow()
Num(n=2)
Store()
Name(id='cast', ctx=Load())
Name(id='float', ctx=Load())
Name(id='a_u', ctx=Load())
Store()
Name(id='cast', ctx=Load())
Name(id='float', ctx=Load())
Name(id='a_l', ctx=Load())
Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load())
List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Name(id='confidence_interval', ctx=Load())
Index(value=Num(n=1))
Load()
Name(id='confidence_interval', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='x', ctx=Load())
Name(id='x', ctx=Store())
Name(id='confidence_interval', ctx=Load())
Name(id='confidence_interval', ctx=Load())
Index(value=Num(n=1))
Load()
Name(id='confidence_interval', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='super', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))
Load()
Load()
Name(id='shots', ctx=Load())
Sub()
Name(id='counts', ctx=Load())
Load()
Name(id='alpha', ctx=Load())
Div()
Num(n=2)
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Name(id='epsilon_target', ctx=Load())
Name(id='alpha', ctx=Load())
Name(id='confint_method', ctx=Load())
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='theta_u', ctx=Load())
Sub()
Name(id='theta_l', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='scaling', ctx=Load())
Mult()
Name(id='theta_l', ctx=Load())
Load()
Load()
Load()
Name(id='scaling', ctx=Load())
Mult()
Name(id='theta_u', ctx=Load())
Load()
Load()
Load()
Name(id='int', ctx=Load())
BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))
Load()
Name(id='theta_max', ctx=Load())
GtE()
Num(n=0.5)
Name(id='theta_max', ctx=Load())
GtE()
GtE()
Name(id='theta_min', ctx=Load())
Num(n=0.5)
Store()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[])
Name(id='upper_half_circle', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Load()
Name(id='problem', ctx=Load())
Load()
Load()
Store()
Load()
Load()
Load()
Load()
Name(id='sum', ctx=Load())
Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='statevector', ctx=Load())
Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[])
Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None)
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='bitstr', ctx=Load())
Index(value=Name(id='index', ctx=Load()))
Load()
Name(id='index', ctx=Store())
Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='problem', ctx=Load())
Load()
Load()
Store()
Name(id='prob', ctx=Load())
Add()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Load()
Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[])
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Index(value=Num(n=1))
Load()
Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='self', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Name(id='powers', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Load()
Name(id='theta_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())
Name(id='powers', ctx=Load())
Load()
Load()
Name(id='ratios', ctx=Load())
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1))
Div()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1))
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='ret', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='num_one_shots', ctx=Load())
Load()
Load()
Load()
Load()
Load()
And()
Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())])
Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])
Name(id='j', ctx=Store())
BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))
Name(id='round_shots', ctx=Store())
Add()
Name(id='shots', ctx=Load())
Name(id='round_one_counts', ctx=Store())
Add()
Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='a_i_min', ctx=Store())
Name(id='a_i_max', ctx=Store())
Store()
Name(id='_chernoff_confint', ctx=Load())
Name(id='prob', ctx=Load())
Name(id='round_shots', ctx=Load())
Name(id='max_rounds', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())
Name(id='a_i_min', ctx=Store())
Name(id='a_i_max', ctx=Store())
Store()
Name(id='_clopper_pearson_confint', ctx=Load())
Name(id='round_one_counts', ctx=Load())
Name(id='round_shots', ctx=Load())
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))
Store()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2))
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Store()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2))
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Store()
Num(n=1)
Sub()
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Store()
Num(n=1)
Sub()
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Num(n=4)
Mult()
Name(id='k', ctx=Load())
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[])
Add()
Name(id='theta_max_i', ctx=Load())
Load()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[])
Add()
Name(id='theta_min_i', ctx=Load())
Load()
Name(id='theta_intervals', ctx=Load())
Load()
Name(id='theta_l', ctx=Load())
Name(id='theta_u', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='a_intervals', ctx=Load())
Load()
Name(id='a_l', ctx=Load())
Name(id='a_u', ctx=Load())
Load()
USub()
Num(n=1)
Load()
Num(n=1)
Load()
Num(n=0)
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Store()
Load()
Load()
Num(n=1)
Load()
Num(n=0)
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load()))
Div()
Name(id='alpha', ctx=Load())
Load()
Load()
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2))
Div()
Num(n=4)
Load()
Load()
Load()
Name(id='int', ctx=Load())
BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='Dict', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load())
Load()
Load()
Load()
Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load())
Name(id='num_qubits', ctx=Load())
UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load()))
USub()
Num(n=1)
Load()
Name(id='index', ctx=Load())
Store()
Name(id='problem', ctx=Load())
Load()
Load()
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8))
Div()
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))
Load()
Load()
Name(id='theta_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Num(n=1)
Name(id='theta_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Num(n=0)
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='self', ctx=Load())
Load()
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Add()
Num(n=1)
BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()))
Add()
Num(n=1)
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load())
Eq()
Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())
Name(id='num_iterations', ctx=Load())
GtE()
BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))
Store()
Name(id='j', ctx=Load())
Add()
Num(n=1)
Store()
Load()
Store()
Name(id='num_one_shots', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load())))
Load()
Load()
Store()
Store()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Store()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())
Div()
Name(id='max_rounds', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[])
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[])
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2))
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2))
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Name(id='int', ctx=Load())
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))
Load()
Name(id='int', ctx=Load())
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Mult()
Name(id='theta_u', ctx=Load())
Name(id='np', ctx=Load())
Load()
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Mult()
Name(id='theta_l', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='max_rounds', ctx=Load())
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Name(id='scaling', ctx=Load())
Sub()
Num(n=2)
Load()
BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2))
Div()
Num(n=4)
Load()
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
Name(id='counts_or_statevector', ctx=Load())
Load()
Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())
Load()
Load()
USub()
Name(id='num_state_qubits', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Name(id='amplitude', ctx=Load())
Load()
Load()
Load()
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Div()
Num(n=8)
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load()))
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
UnaryOp(op=USub(), operand=Num(n=1))
USub()
Num(n=1)
USub()
Num(n=1)
Load()
Num(n=2)
Mult()
Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Num(n=2)
Mult()
Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())
Load()
Name(id='powers', ctx=Load())
Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load())))
Load()
Name(id='powers', ctx=Load())
Index(value=Name(id='num_iterations', ctx=Load()))
Load()
Load()
Name(id='j', ctx=Load())
Add()
Num(n=1)
Load()
Load()
UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[])
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[])
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Load()
Name(id='scaling', ctx=Load())
Mult()
Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Load()
Name(id='scaling', ctx=Load())
Mult()
Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='scaling', ctx=Load())
Sub()
Num(n=2)
Name(id='str', ctx=Load())
Name(id='int', ctx=Load())
Load()
Load()
Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])
Slice(lower=Num(n=2), upper=None, step=None)
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Name(id='a_i', ctx=Load())
USub()
Num(n=1)
USub()
Num(n=1)
Name(id='powers', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='powers', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=2)))
Load()
Load()
BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))
Load()
Name(id='num_iterations', ctx=Load())
Load()
USub()
Name(id='j', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load()))
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load()))
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))
Load()
Load()
Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Index(value=Num(n=1))
Load()
Load()
Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='bin', ctx=Load())
Name(id='i', ctx=Load())
Num(n=2)
Load()
Name(id='self', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Name(id='num_iterations', ctx=Load())
Sub()
Name(id='j', ctx=Load())
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='a_i_min', ctx=Load())
Load()
Num(n=2)
Mult()
Name(id='a_i_max', ctx=Load())
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load()))
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load()))
Name(id='theta_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Num(n=1)
Name(id='theta_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Num(n=0)
Load()
Load()
Load()
Load()
Load()
Load()
USub()
Num(n=1)
USub()
Num(n=2)
Load()
Load()
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='a_i_max', ctx=Load())
Load()
Num(n=2)
Mult()
Name(id='a_i_min', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Load()
USub()
Num(n=1)
USub()
Num(n=1)
Module(body=[Expr(value=Str(s='The Iterative Quantum Amplitude Estimation Algorithm.')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None), alias(name='Dict', asname=None), alias(name='cast', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='scipy.stats', names=[alias(name='beta', asname=None)], level=0), ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='amplitude_estimator', names=[alias(name='AmplitudeEstimator', asname=None), alias(name='AmplitudeEstimatorResult', asname=None)], level=1), ImportFrom(module='estimation_problem', names=[alias(name='EstimationProblem', asname=None)], level=1), ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2), ClassDef(name='IterativeAmplitudeEstimation', bases=[Name(id='AmplitudeEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s="The Iterative Amplitude Estimation algorithm.\n\n    This class implements the Iterative Quantum Amplitude Estimation (IQAE) algorithm, proposed\n    in [1]. The output of the algorithm is an estimate that,\n    with at least probability :math:`1 - \\alpha`, differs by epsilon to the target value, where\n    both alpha and epsilon can be specified.\n\n    It differs from the original QAE algorithm proposed by Brassard [2] in that it does not rely on\n    Quantum Phase Estimation, but is only based on Grover's algorithm. IQAE iteratively\n    applies carefully selected Grover iterations to find an estimate for the target amplitude.\n\n    References:\n        [1]: Grinko, D., Gacon, J., Zoufal, C., & Woerner, S. (2019).\n             Iterative Quantum Amplitude Estimation.\n             `arXiv:1912.05559 <https://arxiv.org/abs/1912.05559>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon_target', annotation=Name(id='float', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='confint_method', annotation=Name(id='str', ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='beta'), Num(n=2), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        The output of the algorithm is an estimate for the amplitude `a`, that with at least\n        probability 1 - alpha has an error of epsilon. The number of A operator calls scales\n        linearly in 1/epsilon (up to a logarithmic factor).\n\n        Args:\n            epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n            alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n            confint_method: Statistical method used to estimate the confidence intervals in\n                each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n                Clopper-Pearson intervals (default)\n            min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            AlgorithmError: if the method to compute the confidence intervals is not supported\n            ValueError: If the target epsilon is not in (0, 0.5]\n            ValueError: If alpha is not in (0, 1)\n            ValueError: If confint_method is not supported\n        ")), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='confint_method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Str(s='chernoff'), Str(s='beta')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon_target', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Store())], value=Name(id='min_ratio', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Store())], value=Name(id='confint_method', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the target precision ``epsilon_target`` of the algorithm.\n\n        Returns:\n            The target precision (which is half the width of the confidence interval).\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target precision of the algorithm.\n\n        Args:\n            epsilon: Target precision for estimation target `a`.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_find_next_k', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='upper_half_circle', annotation=Name(id='bool', ctx=Load())), arg(arg='theta_interval', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2.0)]), body=[Expr(value=Str(s='Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\n        lies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\n        Args:\n            k: The current power of the Q operator.\n            upper_half_circle: Boolean flag of whether theta_interval lies in the\n                upper half-circle [0, pi] or in the lower one [pi, 2pi].\n            theta_interval: The current confidence interval for the angle theta,\n                i.e. (theta_lower, theta_upper).\n            min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\n        Returns:\n            The next power k, and boolean flag for the extrapolated interval.\n\n        Raises:\n            AlgorithmError: if min_ratio is smaller or equal to 1\n        ')), If(test=Compare(left=Name(id='min_ratio', ctx=Load()), ops=[LtE()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='theta_l', ctx=Store()), Name(id='theta_u', ctx=Store())], ctx=Store())], value=Name(id='theta_interval', ctx=Load())), Assign(targets=[Name(id='old_scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='max_scaling', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))], keywords=[])), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4)))), While(test=Compare(left=Name(id='scaling', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))]), body=[Assign(targets=[Name(id='theta_min', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]))), Assign(targets=[Name(id='theta_max', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])]), AugAssign(target=Name(id='scaling', ctx=Store()), op=Sub(), value=Num(n=4))], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\n        The A operator is the unitary specifying the QAE problem and Q the associated Grover\n        operator.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            k: The power of the Q operator.\n            measurement: Boolean flag to indicate if measurements should be included in the\n                circuits.\n\n        Returns:\n            The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n        ')), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='circuit'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_good_state_probability', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='counts_or_statevector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Get the probability to measure '1' in the last qubit.\n\n        Args:\n            problem: The estimation problem, used to obtain the number of objective qubits and\n                the ``is_good_state`` function.\n            counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n                the statevector returned from the statevector_simulator.\n            num_state_qubits: The number of state qubits.\n\n        Returns:\n            If a dict is given, return (#one-counts, #one-counts/#all-counts),\n            otherwise Pr(measure '1' in the last qubit).\n        ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='counts_or_statevector', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='one_counts', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load()))], orelse=[Assign(targets=[Name(id='statevector', ctx=Store())], value=Name(id='counts_or_statevector', ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])], orelse=[]), Return(value=Name(id='prob', ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='powers', ctx=Store())], value=List(elts=[Num(n=0)], ctx=Load())), Assign(targets=[Name(id='ratios', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='theta_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='a_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='num_one_shots', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_rounds', ctx=Store())], value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[]), op=Add(), right=Num(n=1))), Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevector', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_confidence_interval', ctx=Store())], value=List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta_i_interval', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))], orelse=[Assign(targets=[Name(id='num_iterations', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())), While(test=Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))]), body=[AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1)), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load())), Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))]), If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))]), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='estimation', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='IterativeAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='alpha', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=Name(id='num_oracle_queries', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=Name(id='estimation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='estimation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated_processed', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimate_intervals', ctx=Store())], value=Name(id='a_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta_intervals', ctx=Store())], value=Name(id='theta_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='powers', ctx=Store())], value=Name(id='powers', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='ratios', ctx=Store())], value=Name(id='ratios', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='IterativeAmplitudeEstimationResult'))], decorator_list=[]), ClassDef(name='IterativeAmplitudeEstimationResult', bases=[Name(id='AmplitudeEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The ``IterativeAmplitudeEstimation`` result object.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence level :math:`\\alpha`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence level :math:`\\alpha`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='alpha', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the target half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the estimate in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the estimate in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='estimate_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the angles in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the angles in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the powers of the Grover operator in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='powers', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ratios', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='confidence_interval_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[]), FunctionDef(name='_chernoff_confint', args=arguments(args=[arg(arg='value', annotation=Name(id='float', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='max_rounds', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute the Chernoff confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    The confidence interval is\n\n        [value - eps, value + eps], where eps = sqrt(3 * log(2 * max_rounds/ alpha) / shots)\n\n    but at most [0, 1].\n\n    Args:\n        value: The current estimate.\n        shots: The number of shots.\n        max_rounds: The maximum number of rounds, used to compute epsilon_a.\n        alpha: The confidence level, used to compute epsilon_a.\n\n    Returns:\n        The Chernoff confidence interval.\n    ')), Assign(targets=[Name(id='eps', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])), op=Div(), right=Name(id='shots', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='maximum', ctx=Load()), args=[Num(n=0), BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='eps', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='minimum', ctx=Load()), args=[Num(n=1), BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='eps', ctx=Load()))], keywords=[])), Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='_clopper_pearson_confint', args=arguments(args=[arg(arg='counts', annotation=Name(id='int', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute the Clopper-Pearson confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    Args:\n        counts: The number of positive counts.\n        shots: The number of shots.\n        alpha: The confidence level for the confidence interval.\n\n    Returns:\n        The Clopper-Pearson confidence interval.\n    ')), Assign(targets=[Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store())], value=Tuple(elts=[Num(n=0), Num(n=1)], ctx=Load())), If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)), Name(id='counts', ctx=Load()), BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Name(id='shots', ctx=Load())]), body=[Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))), BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1)), BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))])
Expr(value=Str(s='The Iterative Quantum Amplitude Estimation Algorithm.'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None), alias(name='Dict', asname=None), alias(name='cast', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='scipy.stats', names=[alias(name='beta', asname=None)], level=0)
ImportFrom(module='qiskit', names=[alias(name='ClassicalRegister', asname=None), alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='amplitude_estimator', names=[alias(name='AmplitudeEstimator', asname=None), alias(name='AmplitudeEstimatorResult', asname=None)], level=1)
ImportFrom(module='estimation_problem', names=[alias(name='EstimationProblem', asname=None)], level=1)
ImportFrom(module='exceptions', names=[alias(name='AlgorithmError', asname=None)], level=2)
ClassDef(name='IterativeAmplitudeEstimation', bases=[Name(id='AmplitudeEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s="The Iterative Amplitude Estimation algorithm.\n\n    This class implements the Iterative Quantum Amplitude Estimation (IQAE) algorithm, proposed\n    in [1]. The output of the algorithm is an estimate that,\n    with at least probability :math:`1 - \\alpha`, differs by epsilon to the target value, where\n    both alpha and epsilon can be specified.\n\n    It differs from the original QAE algorithm proposed by Brassard [2] in that it does not rely on\n    Quantum Phase Estimation, but is only based on Grover's algorithm. IQAE iteratively\n    applies carefully selected Grover iterations to find an estimate for the target amplitude.\n\n    References:\n        [1]: Grinko, D., Gacon, J., Zoufal, C., & Woerner, S. (2019).\n             Iterative Quantum Amplitude Estimation.\n             `arXiv:1912.05559 <https://arxiv.org/abs/1912.05559>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon_target', annotation=Name(id='float', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='confint_method', annotation=Name(id='str', ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='beta'), Num(n=2), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        The output of the algorithm is an estimate for the amplitude `a`, that with at least\n        probability 1 - alpha has an error of epsilon. The number of A operator calls scales\n        linearly in 1/epsilon (up to a logarithmic factor).\n\n        Args:\n            epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n            alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n            confint_method: Statistical method used to estimate the confidence intervals in\n                each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n                Clopper-Pearson intervals (default)\n            min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            AlgorithmError: if the method to compute the confidence intervals is not supported\n            ValueError: If the target epsilon is not in (0, 0.5]\n            ValueError: If alpha is not in (0, 1)\n            ValueError: If confint_method is not supported\n        ")), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='confint_method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Str(s='chernoff'), Str(s='beta')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon_target', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Store())], value=Name(id='min_ratio', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Store())], value=Name(id='confint_method', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the target precision ``epsilon_target`` of the algorithm.\n\n        Returns:\n            The target precision (which is half the width of the confidence interval).\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target precision of the algorithm.\n\n        Args:\n            epsilon: Target precision for estimation target `a`.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_find_next_k', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='upper_half_circle', annotation=Name(id='bool', ctx=Load())), arg(arg='theta_interval', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2.0)]), body=[Expr(value=Str(s='Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\n        lies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\n        Args:\n            k: The current power of the Q operator.\n            upper_half_circle: Boolean flag of whether theta_interval lies in the\n                upper half-circle [0, pi] or in the lower one [pi, 2pi].\n            theta_interval: The current confidence interval for the angle theta,\n                i.e. (theta_lower, theta_upper).\n            min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\n        Returns:\n            The next power k, and boolean flag for the extrapolated interval.\n\n        Raises:\n            AlgorithmError: if min_ratio is smaller or equal to 1\n        ')), If(test=Compare(left=Name(id='min_ratio', ctx=Load()), ops=[LtE()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='theta_l', ctx=Store()), Name(id='theta_u', ctx=Store())], ctx=Store())], value=Name(id='theta_interval', ctx=Load())), Assign(targets=[Name(id='old_scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='max_scaling', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))], keywords=[])), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4)))), While(test=Compare(left=Name(id='scaling', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))]), body=[Assign(targets=[Name(id='theta_min', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]))), Assign(targets=[Name(id='theta_max', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])]), AugAssign(target=Name(id='scaling', ctx=Store()), op=Sub(), value=Num(n=4))], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\n        The A operator is the unitary specifying the QAE problem and Q the associated Grover\n        operator.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            k: The power of the Q operator.\n            measurement: Boolean flag to indicate if measurements should be included in the\n                circuits.\n\n        Returns:\n            The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n        ')), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='circuit'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_good_state_probability', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='counts_or_statevector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Get the probability to measure '1' in the last qubit.\n\n        Args:\n            problem: The estimation problem, used to obtain the number of objective qubits and\n                the ``is_good_state`` function.\n            counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n                the statevector returned from the statevector_simulator.\n            num_state_qubits: The number of state qubits.\n\n        Returns:\n            If a dict is given, return (#one-counts, #one-counts/#all-counts),\n            otherwise Pr(measure '1' in the last qubit).\n        ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='counts_or_statevector', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='one_counts', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load()))], orelse=[Assign(targets=[Name(id='statevector', ctx=Store())], value=Name(id='counts_or_statevector', ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])], orelse=[]), Return(value=Name(id='prob', ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='powers', ctx=Store())], value=List(elts=[Num(n=0)], ctx=Load())), Assign(targets=[Name(id='ratios', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='theta_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='a_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='num_one_shots', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_rounds', ctx=Store())], value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[]), op=Add(), right=Num(n=1))), Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevector', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_confidence_interval', ctx=Store())], value=List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta_i_interval', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))], orelse=[Assign(targets=[Name(id='num_iterations', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())), While(test=Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))]), body=[AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1)), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load())), Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))]), If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))]), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='estimation', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='IterativeAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='alpha', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=Name(id='num_oracle_queries', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=Name(id='estimation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='estimation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated_processed', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimate_intervals', ctx=Store())], value=Name(id='a_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta_intervals', ctx=Store())], value=Name(id='theta_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='powers', ctx=Store())], value=Name(id='powers', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='ratios', ctx=Store())], value=Name(id='ratios', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='IterativeAmplitudeEstimationResult'))], decorator_list=[])
ClassDef(name='IterativeAmplitudeEstimationResult', bases=[Name(id='AmplitudeEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='The ``IterativeAmplitudeEstimation`` result object.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence level :math:`\\alpha`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence level :math:`\\alpha`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='alpha', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the target half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the estimate in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the estimate in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='estimate_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the angles in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the angles in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the powers of the Grover operator in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='powers', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ratios', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='confidence_interval_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
FunctionDef(name='_chernoff_confint', args=arguments(args=[arg(arg='value', annotation=Name(id='float', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='max_rounds', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute the Chernoff confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    The confidence interval is\n\n        [value - eps, value + eps], where eps = sqrt(3 * log(2 * max_rounds/ alpha) / shots)\n\n    but at most [0, 1].\n\n    Args:\n        value: The current estimate.\n        shots: The number of shots.\n        max_rounds: The maximum number of rounds, used to compute epsilon_a.\n        alpha: The confidence level, used to compute epsilon_a.\n\n    Returns:\n        The Chernoff confidence interval.\n    ')), Assign(targets=[Name(id='eps', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])), op=Div(), right=Name(id='shots', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='maximum', ctx=Load()), args=[Num(n=0), BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='eps', ctx=Load()))], keywords=[])), Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='minimum', ctx=Load()), args=[Num(n=1), BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='eps', ctx=Load()))], keywords=[])), Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='_clopper_pearson_confint', args=arguments(args=[arg(arg='counts', annotation=Name(id='int', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute the Clopper-Pearson confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    Args:\n        counts: The number of positive counts.\n        shots: The number of shots.\n        alpha: The confidence level for the confidence interval.\n\n    Returns:\n        The Clopper-Pearson confidence interval.\n    ')), Assign(targets=[Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store())], value=Tuple(elts=[Num(n=0), Num(n=1)], ctx=Load())), If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)), Name(id='counts', ctx=Load()), BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Name(id='shots', ctx=Load())]), body=[Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))), BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1)), BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))], keywords=[]))], orelse=[]), Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='The Iterative Quantum Amplitude Estimation Algorithm.')
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='List', asname=None)
alias(name='Tuple', asname=None)
alias(name='Dict', asname=None)
alias(name='cast', asname=None)
alias(name='numpy', asname='np')
alias(name='beta', asname=None)
alias(name='ClassicalRegister', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='Backend', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='AmplitudeEstimator', asname=None)
alias(name='AmplitudeEstimatorResult', asname=None)
alias(name='EstimationProblem', asname=None)
alias(name='AlgorithmError', asname=None)
Name(id='AmplitudeEstimator', ctx=Load())
Expr(value=Str(s="The Iterative Amplitude Estimation algorithm.\n\n    This class implements the Iterative Quantum Amplitude Estimation (IQAE) algorithm, proposed\n    in [1]. The output of the algorithm is an estimate that,\n    with at least probability :math:`1 - \\alpha`, differs by epsilon to the target value, where\n    both alpha and epsilon can be specified.\n\n    It differs from the original QAE algorithm proposed by Brassard [2] in that it does not rely on\n    Quantum Phase Estimation, but is only based on Grover's algorithm. IQAE iteratively\n    applies carefully selected Grover iterations to find an estimate for the target amplitude.\n\n    References:\n        [1]: Grinko, D., Gacon, J., Zoufal, C., & Woerner, S. (2019).\n             Iterative Quantum Amplitude Estimation.\n             `arXiv:1912.05559 <https://arxiv.org/abs/1912.05559>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    "))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon_target', annotation=Name(id='float', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='confint_method', annotation=Name(id='str', ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='beta'), Num(n=2), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        The output of the algorithm is an estimate for the amplitude `a`, that with at least\n        probability 1 - alpha has an error of epsilon. The number of A operator calls scales\n        linearly in 1/epsilon (up to a logarithmic factor).\n\n        Args:\n            epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n            alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n            confint_method: Statistical method used to estimate the confidence intervals in\n                each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n                Clopper-Pearson intervals (default)\n            min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            AlgorithmError: if the method to compute the confidence intervals is not supported\n            ValueError: If the target epsilon is not in (0, 0.5]\n            ValueError: If alpha is not in (0, 1)\n            ValueError: If confint_method is not supported\n        ")), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Name(id='confint_method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Str(s='chernoff'), Str(s='beta')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon_target', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Store())], value=Name(id='min_ratio', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Store())], value=Name(id='confint_method', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the target precision ``epsilon_target`` of the algorithm.\n\n        Returns:\n            The target precision (which is half the width of the confidence interval).\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target precision of the algorithm.\n\n        Args:\n            epsilon: Target precision for estimation target `a`.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='_find_next_k', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='upper_half_circle', annotation=Name(id='bool', ctx=Load())), arg(arg='theta_interval', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2.0)]), body=[Expr(value=Str(s='Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\n        lies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\n        Args:\n            k: The current power of the Q operator.\n            upper_half_circle: Boolean flag of whether theta_interval lies in the\n                upper half-circle [0, pi] or in the lower one [pi, 2pi].\n            theta_interval: The current confidence interval for the angle theta,\n                i.e. (theta_lower, theta_upper).\n            min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\n        Returns:\n            The next power k, and boolean flag for the extrapolated interval.\n\n        Raises:\n            AlgorithmError: if min_ratio is smaller or equal to 1\n        ')), If(test=Compare(left=Name(id='min_ratio', ctx=Load()), ops=[LtE()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Tuple(elts=[Name(id='theta_l', ctx=Store()), Name(id='theta_u', ctx=Store())], ctx=Store())], value=Name(id='theta_interval', ctx=Load())), Assign(targets=[Name(id='old_scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='max_scaling', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))], keywords=[])), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4)))), While(test=Compare(left=Name(id='scaling', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))]), body=[Assign(targets=[Name(id='theta_min', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]))), Assign(targets=[Name(id='theta_max', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])]), AugAssign(target=Name(id='scaling', ctx=Store()), op=Sub(), value=Num(n=4))], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\n        The A operator is the unitary specifying the QAE problem and Q the associated Grover\n        operator.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            k: The power of the Q operator.\n            measurement: Boolean flag to indicate if measurements should be included in the\n                circuits.\n\n        Returns:\n            The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n        ')), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='circuit'))])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[]), If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='_good_state_probability', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='counts_or_statevector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s="Get the probability to measure '1' in the last qubit.\n\n        Args:\n            problem: The estimation problem, used to obtain the number of objective qubits and\n                the ``is_good_state`` function.\n            counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n                the statevector returned from the statevector_simulator.\n            num_state_qubits: The number of state qubits.\n\n        Returns:\n            If a dict is given, return (#one-counts, #one-counts/#all-counts),\n            otherwise Pr(measure '1' in the last qubit).\n        ")), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='counts_or_statevector', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='one_counts', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load()))], orelse=[Assign(targets=[Name(id='statevector', ctx=Store())], value=Name(id='counts_or_statevector', ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])], orelse=[]), Return(value=Name(id='prob', ctx=Load()))])], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Assign(targets=[Name(id='powers', ctx=Store())], value=List(elts=[Num(n=0)], ctx=Load())), Assign(targets=[Name(id='ratios', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='theta_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='a_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())], ctx=Load())), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='num_one_shots', ctx=Store())], value=List(elts=[], ctx=Load())), Assign(targets=[Name(id='max_rounds', ctx=Store())], value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[]), op=Add(), right=Num(n=1))), Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevector', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_confidence_interval', ctx=Store())], value=List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta_i_interval', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))], orelse=[Assign(targets=[Name(id='num_iterations', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())), While(test=Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))]), body=[AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1)), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load())), Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))]), If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))]), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])), Assign(targets=[Name(id='estimation', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='IterativeAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='alpha', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=Name(id='num_oracle_queries', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=Name(id='estimation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='estimation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Name(id='confidence_interval', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated_processed', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimate_intervals', ctx=Store())], value=Name(id='a_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta_intervals', ctx=Store())], value=Name(id='theta_intervals', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='powers', ctx=Store())], value=Name(id='powers', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='ratios', ctx=Store())], value=Name(id='ratios', ctx=Load())), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='IterativeAmplitudeEstimationResult'))
Name(id='AmplitudeEstimatorResult', ctx=Load())
Expr(value=Str(s='The ``IterativeAmplitudeEstimation`` result object.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=NameConstant(value=None))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence level :math:`\\alpha`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='alpha', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence level :math:`\\alpha`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='alpha', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the target half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='epsilon_target', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the target half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='epsilon_estimated', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed estimated half-width of the confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='epsilon_estimated_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed estimated half-width of the confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='epsilon_estimated_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the estimate in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='estimate_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the estimate in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='estimate_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the confidence intervals for the angles in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='theta_intervals', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the confidence intervals for the angles in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the powers of the Grover operator in each iteration.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
FunctionDef(name='powers', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the powers of the Grover operator in each iteration.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='powers', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
FunctionDef(name='ratios', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='ratios', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the post-processed confidence interval.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='confidence_interval_processed', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the post-processed confidence interval.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='confidence_interval_processed', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
arguments(args=[arg(arg='value', annotation=Name(id='float', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='max_rounds', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Compute the Chernoff confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    The confidence interval is\n\n        [value - eps, value + eps], where eps = sqrt(3 * log(2 * max_rounds/ alpha) / shots)\n\n    but at most [0, 1].\n\n    Args:\n        value: The current estimate.\n        shots: The number of shots.\n        max_rounds: The maximum number of rounds, used to compute epsilon_a.\n        alpha: The confidence level, used to compute epsilon_a.\n\n    Returns:\n        The Chernoff confidence interval.\n    '))
Assign(targets=[Name(id='eps', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])), op=Div(), right=Name(id='shots', ctx=Load()))], keywords=[]))
Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='maximum', ctx=Load()), args=[Num(n=0), BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='eps', ctx=Load()))], keywords=[]))
Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='minimum', ctx=Load()), args=[Num(n=1), BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='eps', ctx=Load()))], keywords=[]))
Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='counts', annotation=Name(id='int', ctx=Load())), arg(arg='shots', annotation=Name(id='int', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Compute the Clopper-Pearson confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    Args:\n        counts: The number of positive counts.\n        shots: The number of shots.\n        alpha: The confidence level for the confidence interval.\n\n    Returns:\n        The Clopper-Pearson confidence interval.\n    '))
Assign(targets=[Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store())], value=Tuple(elts=[Num(n=0), Num(n=1)], ctx=Load()))
If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)), Name(id='counts', ctx=Load()), BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))], keywords=[]))], orelse=[])
If(test=Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Name(id='shots', ctx=Load())]), body=[Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))), BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1)), BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))], keywords=[]))], orelse=[])
Return(value=Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Str(s="The Iterative Amplitude Estimation algorithm.\n\n    This class implements the Iterative Quantum Amplitude Estimation (IQAE) algorithm, proposed\n    in [1]. The output of the algorithm is an estimate that,\n    with at least probability :math:`1 - \\alpha`, differs by epsilon to the target value, where\n    both alpha and epsilon can be specified.\n\n    It differs from the original QAE algorithm proposed by Brassard [2] in that it does not rely on\n    Quantum Phase Estimation, but is only based on Grover's algorithm. IQAE iteratively\n    applies carefully selected Grover iterations to find an estimate for the target amplitude.\n\n    References:\n        [1]: Grinko, D., Gacon, J., Zoufal, C., & Woerner, S. (2019).\n             Iterative Quantum Amplitude Estimation.\n             `arXiv:1912.05559 <https://arxiv.org/abs/1912.05559>`_.\n        [2]: Brassard, G., Hoyer, P., Mosca, M., & Tapp, A. (2000).\n             Quantum Amplitude Amplification and Estimation.\n             `arXiv:quant-ph/0005055 <http://arxiv.org/abs/quant-ph/0005055>`_.\n    ")
arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon_target', annotation=Name(id='float', ctx=Load())), arg(arg='alpha', annotation=Name(id='float', ctx=Load())), arg(arg='confint_method', annotation=Name(id='str', ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Str(s='beta'), Num(n=2), NameConstant(value=None)])
Expr(value=Str(s="\n        The output of the algorithm is an estimate for the amplitude `a`, that with at least\n        probability 1 - alpha has an error of epsilon. The number of A operator calls scales\n        linearly in 1/epsilon (up to a logarithmic factor).\n\n        Args:\n            epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n            alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n            confint_method: Statistical method used to estimate the confidence intervals in\n                each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n                Clopper-Pearson intervals (default)\n            min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            AlgorithmError: if the method to compute the confidence intervals is not supported\n            ValueError: If the target epsilon is not in (0, 0.5]\n            ValueError: If alpha is not in (0, 1)\n            ValueError: If confint_method is not supported\n        "))
If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[])
If(test=UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[]), cause=None)], orelse=[])
If(test=Compare(left=Name(id='confint_method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Str(s='chernoff'), Str(s='beta')])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)], orelse=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon_target', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='alpha', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Store())], value=Name(id='min_ratio', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Store())], value=Name(id='confint_method', ctx=Load()))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the target precision ``epsilon_target`` of the algorithm.\n\n        Returns:\n            The target precision (which is half the width of the confidence interval).\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the target precision of the algorithm.\n\n        Args:\n            epsilon: Target precision for estimation target `a`.\n        '))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load()))
Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='upper_half_circle', annotation=Name(id='bool', ctx=Load())), arg(arg='theta_interval', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=2.0)])
Expr(value=Str(s='Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\n        lies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\n        Args:\n            k: The current power of the Q operator.\n            upper_half_circle: Boolean flag of whether theta_interval lies in the\n                upper half-circle [0, pi] or in the lower one [pi, 2pi].\n            theta_interval: The current confidence interval for the angle theta,\n                i.e. (theta_lower, theta_upper).\n            min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\n        Returns:\n            The next power k, and boolean flag for the extrapolated interval.\n\n        Raises:\n            AlgorithmError: if min_ratio is smaller or equal to 1\n        '))
If(test=Compare(left=Name(id='min_ratio', ctx=Load()), ops=[LtE()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Tuple(elts=[Name(id='theta_l', ctx=Store()), Name(id='theta_u', ctx=Store())], ctx=Store())], value=Name(id='theta_interval', ctx=Load()))
Assign(targets=[Name(id='old_scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2)))
Assign(targets=[Name(id='max_scaling', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))], keywords=[]))
Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4))))
While(test=Compare(left=Name(id='scaling', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))]), body=[Assign(targets=[Name(id='theta_min', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]))), Assign(targets=[Name(id='theta_max', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]))), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])]), AugAssign(target=Name(id='scaling', ctx=Store()), op=Sub(), value=Num(n=4))], orelse=[])
Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)])
Expr(value=Str(s='Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\n        The A operator is the unitary specifying the QAE problem and Q the associated Grover\n        operator.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            k: The power of the Q operator.\n            measurement: Boolean flag to indicate if measurements should be included in the\n                circuits.\n\n        Returns:\n            The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n        '))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='circuit'))]))
If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
If(test=Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))], orelse=[])
If(test=Name(id='measurement', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))], orelse=[])
Return(value=Name(id='circuit', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='EstimationProblem', ctx=Load())), arg(arg='counts_or_statevector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s="Get the probability to measure '1' in the last qubit.\n\n        Args:\n            problem: The estimation problem, used to obtain the number of objective qubits and\n                the ``is_good_state`` function.\n            counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n                the statevector returned from the statevector_simulator.\n            num_state_qubits: The number of state qubits.\n\n        Returns:\n            If a dict is given, return (#one-counts, #one-counts/#all-counts),\n            otherwise Pr(measure '1' in the last qubit).\n        "))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='counts_or_statevector', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='one_counts', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])], orelse=[]), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load()))], orelse=[Assign(targets=[Name(id='statevector', ctx=Store())], value=Name(id='counts_or_statevector', ctx=Load())), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])], orelse=[]), Return(value=Name(id='prob', ctx=Load()))])
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Assign(targets=[Name(id='powers', ctx=Store())], value=List(elts=[Num(n=0)], ctx=Load()))
Assign(targets=[Name(id='ratios', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='theta_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())], ctx=Load()))
Assign(targets=[Name(id='a_intervals', ctx=Store())], value=List(elts=[List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())], ctx=Load()))
Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))
Assign(targets=[Name(id='num_one_shots', ctx=Store())], value=List(elts=[], ctx=Load()))
Assign(targets=[Name(id='max_rounds', ctx=Store())], value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[]), op=Add(), right=Num(n=1)))
Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='statevector', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_confidence_interval', ctx=Store())], value=List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta_i_interval', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)])), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))], orelse=[Assign(targets=[Name(id='num_iterations', ctx=Store())], value=Num(n=0)), Assign(targets=[Name(id='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())), While(test=Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))]), body=[AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1)), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load())), Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))]), If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))]), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])])
Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]))
Assign(targets=[Name(id='estimation', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='confidence_interval', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='IterativeAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='alpha', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())], value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())], value=Name(id='num_oracle_queries', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())], value=Name(id='estimation', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())], value=Name(id='confidence_interval', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())], value=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='estimation', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='confidence_interval', ctx=Store())], value=Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())], value=Name(id='confidence_interval', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated_processed', ctx=Store())], value=BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='estimate_intervals', ctx=Store())], value=Name(id='a_intervals', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='theta_intervals', ctx=Store())], value=Name(id='theta_intervals', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='powers', ctx=Store())], value=Name(id='powers', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='ratios', ctx=Store())], value=Name(id='ratios', ctx=Load()))
Return(value=Name(id='result', ctx=Load()))
Str(s='IterativeAmplitudeEstimationResult')
Load()
Str(s='The ``IterativeAmplitudeEstimation`` result object.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=NameConstant(value=None))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the confidence level :math:`\\alpha`.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the confidence level :math:`\\alpha`.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='alpha', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the target half-width of the confidence interval.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the target half-width of the confidence interval.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='epsilon_target', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the estimated half-width of the confidence interval.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the estimated half-width of the confidence interval.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='epsilon_estimated', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the post-processed estimated half-width of the confidence interval.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the post-processed estimated half-width of the confidence interval.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='epsilon_estimated_processed', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the confidence intervals for the estimate in each iteration.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the confidence intervals for the estimate in each iteration.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='estimate_intervals', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the confidence intervals for the angles in each iteration.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the confidence intervals for the angles in each iteration.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the powers of the Grover operator in each iteration.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the powers of the Grover operator in each iteration.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='powers', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='ratios', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the post-processed confidence interval.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Load()))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the post-processed confidence interval.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='confidence_interval_processed', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
arg(arg='shots', annotation=Name(id='int', ctx=Load()))
arg(arg='max_rounds', annotation=Name(id='int', ctx=Load()))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
Str(s='Compute the Chernoff confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    The confidence interval is\n\n        [value - eps, value + eps], where eps = sqrt(3 * log(2 * max_rounds/ alpha) / shots)\n\n    but at most [0, 1].\n\n    Args:\n        value: The current estimate.\n        shots: The number of shots.\n        max_rounds: The maximum number of rounds, used to compute epsilon_a.\n        alpha: The confidence level, used to compute epsilon_a.\n\n    Returns:\n        The Chernoff confidence interval.\n    ')
Name(id='eps', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])), op=Div(), right=Name(id='shots', ctx=Load()))], keywords=[])
Name(id='lower', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='maximum', ctx=Load()), args=[Num(n=0), BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='eps', ctx=Load()))], keywords=[])
Name(id='upper', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='minimum', ctx=Load()), args=[Num(n=1), BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='eps', ctx=Load()))], keywords=[])
Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='counts', annotation=Name(id='int', ctx=Load()))
arg(arg='shots', annotation=Name(id='int', ctx=Load()))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
Str(s='Compute the Clopper-Pearson confidence interval for `shots` i.i.d. Bernoulli trials.\n\n    Args:\n        counts: The number of positive counts.\n        shots: The number of shots.\n        alpha: The confidence level for the confidence interval.\n\n    Returns:\n        The Clopper-Pearson confidence interval.\n    ')
Tuple(elts=[Name(id='lower', ctx=Store()), Name(id='upper', ctx=Store())], ctx=Store())
Tuple(elts=[Num(n=0), Num(n=1)], ctx=Load())
Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)])
Assign(targets=[Name(id='lower', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)), Name(id='counts', ctx=Load()), BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))], keywords=[]))
Compare(left=Name(id='counts', ctx=Load()), ops=[NotEq()], comparators=[Name(id='shots', ctx=Load())])
Assign(targets=[Name(id='upper', ctx=Store())], value=Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))), BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1)), BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))], keywords=[]))
Tuple(elts=[Name(id='lower', ctx=Load()), Name(id='upper', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='epsilon_target', annotation=Name(id='float', ctx=Load()))
arg(arg='alpha', annotation=Name(id='float', ctx=Load()))
arg(arg='confint_method', annotation=Name(id='str', ctx=Load()))
arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='beta')
Num(n=2)
NameConstant(value=None)
Str(s="\n        The output of the algorithm is an estimate for the amplitude `a`, that with at least\n        probability 1 - alpha has an error of epsilon. The number of A operator calls scales\n        linearly in 1/epsilon (up to a logarithmic factor).\n\n        Args:\n            epsilon_target: Target precision for estimation target `a`, has values between 0 and 0.5\n            alpha: Confidence level, the target probability is 1 - alpha, has values between 0 and 1\n            confint_method: Statistical method used to estimate the confidence intervals in\n                each iteration, can be 'chernoff' for the Chernoff intervals or 'beta' for the\n                Clopper-Pearson intervals (default)\n            min_ratio: Minimal q-ratio (:math:`K_{i+1} / K_i`) for FindNextK\n            quantum_instance: Quantum Instance or Backend\n\n        Raises:\n            AlgorithmError: if the method to compute the confidence intervals is not supported\n            ValueError: If the target epsilon is not in (0, 0.5]\n            ValueError: If alpha is not in (0, 1)\n            ValueError: If confint_method is not supported\n        ")
UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)]))
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)
UnaryOp(op=Not(), operand=Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)]))
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[]), cause=None)
Compare(left=Name(id='confint_method', ctx=Load()), ops=[NotIn()], comparators=[Set(elts=[Str(s='chernoff'), Str(s='beta')])])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())
Name(id='epsilon_target', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())
Name(id='alpha', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Store())
Name(id='min_ratio', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Store())
Name(id='confint_method', ctx=Load())
arg(arg='self', annotation=None)
Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns the target precision ``epsilon_target`` of the algorithm.\n\n        Returns:\n            The target precision (which is half the width of the confidence interval).\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))
Str(s='Set the target precision of the algorithm.\n\n        Args:\n            epsilon: Target precision for estimation target `a`.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())
Name(id='epsilon', ctx=Load())
Name(id='epsilon_target', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='k', annotation=Name(id='int', ctx=Load()))
arg(arg='upper_half_circle', annotation=Name(id='bool', ctx=Load()))
arg(arg='theta_interval', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='min_ratio', annotation=Name(id='float', ctx=Load()))
Num(n=2.0)
Str(s='Find the largest integer k_next, such that the interval (4 * k_next + 2)*theta_interval\n        lies completely in [0, pi] or [pi, 2pi], for theta_interval = (theta_lower, theta_upper).\n\n        Args:\n            k: The current power of the Q operator.\n            upper_half_circle: Boolean flag of whether theta_interval lies in the\n                upper half-circle [0, pi] or in the lower one [pi, 2pi].\n            theta_interval: The current confidence interval for the angle theta,\n                i.e. (theta_lower, theta_upper).\n            min_ratio: Minimal ratio K/K_next allowed in the algorithm.\n\n        Returns:\n            The next power k, and boolean flag for the extrapolated interval.\n\n        Raises:\n            AlgorithmError: if min_ratio is smaller or equal to 1\n        ')
Compare(left=Name(id='min_ratio', ctx=Load()), ops=[LtE()], comparators=[Num(n=1)])
Raise(exc=Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[]), cause=None)
Tuple(elts=[Name(id='theta_l', ctx=Store()), Name(id='theta_u', ctx=Store())], ctx=Store())
Name(id='theta_interval', ctx=Load())
Name(id='old_scaling', ctx=Store())
BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))
Name(id='max_scaling', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))], keywords=[])
Name(id='scaling', ctx=Store())
BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4)))
Compare(left=Name(id='scaling', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))])
Assign(targets=[Name(id='theta_min', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[])))
Assign(targets=[Name(id='theta_max', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[])))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])])
AugAssign(target=Name(id='scaling', ctx=Store()), op=Sub(), value=Num(n=4))
Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
arg(arg='k', annotation=Name(id='int', ctx=Load()))
arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))
Num(n=0)
NameConstant(value=False)
Str(s='Construct the circuit :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n\n        The A operator is the unitary specifying the QAE problem and Q the associated Grover\n        operator.\n\n        Args:\n            estimation_problem: The estimation problem for which to construct the QAE circuit.\n            k: The power of the Q operator.\n            measurement: Boolean flag to indicate if measurements should be included in the\n                circuits.\n\n        Returns:\n            The circuit implementing :math:`\\mathcal{Q}^k \\mathcal{A} |0\\rangle`.\n        ')
Name(id='num_qubits', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load()), Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='circuit'))])
Name(id='measurement', ctx=Load())
Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Compare(left=Name(id='k', ctx=Load()), ops=[NotEq()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
Name(id='measurement', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))
Name(id='circuit', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='problem', annotation=Name(id='EstimationProblem', ctx=Load()))
arg(arg='counts_or_statevector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='num_state_qubits', annotation=Name(id='int', ctx=Load()))
Str(s="Get the probability to measure '1' in the last qubit.\n\n        Args:\n            problem: The estimation problem, used to obtain the number of objective qubits and\n                the ``is_good_state`` function.\n            counts_or_statevector: Either a counts-dictionary (with one measured qubit only!) or\n                the statevector returned from the statevector_simulator.\n            num_state_qubits: The number of state qubits.\n\n        Returns:\n            If a dict is given, return (#one-counts, #one-counts/#all-counts),\n            otherwise Pr(measure '1' in the last qubit).\n        ")
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='counts_or_statevector', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])
Assign(targets=[Name(id='one_counts', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])], orelse=[])
Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load()))
Assign(targets=[Name(id='statevector', ctx=Store())], value=Name(id='counts_or_statevector', ctx=Load()))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='prob', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])), If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])], orelse=[])
Return(value=Name(id='prob', ctx=Load()))
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='estimation_problem', annotation=Name(id='EstimationProblem', ctx=Load()))
Name(id='powers', ctx=Store())
List(elts=[Num(n=0)], ctx=Load())
Name(id='ratios', ctx=Store())
List(elts=[], ctx=Load())
Name(id='theta_intervals', ctx=Store())
List(elts=[List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())], ctx=Load())
Name(id='a_intervals', ctx=Store())
List(elts=[List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())], ctx=Load())
Name(id='num_oracle_queries', ctx=Store())
Num(n=0)
Name(id='num_one_shots', ctx=Store())
List(elts=[], ctx=Load())
Name(id='max_rounds', ctx=Store())
BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[]), op=Add(), right=Num(n=1))
Name(id='upper_half_circle', ctx=Store())
NameConstant(value=True)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))]))
Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='statevector', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load())))
Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='prob', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='a_confidence_interval', ctx=Store())], value=List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load()))
Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='theta_i_interval', ctx=Store())], value=ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)]))
Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='num_oracle_queries', ctx=Store())], value=Num(n=0))
Assign(targets=[Name(id='num_iterations', ctx=Store())], value=Num(n=0))
Assign(targets=[Name(id='shots', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load()))
While(test=Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))]), body=[AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1)), Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])), Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))), Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])), AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1)), Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load())), Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))]), If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))]), Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))), Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))), Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])), Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])
Name(id='confidence_interval', ctx=Store())
Call(func=Name(id='tuple', ctx=Load()), args=[Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Name(id='estimation', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load()), args=[Name(id='confidence_interval', ctx=Load())], keywords=[])
Name(id='result', ctx=Store())
Call(func=Name(id='IterativeAmplitudeEstimationResult', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='alpha', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='post_processing', ctx=Store())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='num_oracle_queries', ctx=Store())
Name(id='num_oracle_queries', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation', ctx=Store())
Name(id='estimation', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated', ctx=Store())
BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))
Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval', ctx=Store())
Name(id='confidence_interval', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='estimation_processed', ctx=Store())
Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='estimation', ctx=Load())], keywords=[])
Name(id='confidence_interval', ctx=Store())
Call(func=Name(id='tuple', ctx=Load()), args=[GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='confidence_interval_processed', ctx=Store())
Name(id='confidence_interval', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='epsilon_estimated_processed', ctx=Store())
BinOp(left=BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), op=Div(), right=Num(n=2))
Attribute(value=Name(id='result', ctx=Load()), attr='estimate_intervals', ctx=Store())
Name(id='a_intervals', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='theta_intervals', ctx=Store())
Name(id='theta_intervals', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='powers', ctx=Store())
Name(id='powers', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='ratios', ctx=Store())
Name(id='ratios', ctx=Load())
Name(id='result', ctx=Load())
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())
NameConstant(value=None)
arg(arg='self', annotation=None)
Str(s='Return the confidence level :math:`\\alpha`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the confidence level :math:`\\alpha`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Store())
Name(id='value', ctx=Load())
Name(id='alpha', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the target half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the target half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_target', ctx=Store())
Name(id='value', ctx=Load())
Name(id='epsilon_target', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the estimated half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the estimated half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated', ctx=Store())
Name(id='value', ctx=Load())
Name(id='epsilon_estimated', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the post-processed estimated half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Set the post-processed estimated half-width of the confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_estimated_processed', ctx=Store())
Name(id='value', ctx=Load())
Name(id='epsilon_estimated_processed', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the confidence intervals for the estimate in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Set the confidence intervals for the estimate in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_intervals', ctx=Store())
Name(id='value', ctx=Load())
Name(id='estimate_intervals', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the confidence intervals for the angles in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Set the confidence intervals for the angles in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_theta_intervals', ctx=Store())
Name(id='value', ctx=Load())
Name(id='theta_intervals', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the powers of the Grover operator in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Str(s='Set the powers of the Grover operator in each iteration.')
Attribute(value=Name(id='self', ctx=Load()), attr='_powers', ctx=Store())
Name(id='value', ctx=Load())
Name(id='powers', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Load())
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Str(s='Set the ratios :math:`K_{i+1}/K_{i}` for each iteration :math:`i`.')
Attribute(value=Name(id='self', ctx=Load()), attr='_ratios', ctx=Store())
Name(id='value', ctx=Load())
Name(id='ratios', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Return the post-processed confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Load())
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()))
Str(s='Set the post-processed confidence interval.')
Attribute(value=Name(id='self', ctx=Load()), attr='_confidence_interval_processed', ctx=Store())
Name(id='value', ctx=Load())
Name(id='confidence_interval_processed', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])), op=Div(), right=Name(id='shots', ctx=Load()))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='maximum', ctx=Load())
Num(n=0)
BinOp(left=Name(id='value', ctx=Load()), op=Sub(), right=Name(id='eps', ctx=Load()))
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='minimum', ctx=Load())
Num(n=1)
BinOp(left=Name(id='value', ctx=Load()), op=Add(), right=Name(id='eps', ctx=Load()))
Name(id='lower', ctx=Load())
Name(id='upper', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Name(id='lower', ctx=Store())
Name(id='upper', ctx=Store())
Store()
Num(n=0)
Num(n=1)
Load()
Name(id='counts', ctx=Load())
NotEq()
Num(n=0)
Name(id='lower', ctx=Store())
Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)), Name(id='counts', ctx=Load()), BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))], keywords=[])
Name(id='counts', ctx=Load())
NotEq()
Name(id='shots', ctx=Load())
Name(id='upper', ctx=Store())
Call(func=Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))), BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1)), BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))], keywords=[])
Name(id='lower', ctx=Load())
Name(id='upper', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Name(id='str', ctx=Load())
Name(id='float', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Not()
Compare(left=Num(n=0), ops=[Lt(), LtE()], comparators=[Name(id='epsilon_target', ctx=Load()), Num(n=0.5)])
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[])
Not()
Compare(left=Num(n=0), ops=[Lt(), Lt()], comparators=[Name(id='alpha', ctx=Load()), Num(n=1)])
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])], keywords=[])
Name(id='confint_method', ctx=Load())
NotIn()
Set(elts=[Str(s='chernoff'), Str(s='beta')])
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])], keywords=[])
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='int', ctx=Load())
Name(id='bool', ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='float', ctx=Load())
Name(id='min_ratio', ctx=Load())
LtE()
Num(n=1)
Call(func=Name(id='AlgorithmError', ctx=Load()), args=[Str(s='min_ratio must be larger than 1 to ensure convergence')], keywords=[])
Name(id='theta_l', ctx=Store())
Name(id='theta_u', ctx=Store())
Store()
Load()
Store()
BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load()))
Add()
Num(n=2)
Store()
Name(id='int', ctx=Load())
BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))))
Store()
Name(id='max_scaling', ctx=Load())
Sub()
BinOp(left=BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Mod(), right=Num(n=4))
Name(id='scaling', ctx=Load())
GtE()
BinOp(left=Name(id='min_ratio', ctx=Load()), op=Mult(), right=Name(id='old_scaling', ctx=Load()))
Name(id='theta_min', ctx=Store())
BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]))
Name(id='theta_max', ctx=Store())
BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load())), op=Sub(), right=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]))
BoolOp(op=And(), values=[Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)]), Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])])
Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=True))
Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])]), body=[Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False)), Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))], orelse=[])
Name(id='scaling', ctx=Store())
Sub()
Num(n=4)
Call(func=Name(id='int', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])
Name(id='upper_half_circle', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='int', ctx=Load()), Name(id='bool', ctx=Load())], ctx=Load())
Name(id='EstimationProblem', ctx=Load())
Name(id='int', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Name(id='max', ctx=Load())
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load()), attr='num_qubits', ctx=Load())
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='num_qubits', ctx=Load())
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='num_qubits', ctx=Load())
keyword(arg='name', value=Str(s='circuit'))
Load()
Name(id='c', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())
keyword(arg='inplace', value=NameConstant(value=True))
Name(id='k', ctx=Load())
NotEq()
Num(n=0)
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Load()
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load()), Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])
Load()
Name(id='EstimationProblem', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='int', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='counts_or_statevector', ctx=Load())
Name(id='dict', ctx=Load())
Name(id='one_counts', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='state', ctx=Store()), Name(id='counts', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[])
If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))], orelse=[])
Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]), BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))], ctx=Load())
Name(id='statevector', ctx=Store())
Name(id='counts_or_statevector', ctx=Load())
Name(id='num_qubits', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='prob', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='amplitude', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])
Assign(targets=[Name(id='bitstr', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Assign(targets=[Name(id='objectives', ctx=Store())], value=ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)]))
If(test=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))], orelse=[])
Name(id='prob', ctx=Load())
Load()
Tuple(elts=[Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Name(id='EstimationProblem', ctx=Load())
Store()
Num(n=0)
Load()
Store()
Load()
Store()
List(elts=[Num(n=0), BinOp(left=Num(n=1), op=Div(), right=Num(n=4))], ctx=Load())
Load()
Store()
List(elts=[Num(n=0.0), Num(n=1.0)], ctx=Load())
Load()
Store()
Store()
Load()
Store()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))], keywords=[])
Add()
Num(n=1)
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='circuit', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load())], keywords=[keyword(arg='k', value=Num(n=0)), keyword(arg='measurement', value=NameConstant(value=False))])
Name(id='ret', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='statevector', ctx=Store())
Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='num_qubits', ctx=Store())
BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))
Name(id='prob', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='statevector', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])
Name(id='prob', ctx=Store())
Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='prob', ctx=Load())], keywords=[])
Name(id='a_confidence_interval', ctx=Store())
List(elts=[Name(id='prob', ctx=Load()), Name(id='prob', ctx=Load())], ctx=Load())
Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='a_confidence_interval', ctx=Load())], keywords=[])
Name(id='theta_i_interval', ctx=Store())
ListComp(elt=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), generators=[comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)])
Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='theta_i_interval', ctx=Load())], keywords=[])
Name(id='num_oracle_queries', ctx=Store())
Num(n=0)
Name(id='num_iterations', ctx=Store())
Num(n=0)
Name(id='shots', ctx=Store())
Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load()), attr='shots', ctx=Load())
Compare(left=BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), ops=[Gt()], comparators=[BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))])
AugAssign(target=Name(id='num_iterations', ctx=Store()), op=Add(), value=Num(n=1))
Assign(targets=[Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))]))
Expr(value=Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[]))
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))]))
Assign(targets=[Name(id='ret', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='num_qubits', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load())))
Assign(targets=[Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[]))
AugAssign(target=Name(id='num_oracle_queries', ctx=Store()), op=Add(), value=BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load())))
Assign(targets=[Name(id='j', ctx=Store())], value=Num(n=1))
Assign(targets=[Name(id='round_shots', ctx=Store())], value=Name(id='shots', ctx=Load()))
Assign(targets=[Name(id='round_one_counts', ctx=Store())], value=Name(id='one_counts', ctx=Load()))
If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)]), body=[While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])], orelse=[])
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')]), body=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))])
If(test=Name(id='upper_half_circle', ctx=Load()), body=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))], orelse=[Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))), Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))])
Assign(targets=[Name(id='scaling', ctx=Store())], value=BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2)))
Assign(targets=[Name(id='theta_u', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load())))
Assign(targets=[Name(id='theta_l', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load())))
Expr(value=Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[]))
Assign(targets=[Name(id='a_u', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2)))
Assign(targets=[Name(id='a_l', ctx=Store())], value=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2)))
Assign(targets=[Name(id='a_u', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='a_l', ctx=Store())], value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[]))
Store()
Name(id='tuple', ctx=Load())
Subscript(value=Name(id='a_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='mean', ctx=Load())
Name(id='confidence_interval', ctx=Load())
Store()
Name(id='IterativeAmplitudeEstimationResult', ctx=Load())
Name(id='result', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Div()
Num(n=2)
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='estimation', ctx=Load())
Store()
Name(id='tuple', ctx=Load())
GeneratorExp(elt=Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[]), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)])
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
BinOp(left=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Div()
Num(n=2)
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Load()
Load()
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=Num(n=3), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[]))
Div()
Name(id='shots', ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='value', ctx=Load())
Sub()
Name(id='eps', ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='value', ctx=Load())
Add()
Name(id='eps', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Store()
Load()
Store()
Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load())
BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))
Name(id='counts', ctx=Load())
BinOp(left=BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load())), op=Add(), right=Num(n=1))
Load()
Load()
Store()
Attribute(value=Name(id='beta', ctx=Load()), attr='ppf', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2)))
BinOp(left=Name(id='counts', ctx=Load()), op=Add(), right=Num(n=1))
BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))
Load()
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Num(n=0)
Lt()
LtE()
Name(id='epsilon_target', ctx=Load())
Num(n=0.5)
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The target epsilon must be in (0, 0.5], but is '), FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])
Num(n=0)
Lt()
Lt()
Name(id='alpha', ctx=Load())
Num(n=1)
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The confidence level alpha must be in (0, 1), but is '), FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)])
Load()
Str(s='chernoff')
Str(s='beta')
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The confidence interval method must be chernoff or beta, but is '), FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None), Str(s='.')])
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Name(id='AlgorithmError', ctx=Load())
Str(s='min_ratio must be larger than 1 to ensure convergence')
Store()
Store()
Num(n=4)
Mult()
Name(id='k', ctx=Load())
Load()
Num(n=1)
Div()
BinOp(left=Num(n=2), op=Mult(), right=BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load())))
Load()
BinOp(left=Name(id='max_scaling', ctx=Load()), op=Sub(), right=Num(n=2))
Mod()
Num(n=4)
Load()
Name(id='min_ratio', ctx=Load())
Mult()
Name(id='old_scaling', ctx=Load())
Store()
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))
Sub()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[])
Store()
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))
Sub()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[])
And()
Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE(), LtE()], comparators=[Name(id='theta_max', ctx=Load()), Num(n=0.5)])
Compare(left=Name(id='theta_min', ctx=Load()), ops=[LtE()], comparators=[Num(n=0.5)])
Name(id='upper_half_circle', ctx=Store())
NameConstant(value=True)
Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load())
BoolOp(op=And(), values=[Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)]), Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])])
Assign(targets=[Name(id='upper_half_circle', ctx=Store())], value=NameConstant(value=False))
Return(value=Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load()))
Store()
Name(id='int', ctx=Load())
Name(id='k', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='bool', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='state_preparation', ctx=Load())
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Load()
Str(s='circuit')
Store()
Name(id='ClassicalRegister', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())], keywords=[])
Attribute(value=Name(id='circuit', ctx=Load()), attr='add_register', ctx=Load())
Name(id='c', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
NameConstant(value=True)
Load()
Attribute(value=Name(id='circuit', ctx=Load()), attr='compose', ctx=Load())
Call(func=Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])
keyword(arg='inplace', value=NameConstant(value=True))
Attribute(value=Name(id='circuit', ctx=Load()), attr='barrier', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='measure', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Subscript(value=Name(id='c', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Store()
Name(id='state', ctx=Store())
Name(id='counts', ctx=Store())
Store()
Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='items', ctx=Load())
Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='state', ctx=Load())], keywords=[])
AugAssign(target=Name(id='one_counts', ctx=Store()), op=Add(), value=Name(id='counts', ctx=Load()))
Call(func=Name(id='int', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])
BinOp(left=Name(id='one_counts', ctx=Load()), op=Div(), right=Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[]))
Load()
Store()
Load()
Store()
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])], keywords=[])
Store()
Name(id='i', ctx=Store())
Name(id='amplitude', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='statevector', ctx=Load())
Name(id='bitstr', ctx=Store())
Subscript(value=Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Name(id='objectives', ctx=Store())
ListComp(elt=Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load()), generators=[comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)])
Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load()), args=[Name(id='objectives', ctx=Load())], keywords=[])
Assign(targets=[Name(id='prob', ctx=Store())], value=BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))))
Load()
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='float', ctx=Load())
Load()
Load()
Num(n=0)
BinOp(left=Num(n=1), op=Div(), right=Num(n=4))
Load()
Num(n=0.0)
Num(n=1.0)
Load()
Name(id='int', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[]))
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='estimation_problem', ctx=Load())
keyword(arg='k', value=Num(n=0))
keyword(arg='measurement', value=NameConstant(value=False))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Attribute(value=Name(id='ret', ctx=Load()), attr='get_statevector', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load())
Sub()
Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Name(id='statevector', ctx=Load())
Name(id='num_qubits', ctx=Load())
Store()
Name(id='cast', ctx=Load())
Name(id='float', ctx=Load())
Name(id='prob', ctx=Load())
Store()
Name(id='prob', ctx=Load())
Name(id='prob', ctx=Load())
Load()
Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load())
Name(id='a_confidence_interval', ctx=Load())
Store()
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
comprehension(target=Name(id='a_i', ctx=Store()), iter=Name(id='a_confidence_interval', ctx=Load()), ifs=[], is_async=0)
Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load())
Name(id='theta_i_interval', ctx=Load())
Store()
Store()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='_run_config', ctx=Load())
Load()
BinOp(left=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), op=Sub(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Gt()
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Name(id='num_iterations', ctx=Store())
Add()
Num(n=1)
Tuple(elts=[Name(id='k', ctx=Store()), Name(id='upper_half_circle', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load()), args=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), Name(id='upper_half_circle', ctx=Load()), Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))])
Call(func=Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='k', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))], keywords=[])
Name(id='circuit', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='k', ctx=Load())], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])
Name(id='ret', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='counts', ctx=Store())
Call(func=Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Name(id='num_qubits', ctx=Store())
BinOp(left=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load()), op=Sub(), right=Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))
Tuple(elts=[Name(id='one_counts', ctx=Store()), Name(id='prob', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load()), args=[Name(id='estimation_problem', ctx=Load()), Name(id='counts', ctx=Load()), Name(id='num_qubits', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='one_counts', ctx=Load())], keywords=[])
Name(id='num_oracle_queries', ctx=Store())
Add()
BinOp(left=Name(id='shots', ctx=Load()), op=Mult(), right=Name(id='k', ctx=Load()))
Name(id='j', ctx=Store())
Num(n=1)
Name(id='round_shots', ctx=Store())
Name(id='shots', ctx=Load())
Name(id='round_one_counts', ctx=Store())
Name(id='one_counts', ctx=Load())
Compare(left=Name(id='num_iterations', ctx=Load()), ops=[Gt()], comparators=[Num(n=1)])
While(test=BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])]), body=[Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))), AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load())), AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))], orelse=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load()), ops=[Eq()], comparators=[Str(s='chernoff')])
Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[]))
Assign(targets=[Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())], value=Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[]))
Name(id='upper_half_circle', ctx=Load())
Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Assign(targets=[Name(id='theta_min_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))
Assign(targets=[Name(id='theta_max_i', ctx=Store())], value=BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))))
Name(id='scaling', ctx=Store())
BinOp(left=BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load())), op=Add(), right=Num(n=2))
Name(id='theta_u', ctx=Store())
BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))
Name(id='theta_l', ctx=Store())
BinOp(left=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load())), op=Div(), right=Name(id='scaling', ctx=Load()))
Call(func=Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())], keywords=[])
Name(id='a_u', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='a_l', ctx=Store())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[]), op=Pow(), right=Num(n=2))
Name(id='a_u', ctx=Store())
Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_u', ctx=Load())], keywords=[])
Name(id='a_l', ctx=Store())
Call(func=Name(id='cast', ctx=Load()), args=[Name(id='float', ctx=Load()), Name(id='a_l', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load()), args=[List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())], keywords=[])
Load()
Name(id='a_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Sub()
Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Load()
Call(func=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])
comprehension(target=Name(id='x', ctx=Store()), iter=Name(id='confidence_interval', ctx=Load()), ifs=[], is_async=0)
Load()
Load()
Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Sub()
Subscript(value=Name(id='confidence_interval', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Load()
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Num(n=3)
Mult()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='beta', ctx=Load())
Load()
Name(id='alpha', ctx=Load())
Div()
Num(n=2)
Load()
BinOp(left=Name(id='shots', ctx=Load()), op=Sub(), right=Name(id='counts', ctx=Load()))
Add()
Num(n=1)
Name(id='beta', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Name(id='alpha', ctx=Load()), op=Div(), right=Num(n=2))
Name(id='counts', ctx=Load())
Add()
Num(n=1)
Name(id='shots', ctx=Load())
Sub()
Name(id='counts', ctx=Load())
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Str(s='The target epsilon must be in (0, 0.5], but is ')
FormattedValue(value=Name(id='epsilon_target', ctx=Load()), conversion=-1, format_spec=None)
Str(s='.')
Load()
Load()
Str(s='The confidence level alpha must be in (0, 1), but is ')
FormattedValue(value=Name(id='alpha', ctx=Load()), conversion=-1, format_spec=None)
Load()
Str(s='The confidence interval method must be chernoff or beta, but is ')
FormattedValue(value=Name(id='confint_method', ctx=Load()), conversion=-1, format_spec=None)
Str(s='.')
Name(id='super', ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Load()
Load()
Num(n=2)
Mult()
BinOp(left=Name(id='theta_u', ctx=Load()), op=Sub(), right=Name(id='theta_l', ctx=Load()))
Name(id='max_scaling', ctx=Load())
Sub()
Num(n=2)
Load()
Load()
Name(id='scaling', ctx=Load())
Mult()
Name(id='theta_l', ctx=Load())
Name(id='int', ctx=Load())
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_l', ctx=Load()))
Name(id='scaling', ctx=Load())
Mult()
Name(id='theta_u', ctx=Load())
Name(id='int', ctx=Load())
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Name(id='theta_u', ctx=Load()))
Name(id='theta_min', ctx=Load())
LtE()
LtE()
Name(id='theta_max', ctx=Load())
Num(n=0.5)
Name(id='theta_min', ctx=Load())
LtE()
Num(n=0.5)
Store()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[])
Name(id='upper_half_circle', ctx=Load())
Load()
And()
Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE()], comparators=[Num(n=0.5)])
Compare(left=Name(id='theta_max', ctx=Load()), ops=[GtE(), GtE()], comparators=[Name(id='theta_min', ctx=Load()), Num(n=0.5)])
Name(id='upper_half_circle', ctx=Store())
NameConstant(value=False)
Tuple(elts=[Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[]), Name(id='upper_half_circle', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Name(id='len', ctx=Load())
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load()), attr='power', ctx=Load())
Name(id='k', ctx=Load())
NameConstant(value=True)
Name(id='circuit', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='c', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Store()
Store()
Name(id='counts_or_statevector', ctx=Load())
Load()
Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load())
Name(id='state', ctx=Load())
Name(id='one_counts', ctx=Store())
Add()
Name(id='counts', ctx=Load())
Name(id='int', ctx=Load())
Name(id='one_counts', ctx=Load())
Name(id='one_counts', ctx=Load())
Div()
Call(func=Name(id='sum', ctx=Load()), args=[Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='statevector', ctx=Load())], keywords=[])
Store()
Store()
Load()
Load()
Store()
Subscript(value=Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]), slice=Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None), ctx=Load())
Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Store()
Subscript(value=Name(id='bitstr', ctx=Load()), slice=Index(value=Name(id='index', ctx=Load())), ctx=Load())
comprehension(target=Name(id='index', ctx=Store()), iter=Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load()), ifs=[], is_async=0)
Attribute(value=Name(id='problem', ctx=Load()), attr='is_good_state', ctx=Load())
Name(id='objectives', ctx=Load())
Name(id='prob', ctx=Store())
BinOp(left=Name(id='prob', ctx=Load()), op=Add(), right=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)))
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()))
Load()
Load()
Num(n=1)
Div()
Num(n=4)
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))], keywords=[])
Div()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())], keywords=[])
Load()
Name(id='self', ctx=Load())
Load()
Load()
Num(n=0)
NameConstant(value=False)
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='ret', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='a_intervals', ctx=Load())
Load()
Load()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2))
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Name(id='a_i', ctx=Store())
Name(id='a_confidence_interval', ctx=Load())
Name(id='theta_intervals', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Sub()
Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load())
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Store()
Name(id='k', ctx=Store())
Name(id='upper_half_circle', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_find_next_k', ctx=Load())
Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Name(id='upper_half_circle', ctx=Load())
Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
keyword(arg='min_ratio', value=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()))
Attribute(value=Name(id='powers', ctx=Load()), attr='append', ctx=Load())
Name(id='k', ctx=Load())
Attribute(value=Name(id='ratios', ctx=Load()), attr='append', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1)), op=Div(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1)))
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Name(id='k', ctx=Load())
keyword(arg='measurement', value=NameConstant(value=True))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Attribute(value=Name(id='ret', ctx=Load()), attr='get_counts', ctx=Load())
Name(id='circuit', ctx=Load())
Store()
Attribute(value=Name(id='circuit', ctx=Load()), attr='num_qubits', ctx=Load())
Sub()
Attribute(value=Name(id='circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Name(id='one_counts', ctx=Store())
Name(id='prob', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_good_state_probability', ctx=Load())
Name(id='estimation_problem', ctx=Load())
Name(id='counts', ctx=Load())
Name(id='num_qubits', ctx=Load())
Attribute(value=Name(id='num_one_shots', ctx=Load()), attr='append', ctx=Load())
Name(id='one_counts', ctx=Load())
Store()
Name(id='shots', ctx=Load())
Mult()
Name(id='k', ctx=Load())
Store()
Store()
Load()
Store()
Load()
Name(id='num_iterations', ctx=Load())
Gt()
Num(n=1)
BoolOp(op=And(), values=[Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())]), Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])])
Assign(targets=[Name(id='j', ctx=Store())], value=BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1)))
AugAssign(target=Name(id='round_shots', ctx=Store()), op=Add(), value=Name(id='shots', ctx=Load()))
AugAssign(target=Name(id='round_one_counts', ctx=Store()), op=Add(), value=Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_confint_method', ctx=Load())
Eq()
Str(s='chernoff')
Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())
Call(func=Name(id='_chernoff_confint', ctx=Load()), args=[Name(id='prob', ctx=Load()), Name(id='round_shots', ctx=Load()), Name(id='max_rounds', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())], keywords=[])
Tuple(elts=[Name(id='a_i_min', ctx=Store()), Name(id='a_i_max', ctx=Store())], ctx=Store())
Call(func=Name(id='_clopper_pearson_confint', ctx=Load()), args=[Name(id='round_one_counts', ctx=Load()), Name(id='round_shots', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))], keywords=[])
Load()
Name(id='theta_min_i', ctx=Store())
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Name(id='theta_max_i', ctx=Store())
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Name(id='theta_min_i', ctx=Store())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Name(id='theta_max_i', ctx=Store())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Store()
BinOp(left=Num(n=4), op=Mult(), right=Name(id='k', ctx=Load()))
Add()
Num(n=2)
Store()
BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_max_i', ctx=Load()))
Div()
Name(id='scaling', ctx=Load())
Store()
BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[]), op=Add(), right=Name(id='theta_min_i', ctx=Load()))
Div()
Name(id='scaling', ctx=Load())
Attribute(value=Name(id='theta_intervals', ctx=Load()), attr='append', ctx=Load())
List(elts=[Name(id='theta_l', ctx=Load()), Name(id='theta_u', ctx=Load())], ctx=Load())
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))], keywords=[])
Pow()
Num(n=2)
Store()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load()), args=[BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))], keywords=[])
Pow()
Num(n=2)
Store()
Name(id='cast', ctx=Load())
Name(id='float', ctx=Load())
Name(id='a_u', ctx=Load())
Store()
Name(id='cast', ctx=Load())
Name(id='float', ctx=Load())
Name(id='a_l', ctx=Load())
Attribute(value=Name(id='a_intervals', ctx=Load()), attr='append', ctx=Load())
List(elts=[Name(id='a_l', ctx=Load()), Name(id='a_u', ctx=Load())], ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Name(id='confidence_interval', ctx=Load())
Index(value=Num(n=1))
Load()
Name(id='confidence_interval', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='post_processing', ctx=Load())
Name(id='x', ctx=Load())
Name(id='x', ctx=Store())
Name(id='confidence_interval', ctx=Load())
Name(id='confidence_interval', ctx=Load())
Index(value=Num(n=1))
Load()
Name(id='confidence_interval', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='super', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load())), op=Div(), right=Name(id='alpha', ctx=Load()))
Load()
Load()
Name(id='shots', ctx=Load())
Sub()
Name(id='counts', ctx=Load())
Load()
Name(id='alpha', ctx=Load())
Div()
Num(n=2)
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Name(id='epsilon_target', ctx=Load())
Name(id='alpha', ctx=Load())
Name(id='confint_method', ctx=Load())
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='theta_u', ctx=Load())
Sub()
Name(id='theta_l', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='scaling', ctx=Load())
Mult()
Name(id='theta_l', ctx=Load())
Load()
Load()
Load()
Name(id='scaling', ctx=Load())
Mult()
Name(id='theta_u', ctx=Load())
Load()
Load()
Load()
Name(id='int', ctx=Load())
BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))
Load()
Name(id='theta_max', ctx=Load())
GtE()
Num(n=0.5)
Name(id='theta_max', ctx=Load())
GtE()
GtE()
Name(id='theta_min', ctx=Load())
Num(n=0.5)
Store()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))], keywords=[])
Name(id='upper_half_circle', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='estimation_problem', ctx=Load()), attr='grover_operator', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='Dict', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())), ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Load()
Name(id='problem', ctx=Load())
Load()
Load()
Store()
Load()
Load()
Load()
Load()
Name(id='sum', ctx=Load())
Call(func=Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='statevector', ctx=Load())
Call(func=Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[])
Slice(lower=UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load())), upper=None, step=None)
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='bitstr', ctx=Load())
Index(value=Name(id='index', ctx=Load()))
Load()
Name(id='index', ctx=Store())
Attribute(value=Name(id='problem', ctx=Load()), attr='objective_qubits', ctx=Load())
Name(id='problem', ctx=Load())
Load()
Load()
Store()
Name(id='prob', ctx=Load())
Add()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Load()
Tuple(elts=[Name(id='int', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8)), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load()))
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))], keywords=[])
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Index(value=Num(n=1))
Load()
Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='self', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Name(id='powers', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Load()
Name(id='theta_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())
Name(id='powers', ctx=Load())
Load()
Load()
Name(id='ratios', ctx=Load())
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), op=Add(), right=Num(n=1))
Div()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())), op=Add(), right=Num(n=1))
Name(id='self', ctx=Load())
Load()
Load()
Load()
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='ret', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Store()
Store()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='num_one_shots', ctx=Load())
Load()
Load()
Load()
Load()
Load()
And()
Compare(left=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())])
Compare(left=Name(id='num_iterations', ctx=Load()), ops=[GtE()], comparators=[BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))])
Name(id='j', ctx=Store())
BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))
Name(id='round_shots', ctx=Store())
Add()
Name(id='shots', ctx=Load())
Name(id='round_one_counts', ctx=Store())
Add()
Subscript(value=Name(id='num_one_shots', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))), ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='a_i_min', ctx=Store())
Name(id='a_i_max', ctx=Store())
Store()
Name(id='_chernoff_confint', ctx=Load())
Name(id='prob', ctx=Load())
Name(id='round_shots', ctx=Load())
Name(id='max_rounds', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())
Name(id='a_i_min', ctx=Store())
Name(id='a_i_max', ctx=Store())
Store()
Name(id='_clopper_pearson_confint', ctx=Load())
Name(id='round_one_counts', ctx=Load())
Name(id='round_shots', ctx=Load())
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load()), op=Div(), right=Name(id='max_rounds', ctx=Load()))
Store()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2))
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Store()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2))
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Store()
Num(n=1)
Sub()
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Store()
Num(n=1)
Sub()
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2)), op=Div(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Num(n=4)
Mult()
Name(id='k', ctx=Load())
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))], keywords=[])
Add()
Name(id='theta_max_i', ctx=Load())
Load()
Call(func=Name(id='int', ctx=Load()), args=[BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], keywords=[])
Add()
Name(id='theta_min_i', ctx=Load())
Load()
Name(id='theta_intervals', ctx=Load())
Load()
Name(id='theta_l', ctx=Load())
Name(id='theta_u', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_u', ctx=Load()))
Attribute(value=Name(id='np', ctx=Load()), attr='sin', ctx=Load())
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='theta_l', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='a_intervals', ctx=Load())
Load()
Name(id='a_l', ctx=Load())
Name(id='a_u', ctx=Load())
Load()
USub()
Num(n=1)
Load()
Num(n=1)
Load()
Num(n=0)
Name(id='estimation_problem', ctx=Load())
Load()
Load()
Store()
Load()
Load()
Num(n=1)
Load()
Num(n=0)
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='max_rounds', ctx=Load()))
Div()
Name(id='alpha', ctx=Load())
Load()
Load()
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2))
Div()
Num(n=4)
Load()
Load()
Load()
Name(id='int', ctx=Load())
BinOp(left=BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2)), op=Div(), right=Num(n=4))
Load()
Load()
Name(id='estimation_problem', ctx=Load())
Load()
Name(id='Dict', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load()))
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='counts_or_statevector', ctx=Load()), attr='values', ctx=Load())
Load()
Load()
Load()
Attribute(value=Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()), attr='zfill', ctx=Load())
Name(id='num_qubits', ctx=Load())
UnaryOp(op=USub(), operand=Name(id='num_state_qubits', ctx=Load()))
USub()
Num(n=1)
Load()
Name(id='index', ctx=Load())
Store()
Name(id='problem', ctx=Load())
Load()
Load()
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Name(id='amplitude', ctx=Load())], keywords=[])
Pow()
Num(n=2)
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Div(), right=Num(n=8))
Div()
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load())))
Load()
Load()
Name(id='theta_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Num(n=1)
Name(id='theta_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Num(n=0)
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='self', ctx=Load())
Load()
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Add()
Num(n=1)
BinOp(left=Num(n=2), op=Mult(), right=Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()))
Add()
Num(n=1)
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))), ctx=Load())
Eq()
Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=Name(id='num_iterations', ctx=Load())), ctx=Load())
Name(id='num_iterations', ctx=Load())
GtE()
BinOp(left=Name(id='j', ctx=Load()), op=Add(), right=Num(n=1))
Store()
Name(id='j', ctx=Load())
Add()
Num(n=1)
Store()
Load()
Store()
Name(id='num_one_shots', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Name(id='j', ctx=Load())))
Load()
Load()
Store()
Store()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Store()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_alpha', ctx=Load())
Div()
Name(id='max_rounds', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[])
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[])
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2))
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[]), op=Div(), right=Num(n=2))
Div()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Name(id='int', ctx=Load())
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()))
Load()
Name(id='int', ctx=Load())
BinOp(left=Name(id='scaling', ctx=Load()), op=Mult(), right=Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Mult()
Name(id='theta_u', ctx=Load())
Name(id='np', ctx=Load())
Load()
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Mult()
Name(id='theta_l', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='max_rounds', ctx=Load())
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Name(id='scaling', ctx=Load())
Sub()
Num(n=2)
Load()
BinOp(left=Name(id='scaling', ctx=Load()), op=Sub(), right=Num(n=2))
Div()
Num(n=4)
Load()
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='int', ctx=Load())], ctx=Load())
Load()
Name(id='counts_or_statevector', ctx=Load())
Load()
Subscript(value=Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())
Load()
Load()
USub()
Name(id='num_state_qubits', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Name(id='amplitude', ctx=Load())
Load()
Load()
Load()
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load()), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Div()
Num(n=8)
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i', ctx=Load()))
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
UnaryOp(op=USub(), operand=Num(n=1))
USub()
Num(n=1)
USub()
Num(n=1)
Load()
Num(n=2)
Mult()
Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Num(n=2)
Mult()
Subscript(value=Name(id='powers', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())
Load()
Name(id='powers', ctx=Load())
Index(value=BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load())))
Load()
Name(id='powers', ctx=Load())
Index(value=Name(id='num_iterations', ctx=Load()))
Load()
Load()
Name(id='j', ctx=Load())
Add()
Num(n=1)
Load()
Load()
UnaryOp(op=USub(), operand=Name(id='j', ctx=Load()))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))], keywords=[])
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))], keywords=[])
Div()
Num(n=2)
Name(id='np', ctx=Load())
Load()
Load()
Name(id='scaling', ctx=Load())
Mult()
Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Load()
Name(id='scaling', ctx=Load())
Mult()
Subscript(value=Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='scaling', ctx=Load())
Sub()
Num(n=2)
Name(id='str', ctx=Load())
Name(id='int', ctx=Load())
Load()
Load()
Call(func=Name(id='bin', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])
Slice(lower=Num(n=2), upper=None, step=None)
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_min_ratio', ctx=Load())
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Load()
Num(n=2)
Mult()
Name(id='a_i', ctx=Load())
USub()
Num(n=1)
USub()
Num(n=1)
Name(id='powers', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='powers', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=2)))
Load()
Load()
BinOp(left=Name(id='num_iterations', ctx=Load()), op=Sub(), right=Name(id='j', ctx=Load()))
Load()
Name(id='num_iterations', ctx=Load())
Load()
USub()
Name(id='j', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load()))
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load()))
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load())))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='arccos', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load())))
Load()
Load()
Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Index(value=Num(n=1))
Load()
Load()
Subscript(value=Name(id='theta_intervals', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='bin', ctx=Load())
Name(id='i', ctx=Load())
Num(n=2)
Load()
Name(id='self', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Name(id='num_iterations', ctx=Load())
Sub()
Name(id='j', ctx=Load())
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='a_i_min', ctx=Load())
Load()
Num(n=2)
Mult()
Name(id='a_i_max', ctx=Load())
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_max', ctx=Load()))
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='a_i_min', ctx=Load()))
Name(id='theta_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Num(n=1)
Name(id='theta_intervals', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Num(n=0)
Load()
Load()
Load()
Load()
Load()
Load()
USub()
Num(n=1)
USub()
Num(n=2)
Load()
Load()
Load()
Load()
Load()
Num(n=2)
Mult()
Name(id='a_i_max', ctx=Load())
Load()
Num(n=2)
Mult()
Name(id='a_i_min', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Load()
USub()
Num(n=1)
USub()
Num(n=1)
  metric  value
0     NC      3
DONE!
