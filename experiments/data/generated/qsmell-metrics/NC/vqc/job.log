Python 3.7.8
Module(body=[Expr(value=Str(s='An implementation of variational quantum classifier.')), ImportFrom(module='typing', names=[alias(name='Union', asname=None), alias(name='Optional', asname=None), alias(name='Callable', asname=None), alias(name='cast', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit', names=[alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library', names=[alias(name='ZZFeatureMap', asname=None), alias(name='RealAmplitudes', asname=None)], level=0), ImportFrom(module='qiskit.algorithms.optimizers', names=[alias(name='Optimizer', asname=None)], level=0), ImportFrom(module='exceptions', names=[alias(name='QiskitMachineLearningError', asname=None)], level=3), ImportFrom(module='neural_networks', names=[alias(name='CircuitQNN', asname=None)], level=3), ImportFrom(module='utils.loss_functions', names=[alias(name='Loss', asname=None)], level=3), ImportFrom(module='neural_network_classifier', names=[alias(name='NeuralNetworkClassifier', asname=None)], level=1), ClassDef(name='VQC', bases=[Name(id='NeuralNetworkClassifier', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Variational quantum classifier.\n\n    The variational quantum classifier is a variational algorithm where the\n    measured expectation value is interpreted as the output of a classifier.\n\n    Only supports one-hot encoded labels;\n    e.g., data like ``[1, 0, 0]``, ``[0, 1, 0]``, ``[0, 0, 1]``.\n\n    Multi-label classification is not supported;\n    e.g., data like ``[1, 1, 0]``, ``[0, 1, 1]``, ``[1, 0, 1]``, ``[1, 1, 1]``.\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='feature_map', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='ansatz', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='loss', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())), arg(arg='warm_start', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Name(id='QuantumInstance', ctx=Load())), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), Str(s='cross_entropy'), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            num_qubits: The number of qubits for the underlying CircuitQNN. If None, derive from\n                feature_map or ansatz. If neither of those is given, raise exception.\n            feature_map: The feature map for underlying CircuitQNN. If None, use ZZFeatureMap.\n            ansatz: The ansatz for the underlying CircuitQNN. If None, use RealAmplitudes.\n            loss: A target loss function to be used in training. Default is cross entropy.\n            optimizer: An instance of an optimizer to be used in training. When `None` defaults to SLSQP.\n            warm_start: Use weights from previous fit to start next fit.\n            quantum_instance: The quantum instance to execute circuits on.\n            initial_point: Initial point for the optimizer to start from.\n            callback: a reference to a user's callback function that has two parameters and\n                returns ``None``. The callback can access intermediate data during training.\n                On each iteration an optimizer invokes the callback and passes current weights\n                as an array and a computed value as a float of the objective function being\n                optimized. This allows to track how well optimization / training process is going on.\n        Raises:\n            QiskitMachineLearningError: Needs at least one out of num_qubits, feature_map or\n                ansatz to be given.\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[]), cause=None)], orelse=[]), AnnAssign(target=Name(id='num_qubits_', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='feature_map_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='ansatz_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), If(test=Name(id='num_qubits', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Name(id='num_qubits', ctx=Load())), If(test=Name(id='feature_map', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))], orelse=[Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))]), If(test=Name(id='ansatz', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], orelse=[Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])], orelse=[If(test=BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Store())], value=Name(id='feature_map_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Store())], value=Name(id='num_qubits_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Assign(targets=[Name(id='neural_network', ctx=Store())], value=Call(func=Name(id='CircuitQNN', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])), keyword(arg='output_shape', value=Num(n=2)), keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load())), keyword(arg='input_gradients', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load())), keyword(arg='loss', value=Name(id='loss', ctx=Load())), keyword(arg='one_hot', value=NameConstant(value=True)), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load())), keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load())), keyword(arg='callback', value=Name(id='callback', ctx=Load()))]))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='feature_map', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used feature map.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='circuit', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the underlying quantum circuit.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='num_qubits', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the number of qubits used by ansatz and feature map.')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load()), attr='num_qubits', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='fit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='X', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Fit the model to data matrix X and targets y.\n\n        Args:\n            X: The input data.\n            y: The target values. Required to be one-hot encoded.\n\n        Returns:\n            self: returns a trained classifier.\n        ')), Assign(targets=[Name(id='num_classes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[]), Name(id='num_classes', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load()), args=[Name(id='X', ctx=Load()), Name(id='y', ctx=Load())], keywords=[]))], decorator_list=[], returns=None), FunctionDef(name='_get_interpret', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[FunctionDef(name='parity', args=arguments(args=[arg(arg='x', annotation=Name(id='int', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Name(id='num_classes', ctx=Load())]), body=[Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load())))], decorator_list=[], returns=Name(id='int', ctx=Load())), Return(value=Name(id='parity', ctx=Load()))], decorator_list=[], returns=None)], decorator_list=[])])
Expr(value=Str(s='An implementation of variational quantum classifier.'))
ImportFrom(module='typing', names=[alias(name='Union', asname=None), alias(name='Optional', asname=None), alias(name='Callable', asname=None), alias(name='cast', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit', names=[alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library', names=[alias(name='ZZFeatureMap', asname=None), alias(name='RealAmplitudes', asname=None)], level=0)
ImportFrom(module='qiskit.algorithms.optimizers', names=[alias(name='Optimizer', asname=None)], level=0)
ImportFrom(module='exceptions', names=[alias(name='QiskitMachineLearningError', asname=None)], level=3)
ImportFrom(module='neural_networks', names=[alias(name='CircuitQNN', asname=None)], level=3)
ImportFrom(module='utils.loss_functions', names=[alias(name='Loss', asname=None)], level=3)
ImportFrom(module='neural_network_classifier', names=[alias(name='NeuralNetworkClassifier', asname=None)], level=1)
ClassDef(name='VQC', bases=[Name(id='NeuralNetworkClassifier', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Variational quantum classifier.\n\n    The variational quantum classifier is a variational algorithm where the\n    measured expectation value is interpreted as the output of a classifier.\n\n    Only supports one-hot encoded labels;\n    e.g., data like ``[1, 0, 0]``, ``[0, 1, 0]``, ``[0, 0, 1]``.\n\n    Multi-label classification is not supported;\n    e.g., data like ``[1, 1, 0]``, ``[0, 1, 1]``, ``[1, 0, 1]``, ``[1, 1, 1]``.\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='feature_map', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='ansatz', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='loss', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())), arg(arg='warm_start', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Name(id='QuantumInstance', ctx=Load())), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), Str(s='cross_entropy'), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            num_qubits: The number of qubits for the underlying CircuitQNN. If None, derive from\n                feature_map or ansatz. If neither of those is given, raise exception.\n            feature_map: The feature map for underlying CircuitQNN. If None, use ZZFeatureMap.\n            ansatz: The ansatz for the underlying CircuitQNN. If None, use RealAmplitudes.\n            loss: A target loss function to be used in training. Default is cross entropy.\n            optimizer: An instance of an optimizer to be used in training. When `None` defaults to SLSQP.\n            warm_start: Use weights from previous fit to start next fit.\n            quantum_instance: The quantum instance to execute circuits on.\n            initial_point: Initial point for the optimizer to start from.\n            callback: a reference to a user's callback function that has two parameters and\n                returns ``None``. The callback can access intermediate data during training.\n                On each iteration an optimizer invokes the callback and passes current weights\n                as an array and a computed value as a float of the objective function being\n                optimized. This allows to track how well optimization / training process is going on.\n        Raises:\n            QiskitMachineLearningError: Needs at least one out of num_qubits, feature_map or\n                ansatz to be given.\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[]), cause=None)], orelse=[]), AnnAssign(target=Name(id='num_qubits_', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='feature_map_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='ansatz_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), If(test=Name(id='num_qubits', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Name(id='num_qubits', ctx=Load())), If(test=Name(id='feature_map', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))], orelse=[Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))]), If(test=Name(id='ansatz', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], orelse=[Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])], orelse=[If(test=BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Store())], value=Name(id='feature_map_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Store())], value=Name(id='num_qubits_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Assign(targets=[Name(id='neural_network', ctx=Store())], value=Call(func=Name(id='CircuitQNN', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])), keyword(arg='output_shape', value=Num(n=2)), keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load())), keyword(arg='input_gradients', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load())), keyword(arg='loss', value=Name(id='loss', ctx=Load())), keyword(arg='one_hot', value=NameConstant(value=True)), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load())), keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load())), keyword(arg='callback', value=Name(id='callback', ctx=Load()))]))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='feature_map', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used feature map.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='circuit', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the underlying quantum circuit.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='num_qubits', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the number of qubits used by ansatz and feature map.')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load()), attr='num_qubits', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='fit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='X', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Fit the model to data matrix X and targets y.\n\n        Args:\n            X: The input data.\n            y: The target values. Required to be one-hot encoded.\n\n        Returns:\n            self: returns a trained classifier.\n        ')), Assign(targets=[Name(id='num_classes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[]), Name(id='num_classes', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load()), args=[Name(id='X', ctx=Load()), Name(id='y', ctx=Load())], keywords=[]))], decorator_list=[], returns=None), FunctionDef(name='_get_interpret', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[FunctionDef(name='parity', args=arguments(args=[arg(arg='x', annotation=Name(id='int', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Name(id='num_classes', ctx=Load())]), body=[Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load())))], decorator_list=[], returns=Name(id='int', ctx=Load())), Return(value=Name(id='parity', ctx=Load()))], decorator_list=[], returns=None)], decorator_list=[])
Str(s='An implementation of variational quantum classifier.')
alias(name='Union', asname=None)
alias(name='Optional', asname=None)
alias(name='Callable', asname=None)
alias(name='cast', asname=None)
alias(name='numpy', asname='np')
alias(name='QuantumCircuit', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='ZZFeatureMap', asname=None)
alias(name='RealAmplitudes', asname=None)
alias(name='Optimizer', asname=None)
alias(name='QiskitMachineLearningError', asname=None)
alias(name='CircuitQNN', asname=None)
alias(name='Loss', asname=None)
alias(name='NeuralNetworkClassifier', asname=None)
Name(id='NeuralNetworkClassifier', ctx=Load())
Expr(value=Str(s='Variational quantum classifier.\n\n    The variational quantum classifier is a variational algorithm where the\n    measured expectation value is interpreted as the output of a classifier.\n\n    Only supports one-hot encoded labels;\n    e.g., data like ``[1, 0, 0]``, ``[0, 1, 0]``, ``[0, 0, 1]``.\n\n    Multi-label classification is not supported;\n    e.g., data like ``[1, 1, 0]``, ``[0, 1, 1]``, ``[1, 0, 1]``, ``[1, 1, 1]``.\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='feature_map', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='ansatz', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='loss', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())), arg(arg='warm_start', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Name(id='QuantumInstance', ctx=Load())), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), Str(s='cross_entropy'), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            num_qubits: The number of qubits for the underlying CircuitQNN. If None, derive from\n                feature_map or ansatz. If neither of those is given, raise exception.\n            feature_map: The feature map for underlying CircuitQNN. If None, use ZZFeatureMap.\n            ansatz: The ansatz for the underlying CircuitQNN. If None, use RealAmplitudes.\n            loss: A target loss function to be used in training. Default is cross entropy.\n            optimizer: An instance of an optimizer to be used in training. When `None` defaults to SLSQP.\n            warm_start: Use weights from previous fit to start next fit.\n            quantum_instance: The quantum instance to execute circuits on.\n            initial_point: Initial point for the optimizer to start from.\n            callback: a reference to a user's callback function that has two parameters and\n                returns ``None``. The callback can access intermediate data during training.\n                On each iteration an optimizer invokes the callback and passes current weights\n                as an array and a computed value as a float of the objective function being\n                optimized. This allows to track how well optimization / training process is going on.\n        Raises:\n            QiskitMachineLearningError: Needs at least one out of num_qubits, feature_map or\n                ansatz to be given.\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[]), cause=None)], orelse=[]), AnnAssign(target=Name(id='num_qubits_', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='feature_map_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='ansatz_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), If(test=Name(id='num_qubits', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Name(id='num_qubits', ctx=Load())), If(test=Name(id='feature_map', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))], orelse=[Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))]), If(test=Name(id='ansatz', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], orelse=[Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])], orelse=[If(test=BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Store())], value=Name(id='feature_map_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Store())], value=Name(id='num_qubits_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Assign(targets=[Name(id='neural_network', ctx=Store())], value=Call(func=Name(id='CircuitQNN', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])), keyword(arg='output_shape', value=Num(n=2)), keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load())), keyword(arg='input_gradients', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load())), keyword(arg='loss', value=Name(id='loss', ctx=Load())), keyword(arg='one_hot', value=NameConstant(value=True)), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load())), keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load())), keyword(arg='callback', value=Name(id='callback', ctx=Load()))]))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='feature_map', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used feature map.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='circuit', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the underlying quantum circuit.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='num_qubits', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the number of qubits used by ansatz and feature map.')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load()), attr='num_qubits', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='fit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='X', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Fit the model to data matrix X and targets y.\n\n        Args:\n            X: The input data.\n            y: The target values. Required to be one-hot encoded.\n\n        Returns:\n            self: returns a trained classifier.\n        ')), Assign(targets=[Name(id='num_classes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[]), Name(id='num_classes', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load()), args=[Name(id='X', ctx=Load()), Name(id='y', ctx=Load())], keywords=[]))], decorator_list=[], returns=None)
FunctionDef(name='_get_interpret', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[FunctionDef(name='parity', args=arguments(args=[arg(arg='x', annotation=Name(id='int', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Name(id='num_classes', ctx=Load())]), body=[Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load())))], decorator_list=[], returns=Name(id='int', ctx=Load())), Return(value=Name(id='parity', ctx=Load()))], decorator_list=[], returns=None)
Load()
Str(s='Variational quantum classifier.\n\n    The variational quantum classifier is a variational algorithm where the\n    measured expectation value is interpreted as the output of a classifier.\n\n    Only supports one-hot encoded labels;\n    e.g., data like ``[1, 0, 0]``, ``[0, 1, 0]``, ``[0, 0, 1]``.\n\n    Multi-label classification is not supported;\n    e.g., data like ``[1, 1, 0]``, ``[0, 1, 1]``, ``[1, 0, 1]``, ``[1, 1, 1]``.\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='feature_map', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='ansatz', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='loss', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())), arg(arg='warm_start', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Name(id='QuantumInstance', ctx=Load())), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), Str(s='cross_entropy'), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s="\n        Args:\n            num_qubits: The number of qubits for the underlying CircuitQNN. If None, derive from\n                feature_map or ansatz. If neither of those is given, raise exception.\n            feature_map: The feature map for underlying CircuitQNN. If None, use ZZFeatureMap.\n            ansatz: The ansatz for the underlying CircuitQNN. If None, use RealAmplitudes.\n            loss: A target loss function to be used in training. Default is cross entropy.\n            optimizer: An instance of an optimizer to be used in training. When `None` defaults to SLSQP.\n            warm_start: Use weights from previous fit to start next fit.\n            quantum_instance: The quantum instance to execute circuits on.\n            initial_point: Initial point for the optimizer to start from.\n            callback: a reference to a user's callback function that has two parameters and\n                returns ``None``. The callback can access intermediate data during training.\n                On each iteration an optimizer invokes the callback and passes current weights\n                as an array and a computed value as a float of the objective function being\n                optimized. This allows to track how well optimization / training process is going on.\n        Raises:\n            QiskitMachineLearningError: Needs at least one out of num_qubits, feature_map or\n                ansatz to be given.\n        "))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[]), cause=None)], orelse=[])
AnnAssign(target=Name(id='num_qubits_', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=NameConstant(value=None), simple=1)
AnnAssign(target=Name(id='feature_map_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1)
AnnAssign(target=Name(id='ansatz_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1)
If(test=Name(id='num_qubits', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Name(id='num_qubits', ctx=Load())), If(test=Name(id='feature_map', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))], orelse=[Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))]), If(test=Name(id='ansatz', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], orelse=[Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])], orelse=[If(test=BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])])])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Store())], value=Name(id='feature_map_', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz_', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Store())], value=Name(id='num_qubits_', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
Assign(targets=[Name(id='neural_network', ctx=Store())], value=Call(func=Name(id='CircuitQNN', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])), keyword(arg='output_shape', value=Num(n=2)), keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load())), keyword(arg='input_gradients', value=NameConstant(value=False))]))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load())), keyword(arg='loss', value=Name(id='loss', ctx=Load())), keyword(arg='one_hot', value=NameConstant(value=True)), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load())), keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load())), keyword(arg='callback', value=Name(id='callback', ctx=Load()))]))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the used feature map.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the used ansatz.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the underlying quantum circuit.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the number of qubits used by ansatz and feature map.'))
Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load()), attr='num_qubits', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='X', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Fit the model to data matrix X and targets y.\n\n        Args:\n            X: The input data.\n            y: The target values. Required to be one-hot encoded.\n\n        Returns:\n            self: returns a trained classifier.\n        '))
Assign(targets=[Name(id='num_classes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[]), Name(id='num_classes', ctx=Load())], keywords=[]))
Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load()), args=[Name(id='X', ctx=Load()), Name(id='y', ctx=Load())], keywords=[]))
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
FunctionDef(name='parity', args=arguments(args=[arg(arg='x', annotation=Name(id='int', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Name(id='num_classes', ctx=Load())]), body=[Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load())))], decorator_list=[], returns=Name(id='int', ctx=Load()))
Return(value=Name(id='parity', ctx=Load()))
arg(arg='self', annotation=None)
arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))
arg(arg='feature_map', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='ansatz', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='loss', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))
arg(arg='warm_start', annotation=Name(id='bool', ctx=Load()))
arg(arg='quantum_instance', annotation=Name(id='QuantumInstance', ctx=Load()))
arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
Str(s='cross_entropy')
NameConstant(value=None)
NameConstant(value=False)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
Str(s="\n        Args:\n            num_qubits: The number of qubits for the underlying CircuitQNN. If None, derive from\n                feature_map or ansatz. If neither of those is given, raise exception.\n            feature_map: The feature map for underlying CircuitQNN. If None, use ZZFeatureMap.\n            ansatz: The ansatz for the underlying CircuitQNN. If None, use RealAmplitudes.\n            loss: A target loss function to be used in training. Default is cross entropy.\n            optimizer: An instance of an optimizer to be used in training. When `None` defaults to SLSQP.\n            warm_start: Use weights from previous fit to start next fit.\n            quantum_instance: The quantum instance to execute circuits on.\n            initial_point: Initial point for the optimizer to start from.\n            callback: a reference to a user's callback function that has two parameters and\n                returns ``None``. The callback can access intermediate data during training.\n                On each iteration an optimizer invokes the callback and passes current weights\n                as an array and a computed value as a float of the objective function being\n                optimized. This allows to track how well optimization / training process is going on.\n        Raises:\n            QiskitMachineLearningError: Needs at least one out of num_qubits, feature_map or\n                ansatz to be given.\n        ")
BoolOp(op=And(), values=[Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[]), cause=None)
Name(id='num_qubits_', ctx=Store())
Name(id='int', ctx=Load())
NameConstant(value=None)
Name(id='feature_map_', ctx=Store())
Name(id='QuantumCircuit', ctx=Load())
NameConstant(value=None)
Name(id='ansatz_', ctx=Store())
Name(id='QuantumCircuit', ctx=Load())
NameConstant(value=None)
Name(id='num_qubits', ctx=Load())
Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Name(id='num_qubits', ctx=Load()))
If(test=Name(id='feature_map', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))], orelse=[Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])
If(test=Name(id='ansatz', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], orelse=[Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])
If(test=BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])])
Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Store())
Name(id='feature_map_', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
Name(id='ansatz_', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Store())
Name(id='num_qubits_', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Name(id='neural_network', ctx=Store())
Call(func=Name(id='CircuitQNN', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])), keyword(arg='output_shape', value=Num(n=2)), keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load())), keyword(arg='input_gradients', value=NameConstant(value=False))])
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load())), keyword(arg='loss', value=Name(id='loss', ctx=Load())), keyword(arg='one_hot', value=NameConstant(value=True)), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load())), keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load())), keyword(arg='callback', value=Name(id='callback', ctx=Load()))])
arg(arg='self', annotation=None)
Str(s='Returns the used feature map.')
Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
Str(s='Returns the used ansatz.')
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
Str(s='Returns the underlying quantum circuit.')
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
Str(s='Returns the number of qubits used by ansatz and feature map.')
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load()), attr='num_qubits', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='X', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Str(s='\n        Fit the model to data matrix X and targets y.\n\n        Args:\n            X: The input data.\n            y: The target values. Required to be one-hot encoded.\n\n        Returns:\n            self: returns a trained classifier.\n        ')
Name(id='num_classes', ctx=Store())
Subscript(value=Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Call(func=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[]), Name(id='num_classes', ctx=Load())], keywords=[])
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load()), args=[Name(id='X', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])
arg(arg='self', annotation=None)
arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))
arguments(args=[arg(arg='x', annotation=Name(id='int', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Name(id='num_classes', ctx=Load())])
Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load())))
Name(id='int', ctx=Load())
Name(id='parity', ctx=Load())
Name(id='int', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
And()
Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[])
Store()
Load()
Store()
Load()
Store()
Load()
Load()
Name(id='num_qubits_', ctx=Store())
Name(id='num_qubits', ctx=Load())
Name(id='feature_map', ctx=Load())
If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))
Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))
Name(id='ansatz', ctx=Load())
If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))
BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())])
If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))
Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))
If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='QuantumCircuit', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())
keyword(arg='inplace', value=NameConstant(value=True))
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
keyword(arg='inplace', value=NameConstant(value=True))
Store()
Name(id='CircuitQNN', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[]))
keyword(arg='output_shape', value=Num(n=2))
keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load()))
keyword(arg='input_gradients', value=NameConstant(value=False))
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load()))
keyword(arg='loss', value=Name(id='loss', ctx=Load()))
keyword(arg='one_hot', value=NameConstant(value=True))
keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load()))
keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load()))
keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load()))
keyword(arg='callback', value=Name(id='callback', ctx=Load()))
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Store()
Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[])
Name(id='num_classes', ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load())
Name(id='X', ctx=Load())
Name(id='y', ctx=Load())
Name(id='int', ctx=Load())
arg(arg='x', annotation=Name(id='int', ctx=Load()))
arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))
Name(id='num_classes', ctx=Load())
BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='Optimizer', ctx=Load()))
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
Name(id='num_qubits', ctx=Load())
Is()
NameConstant(value=None)
Name(id='feature_map', ctx=Load())
Is()
NameConstant(value=None)
Name(id='ansatz', ctx=Load())
Is()
NameConstant(value=None)
Name(id='QiskitMachineLearningError', ctx=Load())
Str(s='Need at least one of num_qubits, feature_map, or ansatz!')
Store()
Load()
Load()
Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())])
Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)
Name(id='feature_map_', ctx=Store())
Name(id='feature_map', ctx=Load())
Name(id='feature_map_', ctx=Store())
Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[])
Load()
Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())])
Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)
Name(id='ansatz_', ctx=Store())
Name(id='ansatz', ctx=Load())
Name(id='ansatz_', ctx=Store())
Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[])
And()
Name(id='feature_map', ctx=Load())
Name(id='ansatz', ctx=Load())
Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())])
Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)
Name(id='feature_map_', ctx=Store())
Name(id='feature_map', ctx=Load())
Name(id='ansatz_', ctx=Store())
Name(id='ansatz', ctx=Load())
Name(id='num_qubits_', ctx=Store())
Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='feature_map', ctx=Load())
Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))
Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))
Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))
If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
NameConstant(value=True)
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])
Num(n=2)
Name(id='quantum_instance', ctx=Load())
NameConstant(value=False)
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Name(id='neural_network', ctx=Load())
Name(id='loss', ctx=Load())
NameConstant(value=True)
Name(id='optimizer', ctx=Load())
Name(id='warm_start', ctx=Load())
Name(id='initial_point', ctx=Load())
Name(id='callback', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Name(id='y', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[])
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load())
Name(id='num_classes', ctx=Load())
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Load()
Name(id='x', ctx=Load())
Mod()
Name(id='num_classes', ctx=Load())
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())
Load()
Name(id='Optimizer', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())
NotEq()
Name(id='num_qubits', ctx=Load())
Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[])
Store()
Load()
Store()
Name(id='ZZFeatureMap', ctx=Load())
Name(id='num_qubits', ctx=Load())
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
NotEq()
Name(id='num_qubits', ctx=Load())
Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[])
Store()
Load()
Store()
Name(id='RealAmplitudes', ctx=Load())
Name(id='num_qubits', ctx=Load())
Load()
Load()
Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())
NotEq()
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[])
Store()
Load()
Store()
Load()
Store()
Name(id='feature_map', ctx=Load())
Load()
Load()
Name(id='num_qubits_', ctx=Store())
Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='feature_map_', ctx=Store())
Name(id='feature_map', ctx=Load())
Name(id='ansatz_', ctx=Store())
Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[])
Name(id='ansatz', ctx=Load())
Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()))
Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load())
Num(n=2)
Load()
Name(id='super', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
USub()
Num(n=1)
Name(id='cast', ctx=Load())
Name(id='CircuitQNN', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Name(id='super', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='str', ctx=Load())
Name(id='Loss', ctx=Load())
Load()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Name(id='feature_map', ctx=Load())
Load()
Load()
Name(id='QiskitMachineLearningError', ctx=Load())
Str(s='Incompatible num_qubits and feature_map!')
Load()
Load()
Name(id='ansatz', ctx=Load())
Load()
Load()
Name(id='QiskitMachineLearningError', ctx=Load())
Str(s='Incompatible num_qubits and ansatz!')
Load()
Load()
Name(id='feature_map', ctx=Load())
Load()
Name(id='ansatz', ctx=Load())
Load()
Name(id='QiskitMachineLearningError', ctx=Load())
Str(s='Incompatible feature_map and ansatz!')
Load()
Store()
Name(id='feature_map', ctx=Load())
Load()
Store()
Load()
Store()
Name(id='RealAmplitudes', ctx=Load())
Name(id='num_qubits_', ctx=Load())
Load()
Name(id='num_qubits_', ctx=Store())
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='ansatz_', ctx=Store())
Name(id='ansatz', ctx=Load())
Name(id='feature_map_', ctx=Store())
Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[])
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Store()
Name(id='ansatz', ctx=Load())
Load()
Store()
Load()
Store()
Name(id='ZZFeatureMap', ctx=Load())
Name(id='num_qubits_', ctx=Load())
Load()
Load()
List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Module(body=[Expr(value=Str(s='An implementation of variational quantum classifier.')), ImportFrom(module='typing', names=[alias(name='Union', asname=None), alias(name='Optional', asname=None), alias(name='Callable', asname=None), alias(name='cast', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit', names=[alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library', names=[alias(name='ZZFeatureMap', asname=None), alias(name='RealAmplitudes', asname=None)], level=0), ImportFrom(module='qiskit.algorithms.optimizers', names=[alias(name='Optimizer', asname=None)], level=0), ImportFrom(module='exceptions', names=[alias(name='QiskitMachineLearningError', asname=None)], level=3), ImportFrom(module='neural_networks', names=[alias(name='CircuitQNN', asname=None)], level=3), ImportFrom(module='utils.loss_functions', names=[alias(name='Loss', asname=None)], level=3), ImportFrom(module='neural_network_classifier', names=[alias(name='NeuralNetworkClassifier', asname=None)], level=1), ClassDef(name='VQC', bases=[Name(id='NeuralNetworkClassifier', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Variational quantum classifier.\n\n    The variational quantum classifier is a variational algorithm where the\n    measured expectation value is interpreted as the output of a classifier.\n\n    Only supports one-hot encoded labels;\n    e.g., data like ``[1, 0, 0]``, ``[0, 1, 0]``, ``[0, 0, 1]``.\n\n    Multi-label classification is not supported;\n    e.g., data like ``[1, 1, 0]``, ``[0, 1, 1]``, ``[1, 0, 1]``, ``[1, 1, 1]``.\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='feature_map', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='ansatz', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='loss', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())), arg(arg='warm_start', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Name(id='QuantumInstance', ctx=Load())), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), Str(s='cross_entropy'), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            num_qubits: The number of qubits for the underlying CircuitQNN. If None, derive from\n                feature_map or ansatz. If neither of those is given, raise exception.\n            feature_map: The feature map for underlying CircuitQNN. If None, use ZZFeatureMap.\n            ansatz: The ansatz for the underlying CircuitQNN. If None, use RealAmplitudes.\n            loss: A target loss function to be used in training. Default is cross entropy.\n            optimizer: An instance of an optimizer to be used in training. When `None` defaults to SLSQP.\n            warm_start: Use weights from previous fit to start next fit.\n            quantum_instance: The quantum instance to execute circuits on.\n            initial_point: Initial point for the optimizer to start from.\n            callback: a reference to a user's callback function that has two parameters and\n                returns ``None``. The callback can access intermediate data during training.\n                On each iteration an optimizer invokes the callback and passes current weights\n                as an array and a computed value as a float of the objective function being\n                optimized. This allows to track how well optimization / training process is going on.\n        Raises:\n            QiskitMachineLearningError: Needs at least one out of num_qubits, feature_map or\n                ansatz to be given.\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[]), cause=None)], orelse=[]), AnnAssign(target=Name(id='num_qubits_', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='feature_map_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='ansatz_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), If(test=Name(id='num_qubits', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Name(id='num_qubits', ctx=Load())), If(test=Name(id='feature_map', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))], orelse=[Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))]), If(test=Name(id='ansatz', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], orelse=[Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])], orelse=[If(test=BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Store())], value=Name(id='feature_map_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Store())], value=Name(id='num_qubits_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Assign(targets=[Name(id='neural_network', ctx=Store())], value=Call(func=Name(id='CircuitQNN', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])), keyword(arg='output_shape', value=Num(n=2)), keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load())), keyword(arg='input_gradients', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load())), keyword(arg='loss', value=Name(id='loss', ctx=Load())), keyword(arg='one_hot', value=NameConstant(value=True)), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load())), keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load())), keyword(arg='callback', value=Name(id='callback', ctx=Load()))]))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='feature_map', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used feature map.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='circuit', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the underlying quantum circuit.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='num_qubits', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the number of qubits used by ansatz and feature map.')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load()), attr='num_qubits', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='fit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='X', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Fit the model to data matrix X and targets y.\n\n        Args:\n            X: The input data.\n            y: The target values. Required to be one-hot encoded.\n\n        Returns:\n            self: returns a trained classifier.\n        ')), Assign(targets=[Name(id='num_classes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[]), Name(id='num_classes', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load()), args=[Name(id='X', ctx=Load()), Name(id='y', ctx=Load())], keywords=[]))], decorator_list=[], returns=None), FunctionDef(name='_get_interpret', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[FunctionDef(name='parity', args=arguments(args=[arg(arg='x', annotation=Name(id='int', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Name(id='num_classes', ctx=Load())]), body=[Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load())))], decorator_list=[], returns=Name(id='int', ctx=Load())), Return(value=Name(id='parity', ctx=Load()))], decorator_list=[], returns=None)], decorator_list=[])])
Expr(value=Str(s='An implementation of variational quantum classifier.'))
ImportFrom(module='typing', names=[alias(name='Union', asname=None), alias(name='Optional', asname=None), alias(name='Callable', asname=None), alias(name='cast', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit', names=[alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library', names=[alias(name='ZZFeatureMap', asname=None), alias(name='RealAmplitudes', asname=None)], level=0)
ImportFrom(module='qiskit.algorithms.optimizers', names=[alias(name='Optimizer', asname=None)], level=0)
ImportFrom(module='exceptions', names=[alias(name='QiskitMachineLearningError', asname=None)], level=3)
ImportFrom(module='neural_networks', names=[alias(name='CircuitQNN', asname=None)], level=3)
ImportFrom(module='utils.loss_functions', names=[alias(name='Loss', asname=None)], level=3)
ImportFrom(module='neural_network_classifier', names=[alias(name='NeuralNetworkClassifier', asname=None)], level=1)
ClassDef(name='VQC', bases=[Name(id='NeuralNetworkClassifier', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Variational quantum classifier.\n\n    The variational quantum classifier is a variational algorithm where the\n    measured expectation value is interpreted as the output of a classifier.\n\n    Only supports one-hot encoded labels;\n    e.g., data like ``[1, 0, 0]``, ``[0, 1, 0]``, ``[0, 0, 1]``.\n\n    Multi-label classification is not supported;\n    e.g., data like ``[1, 1, 0]``, ``[0, 1, 1]``, ``[1, 0, 1]``, ``[1, 1, 1]``.\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='feature_map', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='ansatz', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='loss', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())), arg(arg='warm_start', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Name(id='QuantumInstance', ctx=Load())), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), Str(s='cross_entropy'), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            num_qubits: The number of qubits for the underlying CircuitQNN. If None, derive from\n                feature_map or ansatz. If neither of those is given, raise exception.\n            feature_map: The feature map for underlying CircuitQNN. If None, use ZZFeatureMap.\n            ansatz: The ansatz for the underlying CircuitQNN. If None, use RealAmplitudes.\n            loss: A target loss function to be used in training. Default is cross entropy.\n            optimizer: An instance of an optimizer to be used in training. When `None` defaults to SLSQP.\n            warm_start: Use weights from previous fit to start next fit.\n            quantum_instance: The quantum instance to execute circuits on.\n            initial_point: Initial point for the optimizer to start from.\n            callback: a reference to a user's callback function that has two parameters and\n                returns ``None``. The callback can access intermediate data during training.\n                On each iteration an optimizer invokes the callback and passes current weights\n                as an array and a computed value as a float of the objective function being\n                optimized. This allows to track how well optimization / training process is going on.\n        Raises:\n            QiskitMachineLearningError: Needs at least one out of num_qubits, feature_map or\n                ansatz to be given.\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[]), cause=None)], orelse=[]), AnnAssign(target=Name(id='num_qubits_', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='feature_map_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='ansatz_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), If(test=Name(id='num_qubits', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Name(id='num_qubits', ctx=Load())), If(test=Name(id='feature_map', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))], orelse=[Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))]), If(test=Name(id='ansatz', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], orelse=[Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])], orelse=[If(test=BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Store())], value=Name(id='feature_map_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Store())], value=Name(id='num_qubits_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Assign(targets=[Name(id='neural_network', ctx=Store())], value=Call(func=Name(id='CircuitQNN', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])), keyword(arg='output_shape', value=Num(n=2)), keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load())), keyword(arg='input_gradients', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load())), keyword(arg='loss', value=Name(id='loss', ctx=Load())), keyword(arg='one_hot', value=NameConstant(value=True)), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load())), keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load())), keyword(arg='callback', value=Name(id='callback', ctx=Load()))]))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='feature_map', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used feature map.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='circuit', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the underlying quantum circuit.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='num_qubits', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the number of qubits used by ansatz and feature map.')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load()), attr='num_qubits', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='fit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='X', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Fit the model to data matrix X and targets y.\n\n        Args:\n            X: The input data.\n            y: The target values. Required to be one-hot encoded.\n\n        Returns:\n            self: returns a trained classifier.\n        ')), Assign(targets=[Name(id='num_classes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[]), Name(id='num_classes', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load()), args=[Name(id='X', ctx=Load()), Name(id='y', ctx=Load())], keywords=[]))], decorator_list=[], returns=None), FunctionDef(name='_get_interpret', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[FunctionDef(name='parity', args=arguments(args=[arg(arg='x', annotation=Name(id='int', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Name(id='num_classes', ctx=Load())]), body=[Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load())))], decorator_list=[], returns=Name(id='int', ctx=Load())), Return(value=Name(id='parity', ctx=Load()))], decorator_list=[], returns=None)], decorator_list=[])
Str(s='An implementation of variational quantum classifier.')
alias(name='Union', asname=None)
alias(name='Optional', asname=None)
alias(name='Callable', asname=None)
alias(name='cast', asname=None)
alias(name='numpy', asname='np')
alias(name='QuantumCircuit', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='ZZFeatureMap', asname=None)
alias(name='RealAmplitudes', asname=None)
alias(name='Optimizer', asname=None)
alias(name='QiskitMachineLearningError', asname=None)
alias(name='CircuitQNN', asname=None)
alias(name='Loss', asname=None)
alias(name='NeuralNetworkClassifier', asname=None)
Name(id='NeuralNetworkClassifier', ctx=Load())
Expr(value=Str(s='Variational quantum classifier.\n\n    The variational quantum classifier is a variational algorithm where the\n    measured expectation value is interpreted as the output of a classifier.\n\n    Only supports one-hot encoded labels;\n    e.g., data like ``[1, 0, 0]``, ``[0, 1, 0]``, ``[0, 0, 1]``.\n\n    Multi-label classification is not supported;\n    e.g., data like ``[1, 1, 0]``, ``[0, 1, 1]``, ``[1, 0, 1]``, ``[1, 1, 1]``.\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='feature_map', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='ansatz', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='loss', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())), arg(arg='warm_start', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Name(id='QuantumInstance', ctx=Load())), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), Str(s='cross_entropy'), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s="\n        Args:\n            num_qubits: The number of qubits for the underlying CircuitQNN. If None, derive from\n                feature_map or ansatz. If neither of those is given, raise exception.\n            feature_map: The feature map for underlying CircuitQNN. If None, use ZZFeatureMap.\n            ansatz: The ansatz for the underlying CircuitQNN. If None, use RealAmplitudes.\n            loss: A target loss function to be used in training. Default is cross entropy.\n            optimizer: An instance of an optimizer to be used in training. When `None` defaults to SLSQP.\n            warm_start: Use weights from previous fit to start next fit.\n            quantum_instance: The quantum instance to execute circuits on.\n            initial_point: Initial point for the optimizer to start from.\n            callback: a reference to a user's callback function that has two parameters and\n                returns ``None``. The callback can access intermediate data during training.\n                On each iteration an optimizer invokes the callback and passes current weights\n                as an array and a computed value as a float of the objective function being\n                optimized. This allows to track how well optimization / training process is going on.\n        Raises:\n            QiskitMachineLearningError: Needs at least one out of num_qubits, feature_map or\n                ansatz to be given.\n        ")), If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[]), cause=None)], orelse=[]), AnnAssign(target=Name(id='num_qubits_', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='feature_map_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), AnnAssign(target=Name(id='ansatz_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1), If(test=Name(id='num_qubits', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Name(id='num_qubits', ctx=Load())), If(test=Name(id='feature_map', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))], orelse=[Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))]), If(test=Name(id='ansatz', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], orelse=[Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])], orelse=[If(test=BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Store())], value=Name(id='feature_map_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Store())], value=Name(id='num_qubits_', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])), Assign(targets=[Name(id='neural_network', ctx=Store())], value=Call(func=Name(id='CircuitQNN', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])), keyword(arg='output_shape', value=Num(n=2)), keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load())), keyword(arg='input_gradients', value=NameConstant(value=False))])), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load())), keyword(arg='loss', value=Name(id='loss', ctx=Load())), keyword(arg='one_hot', value=NameConstant(value=True)), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load())), keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load())), keyword(arg='callback', value=Name(id='callback', ctx=Load()))]))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='feature_map', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used feature map.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='ansatz', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the used ansatz.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='circuit', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the underlying quantum circuit.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='num_qubits', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the number of qubits used by ansatz and feature map.')), Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load()), attr='num_qubits', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='fit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='X', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Fit the model to data matrix X and targets y.\n\n        Args:\n            X: The input data.\n            y: The target values. Required to be one-hot encoded.\n\n        Returns:\n            self: returns a trained classifier.\n        ')), Assign(targets=[Name(id='num_classes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())), Expr(value=Call(func=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[]), Name(id='num_classes', ctx=Load())], keywords=[])), Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load()), args=[Name(id='X', ctx=Load()), Name(id='y', ctx=Load())], keywords=[]))], decorator_list=[], returns=None)
FunctionDef(name='_get_interpret', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[FunctionDef(name='parity', args=arguments(args=[arg(arg='x', annotation=Name(id='int', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Name(id='num_classes', ctx=Load())]), body=[Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load())))], decorator_list=[], returns=Name(id='int', ctx=Load())), Return(value=Name(id='parity', ctx=Load()))], decorator_list=[], returns=None)
Load()
Str(s='Variational quantum classifier.\n\n    The variational quantum classifier is a variational algorithm where the\n    measured expectation value is interpreted as the output of a classifier.\n\n    Only supports one-hot encoded labels;\n    e.g., data like ``[1, 0, 0]``, ``[0, 1, 0]``, ``[0, 0, 1]``.\n\n    Multi-label classification is not supported;\n    e.g., data like ``[1, 1, 0]``, ``[0, 1, 1]``, ``[1, 0, 1]``, ``[1, 1, 1]``.\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='feature_map', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='ansatz', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='loss', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())), arg(arg='warm_start', annotation=Name(id='bool', ctx=Load())), arg(arg='quantum_instance', annotation=Name(id='QuantumInstance', ctx=Load())), arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), Str(s='cross_entropy'), NameConstant(value=None), NameConstant(value=False), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s="\n        Args:\n            num_qubits: The number of qubits for the underlying CircuitQNN. If None, derive from\n                feature_map or ansatz. If neither of those is given, raise exception.\n            feature_map: The feature map for underlying CircuitQNN. If None, use ZZFeatureMap.\n            ansatz: The ansatz for the underlying CircuitQNN. If None, use RealAmplitudes.\n            loss: A target loss function to be used in training. Default is cross entropy.\n            optimizer: An instance of an optimizer to be used in training. When `None` defaults to SLSQP.\n            warm_start: Use weights from previous fit to start next fit.\n            quantum_instance: The quantum instance to execute circuits on.\n            initial_point: Initial point for the optimizer to start from.\n            callback: a reference to a user's callback function that has two parameters and\n                returns ``None``. The callback can access intermediate data during training.\n                On each iteration an optimizer invokes the callback and passes current weights\n                as an array and a computed value as a float of the objective function being\n                optimized. This allows to track how well optimization / training process is going on.\n        Raises:\n            QiskitMachineLearningError: Needs at least one out of num_qubits, feature_map or\n                ansatz to be given.\n        "))
If(test=BoolOp(op=And(), values=[Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[]), cause=None)], orelse=[])
AnnAssign(target=Name(id='num_qubits_', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=NameConstant(value=None), simple=1)
AnnAssign(target=Name(id='feature_map_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1)
AnnAssign(target=Name(id='ansatz_', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=1)
If(test=Name(id='num_qubits', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Name(id='num_qubits', ctx=Load())), If(test=Name(id='feature_map', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))], orelse=[Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))]), If(test=Name(id='ansatz', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], orelse=[Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])], orelse=[If(test=BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])])])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Store())], value=Name(id='feature_map_', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Name(id='ansatz_', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Store())], value=Name(id='num_qubits_', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))]))
Assign(targets=[Name(id='neural_network', ctx=Store())], value=Call(func=Name(id='CircuitQNN', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])), keyword(arg='output_shape', value=Num(n=2)), keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load())), keyword(arg='input_gradients', value=NameConstant(value=False))]))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load())), keyword(arg='loss', value=Name(id='loss', ctx=Load())), keyword(arg='one_hot', value=NameConstant(value=True)), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load())), keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load())), keyword(arg='callback', value=Name(id='callback', ctx=Load()))]))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the used feature map.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the used ansatz.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the underlying quantum circuit.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the number of qubits used by ansatz and feature map.'))
Return(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load()), attr='num_qubits', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='X', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())), arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Fit the model to data matrix X and targets y.\n\n        Args:\n            X: The input data.\n            y: The target values. Required to be one-hot encoded.\n\n        Returns:\n            self: returns a trained classifier.\n        '))
Assign(targets=[Name(id='num_classes', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[]), Name(id='num_classes', ctx=Load())], keywords=[]))
Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load()), args=[Name(id='X', ctx=Load()), Name(id='y', ctx=Load())], keywords=[]))
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
FunctionDef(name='parity', args=arguments(args=[arg(arg='x', annotation=Name(id='int', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Name(id='num_classes', ctx=Load())]), body=[Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load())))], decorator_list=[], returns=Name(id='int', ctx=Load()))
Return(value=Name(id='parity', ctx=Load()))
arg(arg='self', annotation=None)
arg(arg='num_qubits', annotation=Name(id='int', ctx=Load()))
arg(arg='feature_map', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='ansatz', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='loss', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='optimizer', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load()))
arg(arg='warm_start', annotation=Name(id='bool', ctx=Load()))
arg(arg='quantum_instance', annotation=Name(id='QuantumInstance', ctx=Load()))
arg(arg='initial_point', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
arg(arg='callback', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
Str(s='cross_entropy')
NameConstant(value=None)
NameConstant(value=False)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
Str(s="\n        Args:\n            num_qubits: The number of qubits for the underlying CircuitQNN. If None, derive from\n                feature_map or ansatz. If neither of those is given, raise exception.\n            feature_map: The feature map for underlying CircuitQNN. If None, use ZZFeatureMap.\n            ansatz: The ansatz for the underlying CircuitQNN. If None, use RealAmplitudes.\n            loss: A target loss function to be used in training. Default is cross entropy.\n            optimizer: An instance of an optimizer to be used in training. When `None` defaults to SLSQP.\n            warm_start: Use weights from previous fit to start next fit.\n            quantum_instance: The quantum instance to execute circuits on.\n            initial_point: Initial point for the optimizer to start from.\n            callback: a reference to a user's callback function that has two parameters and\n                returns ``None``. The callback can access intermediate data during training.\n                On each iteration an optimizer invokes the callback and passes current weights\n                as an array and a computed value as a float of the objective function being\n                optimized. This allows to track how well optimization / training process is going on.\n        Raises:\n            QiskitMachineLearningError: Needs at least one out of num_qubits, feature_map or\n                ansatz to be given.\n        ")
BoolOp(op=And(), values=[Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])])
Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[]), cause=None)
Name(id='num_qubits_', ctx=Store())
Name(id='int', ctx=Load())
NameConstant(value=None)
Name(id='feature_map_', ctx=Store())
Name(id='QuantumCircuit', ctx=Load())
NameConstant(value=None)
Name(id='ansatz_', ctx=Store())
Name(id='QuantumCircuit', ctx=Load())
NameConstant(value=None)
Name(id='num_qubits', ctx=Load())
Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Name(id='num_qubits', ctx=Load()))
If(test=Name(id='feature_map', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))], orelse=[Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])
If(test=Name(id='ansatz', ctx=Load()), body=[If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))], orelse=[Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))])
If(test=BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())]), body=[If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])])
Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Store())
Name(id='feature_map_', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
Name(id='ansatz_', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Store())
Name(id='num_qubits_', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[keyword(arg='inplace', value=NameConstant(value=True))])
Name(id='neural_network', ctx=Store())
Call(func=Name(id='CircuitQNN', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])), keyword(arg='output_shape', value=Num(n=2)), keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load())), keyword(arg='input_gradients', value=NameConstant(value=False))])
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load())), keyword(arg='loss', value=Name(id='loss', ctx=Load())), keyword(arg='one_hot', value=NameConstant(value=True)), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load())), keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load())), keyword(arg='callback', value=Name(id='callback', ctx=Load()))])
arg(arg='self', annotation=None)
Str(s='Returns the used feature map.')
Attribute(value=Name(id='self', ctx=Load()), attr='_feature_map', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
Str(s='Returns the used ansatz.')
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
Str(s='Returns the underlying quantum circuit.')
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
Str(s='Returns the number of qubits used by ansatz and feature map.')
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load()), attr='num_qubits', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='X', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
arg(arg='y', annotation=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()))
Str(s='\n        Fit the model to data matrix X and targets y.\n\n        Args:\n            X: The input data.\n            y: The target values. Required to be one-hot encoded.\n\n        Returns:\n            self: returns a trained classifier.\n        ')
Name(id='num_classes', ctx=Store())
Subscript(value=Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Call(func=Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[]), Name(id='num_classes', ctx=Load())], keywords=[])
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load()), args=[Name(id='X', ctx=Load()), Name(id='y', ctx=Load())], keywords=[])
arg(arg='self', annotation=None)
arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))
arguments(args=[arg(arg='x', annotation=Name(id='int', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Name(id='num_classes', ctx=Load())])
Return(value=BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load())))
Name(id='int', ctx=Load())
Name(id='parity', ctx=Load())
Name(id='int', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='Optimizer', ctx=Load())), ctx=Load())
Name(id='bool', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())), ctx=Load())
And()
Compare(left=Name(id='num_qubits', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='feature_map', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='ansatz', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Need at least one of num_qubits, feature_map, or ansatz!')], keywords=[])
Store()
Load()
Store()
Load()
Store()
Load()
Load()
Name(id='num_qubits_', ctx=Store())
Name(id='num_qubits', ctx=Load())
Name(id='feature_map', ctx=Load())
If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))
Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))
Name(id='ansatz', ctx=Load())
If(test=Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[]))
BoolOp(op=And(), values=[Name(id='feature_map', ctx=Load()), Name(id='ansatz', ctx=Load())])
If(test=Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())]), body=[Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))
Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))
If(test=Name(id='feature_map', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='QuantumCircuit', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_qubits', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())
keyword(arg='inplace', value=NameConstant(value=True))
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load()), attr='compose', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
keyword(arg='inplace', value=NameConstant(value=True))
Store()
Name(id='CircuitQNN', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load()), attr='parameters', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
keyword(arg='interpret', value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[]))
keyword(arg='output_shape', value=Num(n=2))
keyword(arg='quantum_instance', value=Name(id='quantum_instance', ctx=Load()))
keyword(arg='input_gradients', value=NameConstant(value=False))
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
keyword(arg='neural_network', value=Name(id='neural_network', ctx=Load()))
keyword(arg='loss', value=Name(id='loss', ctx=Load()))
keyword(arg='one_hot', value=NameConstant(value=True))
keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load()))
keyword(arg='warm_start', value=Name(id='warm_start', ctx=Load()))
keyword(arg='initial_point', value=Name(id='initial_point', ctx=Load()))
keyword(arg='callback', value=Name(id='callback', ctx=Load()))
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='circuit', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Store()
Attribute(value=Name(id='y', ctx=Load()), attr='shape', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Attribute(value=Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[]), attr='set_interpret', ctx=Load())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Name(id='num_classes', ctx=Load())], keywords=[])
Name(id='num_classes', ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='fit', ctx=Load())
Name(id='X', ctx=Load())
Name(id='y', ctx=Load())
Name(id='int', ctx=Load())
arg(arg='x', annotation=Name(id='int', ctx=Load()))
arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))
Name(id='num_classes', ctx=Load())
BinOp(left=Name(id='x', ctx=Load()), op=Mod(), right=Name(id='num_classes', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='Optimizer', ctx=Load()))
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load()))
Load()
Name(id='num_qubits', ctx=Load())
Is()
NameConstant(value=None)
Name(id='feature_map', ctx=Load())
Is()
NameConstant(value=None)
Name(id='ansatz', ctx=Load())
Is()
NameConstant(value=None)
Name(id='QiskitMachineLearningError', ctx=Load())
Str(s='Need at least one of num_qubits, feature_map, or ansatz!')
Store()
Load()
Load()
Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())])
Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[]), cause=None)
Name(id='feature_map_', ctx=Store())
Name(id='feature_map', ctx=Load())
Name(id='feature_map_', ctx=Store())
Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[])
Load()
Compare(left=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Name(id='num_qubits', ctx=Load())])
Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[]), cause=None)
Name(id='ansatz_', ctx=Store())
Name(id='ansatz', ctx=Load())
Name(id='ansatz_', ctx=Store())
Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits', ctx=Load())], keywords=[])
And()
Name(id='feature_map', ctx=Load())
Name(id='ansatz', ctx=Load())
Compare(left=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()), ops=[NotEq()], comparators=[Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())])
Raise(exc=Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[]), cause=None)
Name(id='feature_map_', ctx=Store())
Name(id='feature_map', ctx=Load())
Name(id='ansatz_', ctx=Store())
Name(id='ansatz', ctx=Load())
Name(id='num_qubits_', ctx=Store())
Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='feature_map', ctx=Load())
Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load()))
Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Name(id='feature_map', ctx=Load()))
Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))
If(test=Name(id='ansatz', ctx=Load()), body=[Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load())), Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))], orelse=[])
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='_circuit', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
NameConstant(value=True)
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='feature_map', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load()), args=[Num(n=2)], keywords=[])
Num(n=2)
Name(id='quantum_instance', ctx=Load())
NameConstant(value=False)
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Name(id='neural_network', ctx=Load())
Name(id='loss', ctx=Load())
NameConstant(value=True)
Name(id='optimizer', ctx=Load())
Name(id='warm_start', ctx=Load())
Name(id='initial_point', ctx=Load())
Name(id='callback', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Name(id='y', ctx=Load())
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Call(func=Name(id='cast', ctx=Load()), args=[Name(id='CircuitQNN', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())], keywords=[])
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load())
Name(id='num_classes', ctx=Load())
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Name(id='int', ctx=Load())
Load()
Name(id='x', ctx=Load())
Mod()
Name(id='num_classes', ctx=Load())
Load()
Tuple(elts=[Name(id='str', ctx=Load()), Name(id='Loss', ctx=Load())], ctx=Load())
Load()
Name(id='Optimizer', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())
NotEq()
Name(id='num_qubits', ctx=Load())
Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and feature_map!')], keywords=[])
Store()
Load()
Store()
Name(id='ZZFeatureMap', ctx=Load())
Name(id='num_qubits', ctx=Load())
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
NotEq()
Name(id='num_qubits', ctx=Load())
Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible num_qubits and ansatz!')], keywords=[])
Store()
Load()
Store()
Name(id='RealAmplitudes', ctx=Load())
Name(id='num_qubits', ctx=Load())
Load()
Load()
Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())
NotEq()
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Call(func=Name(id='QiskitMachineLearningError', ctx=Load()), args=[Str(s='Incompatible feature_map and ansatz!')], keywords=[])
Store()
Load()
Store()
Load()
Store()
Name(id='feature_map', ctx=Load())
Load()
Load()
Name(id='num_qubits_', ctx=Store())
Attribute(value=Name(id='feature_map', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='feature_map_', ctx=Store())
Name(id='feature_map', ctx=Load())
Name(id='ansatz_', ctx=Store())
Call(func=Name(id='RealAmplitudes', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[])
Name(id='ansatz', ctx=Load())
Assign(targets=[Name(id='num_qubits_', ctx=Store())], value=Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load()))
Assign(targets=[Name(id='ansatz_', ctx=Store())], value=Name(id='ansatz', ctx=Load()))
Assign(targets=[Name(id='feature_map_', ctx=Store())], value=Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[]))
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_interpret', ctx=Load())
Num(n=2)
Load()
Name(id='super', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
USub()
Num(n=1)
Name(id='cast', ctx=Load())
Name(id='CircuitQNN', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_neural_network', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Name(id='super', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='str', ctx=Load())
Name(id='Loss', ctx=Load())
Load()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load()))
Load()
Name(id='feature_map', ctx=Load())
Load()
Load()
Name(id='QiskitMachineLearningError', ctx=Load())
Str(s='Incompatible num_qubits and feature_map!')
Load()
Load()
Name(id='ansatz', ctx=Load())
Load()
Load()
Name(id='QiskitMachineLearningError', ctx=Load())
Str(s='Incompatible num_qubits and ansatz!')
Load()
Load()
Name(id='feature_map', ctx=Load())
Load()
Name(id='ansatz', ctx=Load())
Load()
Name(id='QiskitMachineLearningError', ctx=Load())
Str(s='Incompatible feature_map and ansatz!')
Load()
Store()
Name(id='feature_map', ctx=Load())
Load()
Store()
Load()
Store()
Name(id='RealAmplitudes', ctx=Load())
Name(id='num_qubits_', ctx=Load())
Load()
Name(id='num_qubits_', ctx=Store())
Attribute(value=Name(id='ansatz', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='ansatz_', ctx=Store())
Name(id='ansatz', ctx=Load())
Name(id='feature_map_', ctx=Store())
Call(func=Name(id='ZZFeatureMap', ctx=Load()), args=[Name(id='num_qubits_', ctx=Load())], keywords=[])
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), NameConstant(value=None)], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Store()
Name(id='ansatz', ctx=Load())
Load()
Store()
Load()
Store()
Name(id='ZZFeatureMap', ctx=Load())
Name(id='num_qubits_', ctx=Load())
Load()
Load()
List(elts=[Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load())
NameConstant(value=None)
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='float', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
  metric  value
0     NC      0
DONE!
