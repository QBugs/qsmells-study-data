Python 3.7.8
Module(body=[Expr(value=Str(s='A ground state calculation employing the AdaptVQE algorithm.')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None), alias(name='Union', asname=None)], level=0), Import(names=[alias(name='copy', asname=None)]), Import(names=[alias(name='re', asname=None)]), Import(names=[alias(name='logging', asname=None)]), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit.algorithms', names=[alias(name='VQE', asname=None)], level=0), ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.opflow', names=[alias(name='OperatorBase', asname=None), alias(name='PauliSumOp', asname=None), alias(name='CircuitSampler', asname=None)], level=0), ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None), alias(name='Gradient', asname=None)], level=0), ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0), ImportFrom(module='qiskit_nature', names=[alias(name='ListOrDictType', asname=None)], level=0), ImportFrom(module='qiskit_nature.exceptions', names=[alias(name='QiskitNatureError', asname=None)], level=0), ImportFrom(module='qiskit_nature.circuit.library', names=[alias(name='UCC', asname=None)], level=0), ImportFrom(module='qiskit_nature.operators.second_quantization', names=[alias(name='SecondQuantizedOp', asname=None)], level=0), ImportFrom(module='qiskit_nature.converters.second_quantization', names=[alias(name='QubitConverter', asname=None)], level=0), ImportFrom(module='qiskit_nature.converters.second_quantization.utils', names=[alias(name='ListOrDict', asname=None)], level=0), ImportFrom(module='qiskit_nature.problems.second_quantization', names=[alias(name='BaseProblem', asname=None)], level=0), ImportFrom(module='qiskit_nature.results', names=[alias(name='ElectronicStructureResult', asname=None)], level=0), ImportFrom(module='qiskit_nature.deprecation', names=[alias(name='deprecate_arguments', asname=None)], level=0), ImportFrom(module='minimum_eigensolver_factories', names=[alias(name='MinimumEigensolverFactory', asname=None)], level=1), ImportFrom(module='ground_state_eigensolver', names=[alias(name='GroundStateEigensolver', asname=None)], level=1), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='AdaptVQE', bases=[Name(id='GroundStateEigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='A ground state calculation employing the AdaptVQE algorithm.\n\n    The performance of AdaptVQE significantly depends on the choice of `gradient` (see also\n    `qiskit.opflow.gradients`) and its parameters such as `grad_method`, `qfi_method` (if\n    applicable) and `epilson`.\n\n    To reproduce the default behavior of AdaptVQE prior to Qiskit Nature 0.4 you should supply\n    `delta=1` explicitly. This will use a finite difference scheme for the gradient evaluation\n    whereas after version 0.4 a parameter shift gradient will be used.\n    For more information refer to the gradient framework of Qiskit Terra:\n    https://qiskit.org/documentation/tutorials/operators/02_gradients_framework.html\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qubit_converter', annotation=Name(id='QubitConverter', ctx=Load())), arg(arg='solver', annotation=Name(id='MinimumEigensolverFactory', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='delta', annotation=Name(id='float', ctx=Load())), arg(arg='max_iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-05), Num(n=1.0), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            qubit_converter: a class that converts second quantized operator to qubit operator\n            solver: a factory for the VQE solver employing a UCCSD ansatz.\n            threshold: the energy convergence threshold. It has a minimum value of 1e-15.\n            delta: the finite difference step size for the gradient computation. It has a minimum\n                value of 1e-5.\n            max_iterations: the maximum number of iterations of the AdaptVQE algorithm.\n            gradient: a class that converts operator expression to the first-order gradient based\n                on the method mentioned.\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='threshold'), Name(id='threshold', ctx=Load()), Num(n=1e-15)], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='gradient', ctx=Load()), Name(id='float', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='qubit_converter', ctx=Load()), Name(id='solver', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Store())], value=Name(id='threshold', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Store())], value=Name(id='max_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store()), annotation=Name(id='PauliSumOp', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store()), annotation=Name(id='CircuitSampler', ctx=Load()), value=NameConstant(value=None), simple=0)], decorator_list=[Call(func=Name(id='deprecate_arguments', ctx=Load()), args=[Str(s='0.4.0'), Dict(keys=[Str(s='delta')], values=[Str(s='gradient')])], keywords=[keyword(arg='additional_msg', value=Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`."))])], returns=NameConstant(value=None)), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='GradientBase', ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='grad', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Sets the gradient.')), If(test=Compare(left=Name(id='grad', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='grad', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='grad', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='returns_groundstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Whether this class returns only the ground state energy or also the ground state itself.')), Return(value=NameConstant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compute_gradients', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='theta', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='vqe', annotation=Name(id='VQE', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Computes the gradients for all available excitation operators.\n\n        Args:\n            theta: list of (up to now) optimal parameters\n            vqe: the variational quantum eigensolver instance used for solving\n\n        Returns:\n            List of pairs consisting of gradient and excitation operator.\n        ')), Assign(targets=[Name(id='res', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='exc', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load()))), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='param_sets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta1', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='op', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_grad', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))])), Assign(targets=[Name(id='value_dict', ctx=Store())], value=Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)])), Assign(targets=[Name(id='state_grad_result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='_check_cyclicity', args=arguments(args=[arg(arg='indices', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Auxiliary function to check for cycles in the indices of the selected excitations.\n\n        Args:\n            indices: the list of chosen gradient indices.\n        Returns:\n            Whether repeating sequences of indices have been detected.\n        ')), Assign(targets=[Name(id='cycle_regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')], keywords=[])), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cycle detected: %s'), Name(id='match', ctx=Load())], keywords=[])), Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='BaseProblem', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Computes the ground state.\n\n        Args:\n            problem: a class encoding a problem to be solved.\n            aux_operators: Additional auxiliary operators to evaluate.\n\n        Raises:\n            QiskitNatureError: if a solver other than VQE or a ansatz other than UCCSD is provided\n                or if the algorithm finishes due to an unforeseen reason.\n            ValueError: if the grouped property object returned by the driver does not contain a\n                main property as requested by the problem being solved (`problem.main_property_name`)\n            QiskitNatureError: if the user-provided `aux_operators` contain a name which clashes\n                with an internally constructed auxiliary operator. Note: the names used for the\n                internal auxiliary operators correspond to the `Property.name` attributes which\n                generated the respective operators.\n            QiskitNatureError: if the chosen gradient method appears to result in all-zero gradients.\n\n        Returns:\n            An AdaptVQEResult which is an ElectronicStructureResult but also includes runtime\n            information about the AdaptVQE algorithm like the number of iterations, finishing\n            criterion, and the final maximum gradient.\n        ')), Assign(targets=[Name(id='second_q_ops', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Name(id='aux_second_q_ops', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Name(id='SecondQuantizedOp', ctx=Load())), ctx=Load()), value=None, simple=1), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())), Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))], orelse=[])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='main_second_q_op', ctx=Load())], keywords=[keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())), keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))])), Assign(targets=[Name(id='aux_ops', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_second_q_ops', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AnnAssign(target=Name(id='wrapped_aux_operators', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), value=Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])], orelse=[])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), Name(id='MinimumEigensolverFactory', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()))]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=False)), AnnAssign(target=Name(id='prev_op_indices', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='theta', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='max_grad', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), value=Tuple(elts=[Num(n=0.0), NameConstant(value=None)], ctx=Load()), simple=1), Assign(targets=[Name(id='iteration', ctx=Store())], value=Num(n=0)), While(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])]), body=[AugAssign(target=Name(id='iteration', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='cur_grads', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))])), Expr(value=Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())]), body=[If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Name(id='raw_vqe_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))]), If(test=Compare(left=Name(id='aux_ops', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=NameConstant(value=None))]), Assign(targets=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load())), If(test=Name(id='threshold_satisfied', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Threshold converged'))], orelse=[If(test=Name(id='alternating_sequence', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))], orelse=[If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])])]), Assign(targets=[Name(id='electronic_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load()), args=[Name(id='raw_vqe_result', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='AdaptVQEResult', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load()), args=[Name(id='electronic_result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_iterations', ctx=Store())], value=Name(id='iteration', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='final_max_gradient', ctx=Store())], value=Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='finishing_criterion', ctx=Store())], value=Name(id='finishing_criterion', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The final energy is: %s'), Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='AdaptVQEResult'))], decorator_list=[]), ClassDef(name='AdaptVQEResult', bases=[Name(id='ElectronicStructureResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='AdaptVQE Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Num(n=0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store()), annotation=Name(id='float', ctx=Load()), value=Num(n=0.0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Str(s=''), simple=0)], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of iterations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of iterations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='num_iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns final maximum gradient')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets final maximum gradient')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='final_max_gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns finishing criterion')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets finishing criterion')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='finishing_criterion', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])])
Expr(value=Str(s='A ground state calculation employing the AdaptVQE algorithm.'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None), alias(name='Union', asname=None)], level=0)
Import(names=[alias(name='copy', asname=None)])
Import(names=[alias(name='re', asname=None)])
Import(names=[alias(name='logging', asname=None)])
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit.algorithms', names=[alias(name='VQE', asname=None)], level=0)
ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.opflow', names=[alias(name='OperatorBase', asname=None), alias(name='PauliSumOp', asname=None), alias(name='CircuitSampler', asname=None)], level=0)
ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None), alias(name='Gradient', asname=None)], level=0)
ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0)
ImportFrom(module='qiskit_nature', names=[alias(name='ListOrDictType', asname=None)], level=0)
ImportFrom(module='qiskit_nature.exceptions', names=[alias(name='QiskitNatureError', asname=None)], level=0)
ImportFrom(module='qiskit_nature.circuit.library', names=[alias(name='UCC', asname=None)], level=0)
ImportFrom(module='qiskit_nature.operators.second_quantization', names=[alias(name='SecondQuantizedOp', asname=None)], level=0)
ImportFrom(module='qiskit_nature.converters.second_quantization', names=[alias(name='QubitConverter', asname=None)], level=0)
ImportFrom(module='qiskit_nature.converters.second_quantization.utils', names=[alias(name='ListOrDict', asname=None)], level=0)
ImportFrom(module='qiskit_nature.problems.second_quantization', names=[alias(name='BaseProblem', asname=None)], level=0)
ImportFrom(module='qiskit_nature.results', names=[alias(name='ElectronicStructureResult', asname=None)], level=0)
ImportFrom(module='qiskit_nature.deprecation', names=[alias(name='deprecate_arguments', asname=None)], level=0)
ImportFrom(module='minimum_eigensolver_factories', names=[alias(name='MinimumEigensolverFactory', asname=None)], level=1)
ImportFrom(module='ground_state_eigensolver', names=[alias(name='GroundStateEigensolver', asname=None)], level=1)
Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[]))
ClassDef(name='AdaptVQE', bases=[Name(id='GroundStateEigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='A ground state calculation employing the AdaptVQE algorithm.\n\n    The performance of AdaptVQE significantly depends on the choice of `gradient` (see also\n    `qiskit.opflow.gradients`) and its parameters such as `grad_method`, `qfi_method` (if\n    applicable) and `epilson`.\n\n    To reproduce the default behavior of AdaptVQE prior to Qiskit Nature 0.4 you should supply\n    `delta=1` explicitly. This will use a finite difference scheme for the gradient evaluation\n    whereas after version 0.4 a parameter shift gradient will be used.\n    For more information refer to the gradient framework of Qiskit Terra:\n    https://qiskit.org/documentation/tutorials/operators/02_gradients_framework.html\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qubit_converter', annotation=Name(id='QubitConverter', ctx=Load())), arg(arg='solver', annotation=Name(id='MinimumEigensolverFactory', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='delta', annotation=Name(id='float', ctx=Load())), arg(arg='max_iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-05), Num(n=1.0), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            qubit_converter: a class that converts second quantized operator to qubit operator\n            solver: a factory for the VQE solver employing a UCCSD ansatz.\n            threshold: the energy convergence threshold. It has a minimum value of 1e-15.\n            delta: the finite difference step size for the gradient computation. It has a minimum\n                value of 1e-5.\n            max_iterations: the maximum number of iterations of the AdaptVQE algorithm.\n            gradient: a class that converts operator expression to the first-order gradient based\n                on the method mentioned.\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='threshold'), Name(id='threshold', ctx=Load()), Num(n=1e-15)], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='gradient', ctx=Load()), Name(id='float', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='qubit_converter', ctx=Load()), Name(id='solver', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Store())], value=Name(id='threshold', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Store())], value=Name(id='max_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store()), annotation=Name(id='PauliSumOp', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store()), annotation=Name(id='CircuitSampler', ctx=Load()), value=NameConstant(value=None), simple=0)], decorator_list=[Call(func=Name(id='deprecate_arguments', ctx=Load()), args=[Str(s='0.4.0'), Dict(keys=[Str(s='delta')], values=[Str(s='gradient')])], keywords=[keyword(arg='additional_msg', value=Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`."))])], returns=NameConstant(value=None)), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='GradientBase', ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='grad', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Sets the gradient.')), If(test=Compare(left=Name(id='grad', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='grad', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='grad', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='returns_groundstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Whether this class returns only the ground state energy or also the ground state itself.')), Return(value=NameConstant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compute_gradients', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='theta', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='vqe', annotation=Name(id='VQE', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Computes the gradients for all available excitation operators.\n\n        Args:\n            theta: list of (up to now) optimal parameters\n            vqe: the variational quantum eigensolver instance used for solving\n\n        Returns:\n            List of pairs consisting of gradient and excitation operator.\n        ')), Assign(targets=[Name(id='res', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='exc', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load()))), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='param_sets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta1', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='op', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_grad', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))])), Assign(targets=[Name(id='value_dict', ctx=Store())], value=Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)])), Assign(targets=[Name(id='state_grad_result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='_check_cyclicity', args=arguments(args=[arg(arg='indices', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Auxiliary function to check for cycles in the indices of the selected excitations.\n\n        Args:\n            indices: the list of chosen gradient indices.\n        Returns:\n            Whether repeating sequences of indices have been detected.\n        ')), Assign(targets=[Name(id='cycle_regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')], keywords=[])), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cycle detected: %s'), Name(id='match', ctx=Load())], keywords=[])), Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='BaseProblem', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Computes the ground state.\n\n        Args:\n            problem: a class encoding a problem to be solved.\n            aux_operators: Additional auxiliary operators to evaluate.\n\n        Raises:\n            QiskitNatureError: if a solver other than VQE or a ansatz other than UCCSD is provided\n                or if the algorithm finishes due to an unforeseen reason.\n            ValueError: if the grouped property object returned by the driver does not contain a\n                main property as requested by the problem being solved (`problem.main_property_name`)\n            QiskitNatureError: if the user-provided `aux_operators` contain a name which clashes\n                with an internally constructed auxiliary operator. Note: the names used for the\n                internal auxiliary operators correspond to the `Property.name` attributes which\n                generated the respective operators.\n            QiskitNatureError: if the chosen gradient method appears to result in all-zero gradients.\n\n        Returns:\n            An AdaptVQEResult which is an ElectronicStructureResult but also includes runtime\n            information about the AdaptVQE algorithm like the number of iterations, finishing\n            criterion, and the final maximum gradient.\n        ')), Assign(targets=[Name(id='second_q_ops', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Name(id='aux_second_q_ops', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Name(id='SecondQuantizedOp', ctx=Load())), ctx=Load()), value=None, simple=1), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())), Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))], orelse=[])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='main_second_q_op', ctx=Load())], keywords=[keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())), keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))])), Assign(targets=[Name(id='aux_ops', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_second_q_ops', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AnnAssign(target=Name(id='wrapped_aux_operators', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), value=Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])], orelse=[])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), Name(id='MinimumEigensolverFactory', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()))]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=False)), AnnAssign(target=Name(id='prev_op_indices', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='theta', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='max_grad', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), value=Tuple(elts=[Num(n=0.0), NameConstant(value=None)], ctx=Load()), simple=1), Assign(targets=[Name(id='iteration', ctx=Store())], value=Num(n=0)), While(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])]), body=[AugAssign(target=Name(id='iteration', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='cur_grads', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))])), Expr(value=Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())]), body=[If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Name(id='raw_vqe_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))]), If(test=Compare(left=Name(id='aux_ops', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=NameConstant(value=None))]), Assign(targets=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load())), If(test=Name(id='threshold_satisfied', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Threshold converged'))], orelse=[If(test=Name(id='alternating_sequence', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))], orelse=[If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])])]), Assign(targets=[Name(id='electronic_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load()), args=[Name(id='raw_vqe_result', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='AdaptVQEResult', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load()), args=[Name(id='electronic_result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_iterations', ctx=Store())], value=Name(id='iteration', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='final_max_gradient', ctx=Store())], value=Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='finishing_criterion', ctx=Store())], value=Name(id='finishing_criterion', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The final energy is: %s'), Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='AdaptVQEResult'))], decorator_list=[])
ClassDef(name='AdaptVQEResult', bases=[Name(id='ElectronicStructureResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='AdaptVQE Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Num(n=0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store()), annotation=Name(id='float', ctx=Load()), value=Num(n=0.0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Str(s=''), simple=0)], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of iterations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of iterations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='num_iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns final maximum gradient')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets final maximum gradient')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='final_max_gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns finishing criterion')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets finishing criterion')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='finishing_criterion', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
Str(s='A ground state calculation employing the AdaptVQE algorithm.')
alias(name='Optional', asname=None)
alias(name='List', asname=None)
alias(name='Tuple', asname=None)
alias(name='Union', asname=None)
alias(name='copy', asname=None)
alias(name='re', asname=None)
alias(name='logging', asname=None)
alias(name='numpy', asname='np')
alias(name='VQE', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='OperatorBase', asname=None)
alias(name='PauliSumOp', asname=None)
alias(name='CircuitSampler', asname=None)
alias(name='GradientBase', asname=None)
alias(name='Gradient', asname=None)
alias(name='validate_min', asname=None)
alias(name='ListOrDictType', asname=None)
alias(name='QiskitNatureError', asname=None)
alias(name='UCC', asname=None)
alias(name='SecondQuantizedOp', asname=None)
alias(name='QubitConverter', asname=None)
alias(name='ListOrDict', asname=None)
alias(name='BaseProblem', asname=None)
alias(name='ElectronicStructureResult', asname=None)
alias(name='deprecate_arguments', asname=None)
alias(name='MinimumEigensolverFactory', asname=None)
alias(name='GroundStateEigensolver', asname=None)
Name(id='logger', ctx=Store())
Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])
Name(id='GroundStateEigensolver', ctx=Load())
Expr(value=Str(s='A ground state calculation employing the AdaptVQE algorithm.\n\n    The performance of AdaptVQE significantly depends on the choice of `gradient` (see also\n    `qiskit.opflow.gradients`) and its parameters such as `grad_method`, `qfi_method` (if\n    applicable) and `epilson`.\n\n    To reproduce the default behavior of AdaptVQE prior to Qiskit Nature 0.4 you should supply\n    `delta=1` explicitly. This will use a finite difference scheme for the gradient evaluation\n    whereas after version 0.4 a parameter shift gradient will be used.\n    For more information refer to the gradient framework of Qiskit Terra:\n    https://qiskit.org/documentation/tutorials/operators/02_gradients_framework.html\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qubit_converter', annotation=Name(id='QubitConverter', ctx=Load())), arg(arg='solver', annotation=Name(id='MinimumEigensolverFactory', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='delta', annotation=Name(id='float', ctx=Load())), arg(arg='max_iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-05), Num(n=1.0), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            qubit_converter: a class that converts second quantized operator to qubit operator\n            solver: a factory for the VQE solver employing a UCCSD ansatz.\n            threshold: the energy convergence threshold. It has a minimum value of 1e-15.\n            delta: the finite difference step size for the gradient computation. It has a minimum\n                value of 1e-5.\n            max_iterations: the maximum number of iterations of the AdaptVQE algorithm.\n            gradient: a class that converts operator expression to the first-order gradient based\n                on the method mentioned.\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='threshold'), Name(id='threshold', ctx=Load()), Num(n=1e-15)], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='gradient', ctx=Load()), Name(id='float', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='qubit_converter', ctx=Load()), Name(id='solver', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Store())], value=Name(id='threshold', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Store())], value=Name(id='max_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store()), annotation=Name(id='PauliSumOp', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store()), annotation=Name(id='CircuitSampler', ctx=Load()), value=NameConstant(value=None), simple=0)], decorator_list=[Call(func=Name(id='deprecate_arguments', ctx=Load()), args=[Str(s='0.4.0'), Dict(keys=[Str(s='delta')], values=[Str(s='gradient')])], keywords=[keyword(arg='additional_msg', value=Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`."))])], returns=NameConstant(value=None))
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='GradientBase', ctx=Load()))
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='grad', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Sets the gradient.')), If(test=Compare(left=Name(id='grad', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='grad', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='grad', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='returns_groundstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Whether this class returns only the ground state energy or also the ground state itself.')), Return(value=NameConstant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='_compute_gradients', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='theta', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='vqe', annotation=Name(id='VQE', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Computes the gradients for all available excitation operators.\n\n        Args:\n            theta: list of (up to now) optimal parameters\n            vqe: the variational quantum eigensolver instance used for solving\n\n        Returns:\n            List of pairs consisting of gradient and excitation operator.\n        ')), Assign(targets=[Name(id='res', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='exc', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load()))), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='param_sets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta1', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='op', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_grad', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))])), Assign(targets=[Name(id='value_dict', ctx=Store())], value=Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)])), Assign(targets=[Name(id='state_grad_result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='_check_cyclicity', args=arguments(args=[arg(arg='indices', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Auxiliary function to check for cycles in the indices of the selected excitations.\n\n        Args:\n            indices: the list of chosen gradient indices.\n        Returns:\n            Whether repeating sequences of indices have been detected.\n        ')), Assign(targets=[Name(id='cycle_regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')], keywords=[])), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cycle detected: %s'), Name(id='match', ctx=Load())], keywords=[])), Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='BaseProblem', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Computes the ground state.\n\n        Args:\n            problem: a class encoding a problem to be solved.\n            aux_operators: Additional auxiliary operators to evaluate.\n\n        Raises:\n            QiskitNatureError: if a solver other than VQE or a ansatz other than UCCSD is provided\n                or if the algorithm finishes due to an unforeseen reason.\n            ValueError: if the grouped property object returned by the driver does not contain a\n                main property as requested by the problem being solved (`problem.main_property_name`)\n            QiskitNatureError: if the user-provided `aux_operators` contain a name which clashes\n                with an internally constructed auxiliary operator. Note: the names used for the\n                internal auxiliary operators correspond to the `Property.name` attributes which\n                generated the respective operators.\n            QiskitNatureError: if the chosen gradient method appears to result in all-zero gradients.\n\n        Returns:\n            An AdaptVQEResult which is an ElectronicStructureResult but also includes runtime\n            information about the AdaptVQE algorithm like the number of iterations, finishing\n            criterion, and the final maximum gradient.\n        ')), Assign(targets=[Name(id='second_q_ops', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Name(id='aux_second_q_ops', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Name(id='SecondQuantizedOp', ctx=Load())), ctx=Load()), value=None, simple=1), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())), Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))], orelse=[])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='main_second_q_op', ctx=Load())], keywords=[keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())), keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))])), Assign(targets=[Name(id='aux_ops', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_second_q_ops', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AnnAssign(target=Name(id='wrapped_aux_operators', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), value=Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])], orelse=[])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), Name(id='MinimumEigensolverFactory', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()))]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=False)), AnnAssign(target=Name(id='prev_op_indices', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='theta', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='max_grad', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), value=Tuple(elts=[Num(n=0.0), NameConstant(value=None)], ctx=Load()), simple=1), Assign(targets=[Name(id='iteration', ctx=Store())], value=Num(n=0)), While(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])]), body=[AugAssign(target=Name(id='iteration', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='cur_grads', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))])), Expr(value=Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())]), body=[If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Name(id='raw_vqe_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))]), If(test=Compare(left=Name(id='aux_ops', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=NameConstant(value=None))]), Assign(targets=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load())), If(test=Name(id='threshold_satisfied', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Threshold converged'))], orelse=[If(test=Name(id='alternating_sequence', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))], orelse=[If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])])]), Assign(targets=[Name(id='electronic_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load()), args=[Name(id='raw_vqe_result', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='AdaptVQEResult', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load()), args=[Name(id='electronic_result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_iterations', ctx=Store())], value=Name(id='iteration', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='final_max_gradient', ctx=Store())], value=Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='finishing_criterion', ctx=Store())], value=Name(id='finishing_criterion', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The final energy is: %s'), Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='AdaptVQEResult'))
Name(id='ElectronicStructureResult', ctx=Load())
Expr(value=Str(s='AdaptVQE Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Num(n=0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store()), annotation=Name(id='float', ctx=Load()), value=Num(n=0.0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Str(s=''), simple=0)], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of iterations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of iterations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='num_iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns final maximum gradient')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets final maximum gradient')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='final_max_gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns finishing criterion')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))
FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets finishing criterion')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='finishing_criterion', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
Store()
Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load())
Name(id='__name__', ctx=Load())
Load()
Str(s='A ground state calculation employing the AdaptVQE algorithm.\n\n    The performance of AdaptVQE significantly depends on the choice of `gradient` (see also\n    `qiskit.opflow.gradients`) and its parameters such as `grad_method`, `qfi_method` (if\n    applicable) and `epilson`.\n\n    To reproduce the default behavior of AdaptVQE prior to Qiskit Nature 0.4 you should supply\n    `delta=1` explicitly. This will use a finite difference scheme for the gradient evaluation\n    whereas after version 0.4 a parameter shift gradient will be used.\n    For more information refer to the gradient framework of Qiskit Terra:\n    https://qiskit.org/documentation/tutorials/operators/02_gradients_framework.html\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='qubit_converter', annotation=Name(id='QubitConverter', ctx=Load())), arg(arg='solver', annotation=Name(id='MinimumEigensolverFactory', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='delta', annotation=Name(id='float', ctx=Load())), arg(arg='max_iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-05), Num(n=1.0), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='\n        Args:\n            qubit_converter: a class that converts second quantized operator to qubit operator\n            solver: a factory for the VQE solver employing a UCCSD ansatz.\n            threshold: the energy convergence threshold. It has a minimum value of 1e-15.\n            delta: the finite difference step size for the gradient computation. It has a minimum\n                value of 1e-5.\n            max_iterations: the maximum number of iterations of the AdaptVQE algorithm.\n            gradient: a class that converts operator expression to the first-order gradient based\n                on the method mentioned.\n        '))
Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='threshold'), Name(id='threshold', ctx=Load()), Num(n=1e-15)], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='gradient', ctx=Load()), Name(id='float', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))]))], orelse=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='qubit_converter', ctx=Load()), Name(id='solver', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Store())], value=Name(id='threshold', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Store())], value=Name(id='max_iterations', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store()), annotation=Name(id='PauliSumOp', ctx=Load()), value=NameConstant(value=None), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store()), annotation=Name(id='CircuitSampler', ctx=Load()), value=NameConstant(value=None), simple=0)
Call(func=Name(id='deprecate_arguments', ctx=Load()), args=[Str(s='0.4.0'), Dict(keys=[Str(s='delta')], values=[Str(s='gradient')])], keywords=[keyword(arg='additional_msg', value=Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`."))])
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the gradient.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='GradientBase', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='grad', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='Sets the gradient.'))
If(test=Compare(left=Name(id='grad', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='grad', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='grad', ctx=Load()))
Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Whether this class returns only the ground state energy or also the ground state itself.'))
Return(value=NameConstant(value=True))
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='theta', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='vqe', annotation=Name(id='VQE', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Computes the gradients for all available excitation operators.\n\n        Args:\n            theta: list of (up to now) optimal parameters\n            vqe: the variational quantum eigensolver instance used for solving\n\n        Returns:\n            List of pairs consisting of gradient and excitation operator.\n        '))
Assign(targets=[Name(id='res', ctx=Store())], value=List(elts=[], ctx=Load()))
For(target=Name(id='exc', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load()))), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='param_sets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta1', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='op', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_grad', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))])), Assign(targets=[Name(id='value_dict', ctx=Store())], value=Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)])), Assign(targets=[Name(id='state_grad_result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])
Return(value=Name(id='res', ctx=Load()))
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='indices', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Auxiliary function to check for cycles in the indices of the selected excitations.\n\n        Args:\n            indices: the list of chosen gradient indices.\n        Returns:\n            Whether repeating sequences of indices have been detected.\n        '))
Assign(targets=[Name(id='cycle_regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')], keywords=[]))
Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cycle detected: %s'), Name(id='match', ctx=Load())], keywords=[]))
Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])]))
Name(id='staticmethod', ctx=Load())
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='BaseProblem', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='Computes the ground state.\n\n        Args:\n            problem: a class encoding a problem to be solved.\n            aux_operators: Additional auxiliary operators to evaluate.\n\n        Raises:\n            QiskitNatureError: if a solver other than VQE or a ansatz other than UCCSD is provided\n                or if the algorithm finishes due to an unforeseen reason.\n            ValueError: if the grouped property object returned by the driver does not contain a\n                main property as requested by the problem being solved (`problem.main_property_name`)\n            QiskitNatureError: if the user-provided `aux_operators` contain a name which clashes\n                with an internally constructed auxiliary operator. Note: the names used for the\n                internal auxiliary operators correspond to the `Property.name` attributes which\n                generated the respective operators.\n            QiskitNatureError: if the chosen gradient method appears to result in all-zero gradients.\n\n        Returns:\n            An AdaptVQEResult which is an ElectronicStructureResult but also includes runtime\n            information about the AdaptVQE algorithm like the number of iterations, finishing\n            criterion, and the final maximum gradient.\n        '))
Assign(targets=[Name(id='second_q_ops', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load()), args=[], keywords=[]))
AnnAssign(target=Name(id='aux_second_q_ops', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Name(id='SecondQuantizedOp', ctx=Load())), ctx=Load()), value=None, simple=1)
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())), Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))], orelse=[])])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='main_second_q_op', ctx=Load())], keywords=[keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())), keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))]))
Assign(targets=[Name(id='aux_ops', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_second_q_ops', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AnnAssign(target=Name(id='wrapped_aux_operators', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), value=Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])], orelse=[])], orelse=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), Name(id='MinimumEigensolverFactory', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()))])
If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[]), cause=None)], orelse=[])
If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=False))
Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=False))
Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=False))
AnnAssign(target=Name(id='prev_op_indices', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1)
AnnAssign(target=Name(id='theta', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1)
AnnAssign(target=Name(id='max_grad', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), value=Tuple(elts=[Num(n=0.0), NameConstant(value=None)], ctx=Load()), simple=1)
Assign(targets=[Name(id='iteration', ctx=Store())], value=Num(n=0))
While(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])]), body=[AugAssign(target=Name(id='iteration', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='cur_grads', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))])), Expr(value=Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())]), body=[If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Name(id='raw_vqe_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))])
If(test=Compare(left=Name(id='aux_ops', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=NameConstant(value=None))])
Assign(targets=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))
If(test=Name(id='threshold_satisfied', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Threshold converged'))], orelse=[If(test=Name(id='alternating_sequence', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))], orelse=[If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])])])
Assign(targets=[Name(id='electronic_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load()), args=[Name(id='raw_vqe_result', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='AdaptVQEResult', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load()), args=[Name(id='electronic_result', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_iterations', ctx=Store())], value=Name(id='iteration', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='final_max_gradient', ctx=Store())], value=Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='finishing_criterion', ctx=Store())], value=Name(id='finishing_criterion', ctx=Load()))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The final energy is: %s'), Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[]))
Return(value=Name(id='result', ctx=Load()))
Str(s='AdaptVQEResult')
Load()
Str(s='AdaptVQE Result.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Num(n=0), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store()), annotation=Name(id='float', ctx=Load()), value=Num(n=0.0), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Str(s=''), simple=0)
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns number of iterations'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets number of iterations'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='num_iterations', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns final maximum gradient'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets final maximum gradient'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='final_max_gradient', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns finishing criterion'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='str', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets finishing criterion'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='finishing_criterion', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
Name(id='logging', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='qubit_converter', annotation=Name(id='QubitConverter', ctx=Load()))
arg(arg='solver', annotation=Name(id='MinimumEigensolverFactory', ctx=Load()))
arg(arg='threshold', annotation=Name(id='float', ctx=Load()))
arg(arg='delta', annotation=Name(id='float', ctx=Load()))
arg(arg='max_iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))
Num(n=1e-05)
Num(n=1.0)
NameConstant(value=None)
NameConstant(value=None)
Str(s='\n        Args:\n            qubit_converter: a class that converts second quantized operator to qubit operator\n            solver: a factory for the VQE solver employing a UCCSD ansatz.\n            threshold: the energy convergence threshold. It has a minimum value of 1e-15.\n            delta: the finite difference step size for the gradient computation. It has a minimum\n                value of 1e-5.\n            max_iterations: the maximum number of iterations of the AdaptVQE algorithm.\n            gradient: a class that converts operator expression to the first-order gradient based\n                on the method mentioned.\n        ')
Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='threshold'), Name(id='threshold', ctx=Load()), Num(n=1e-15)], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='gradient', ctx=Load()), Name(id='float', ctx=Load())], keywords=[])
Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))]))
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='qubit_converter', ctx=Load()), Name(id='solver', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Store())
Name(id='threshold', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Store())
Name(id='max_iterations', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())
Name(id='gradient', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())
List(elts=[], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Store())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())
List(elts=[], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())
Name(id='PauliSumOp', ctx=Load())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
Name(id='QuantumCircuit', ctx=Load())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())
Name(id='CircuitSampler', ctx=Load())
NameConstant(value=None)
Name(id='deprecate_arguments', ctx=Load())
Str(s='0.4.0')
Dict(keys=[Str(s='delta')], values=[Str(s='gradient')])
keyword(arg='additional_msg', value=Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`."))
arg(arg='self', annotation=None)
Str(s='Returns the gradient.')
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='grad', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='Sets the gradient.')
Compare(left=Name(id='grad', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='grad', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))]))
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())
Name(id='grad', ctx=Load())
Name(id='gradient', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Whether this class returns only the ground state energy or also the ground state itself.')
NameConstant(value=True)
Load()
arg(arg='self', annotation=None)
arg(arg='theta', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
arg(arg='vqe', annotation=Name(id='VQE', ctx=Load()))
Str(s='\n        Computes the gradients for all available excitation operators.\n\n        Args:\n            theta: list of (up to now) optimal parameters\n            vqe: the variational quantum eigensolver instance used for solving\n\n        Returns:\n            List of pairs consisting of gradient and excitation operator.\n        ')
Name(id='res', ctx=Store())
List(elts=[], ctx=Load())
Name(id='exc', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Load())
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load())))
Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='param_sets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='theta1', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Name(id='op', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='state_grad', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))]))
Assign(targets=[Name(id='value_dict', ctx=Store())], value=Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)]))
Assign(targets=[Name(id='state_grad_result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[]))
Name(id='res', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
arg(arg='indices', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Str(s='\n        Auxiliary function to check for cycles in the indices of the selected excitations.\n\n        Args:\n            indices: the list of chosen gradient indices.\n        Returns:\n            Whether repeating sequences of indices have been detected.\n        ')
Name(id='cycle_regex', ctx=Store())
Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')], keywords=[])
Name(id='match', ctx=Store())
Call(func=Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cycle detected: %s'), Name(id='match', ctx=Load())], keywords=[])
BoolOp(op=Or(), values=[Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])])
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='problem', annotation=Name(id='BaseProblem', ctx=Load()))
arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='Computes the ground state.\n\n        Args:\n            problem: a class encoding a problem to be solved.\n            aux_operators: Additional auxiliary operators to evaluate.\n\n        Raises:\n            QiskitNatureError: if a solver other than VQE or a ansatz other than UCCSD is provided\n                or if the algorithm finishes due to an unforeseen reason.\n            ValueError: if the grouped property object returned by the driver does not contain a\n                main property as requested by the problem being solved (`problem.main_property_name`)\n            QiskitNatureError: if the user-provided `aux_operators` contain a name which clashes\n                with an internally constructed auxiliary operator. Note: the names used for the\n                internal auxiliary operators correspond to the `Property.name` attributes which\n                generated the respective operators.\n            QiskitNatureError: if the chosen gradient method appears to result in all-zero gradients.\n\n        Returns:\n            An AdaptVQEResult which is an ElectronicStructureResult but also includes runtime\n            information about the AdaptVQE algorithm like the number of iterations, finishing\n            criterion, and the final maximum gradient.\n        ')
Name(id='second_q_ops', ctx=Store())
Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load()), args=[], keywords=[])
Name(id='aux_second_q_ops', ctx=Store())
Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Name(id='SecondQuantizedOp', ctx=Load())), ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())), Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))], orelse=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='main_second_q_op', ctx=Load())], keywords=[keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())), keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))])
Name(id='aux_ops', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_second_q_ops', ctx=Load())], keywords=[])
Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
AnnAssign(target=Name(id='wrapped_aux_operators', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), value=Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]), simple=1)
For(target=Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])], orelse=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), Name(id='MinimumEigensolverFactory', ctx=Load())], keywords=[])
Assign(targets=[Name(id='vqe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='vqe', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()))
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[]))
Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[]), cause=None)
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[]))
Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[]), cause=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())
Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())
Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())], keywords=[])
Name(id='threshold_satisfied', ctx=Store())
NameConstant(value=False)
Name(id='alternating_sequence', ctx=Store())
NameConstant(value=False)
Name(id='max_iterations_exceeded', ctx=Store())
NameConstant(value=False)
Name(id='prev_op_indices', ctx=Store())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
List(elts=[], ctx=Load())
Name(id='theta', ctx=Store())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
List(elts=[], ctx=Load())
Name(id='max_grad', ctx=Store())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Tuple(elts=[Num(n=0.0), NameConstant(value=None)], ctx=Load())
Name(id='iteration', ctx=Store())
Num(n=0)
BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])])
AugAssign(target=Name(id='iteration', ctx=Store()), op=Add(), value=Num(n=1))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Name(id='cur_grads', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[]))
Assign(targets=[Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))]))
Expr(value=Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[]))
If(test=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))], orelse=[])
If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())]), body=[If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[])
If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[])
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[]))
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='theta', ctx=Load()))
Assign(targets=[Name(id='raw_vqe_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='theta', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=True))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Compare(left=Name(id='aux_ops', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='aux_values', ctx=Store())], value=NameConstant(value=None))
Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())
Name(id='aux_values', ctx=Load())
Name(id='threshold_satisfied', ctx=Load())
Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Threshold converged'))
If(test=Name(id='alternating_sequence', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))], orelse=[If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])])
Name(id='electronic_result', ctx=Store())
Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load()), args=[Name(id='raw_vqe_result', ctx=Load())], keywords=[])
Name(id='result', ctx=Store())
Call(func=Name(id='AdaptVQEResult', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load()), args=[Name(id='electronic_result', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='num_iterations', ctx=Store())
Name(id='iteration', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='final_max_gradient', ctx=Store())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='finishing_criterion', ctx=Store())
Name(id='finishing_criterion', ctx=Load())
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The final energy is: %s'), Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])
Name(id='result', ctx=Load())
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())
Name(id='int', ctx=Load())
Num(n=0)
Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())
Name(id='float', ctx=Load())
Num(n=0.0)
Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())
Name(id='str', ctx=Load())
Str(s='')
arg(arg='self', annotation=None)
Str(s='Returns number of iterations')
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='int', ctx=Load()))
Str(s='Sets number of iterations')
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())
Name(id='value', ctx=Load())
Name(id='num_iterations', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns final maximum gradient')
Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Sets final maximum gradient')
Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())
Name(id='value', ctx=Load())
Name(id='final_max_gradient', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns finishing criterion')
Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='str', ctx=Load()))
Str(s='Sets finishing criterion')
Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())
Name(id='value', ctx=Load())
Name(id='finishing_criterion', ctx=Load())
Load()
Load()
Name(id='QubitConverter', ctx=Load())
Name(id='MinimumEigensolverFactory', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load())
Name(id='validate_min', ctx=Load())
Str(s='threshold')
Name(id='threshold', ctx=Load())
Num(n=1e-15)
Name(id='isinstance', ctx=Load())
Name(id='gradient', ctx=Load())
Name(id='float', ctx=Load())
Name(id='gradient', ctx=Store())
Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))])
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='qubit_converter', ctx=Load())
Name(id='solver', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='List', ctx=Load())
Index(value=Name(id='OperatorBase', ctx=Load()))
Load()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='List', ctx=Load())
Index(value=Name(id='OperatorBase', ctx=Load()))
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Str(s='delta')
Str(s='gradient')
Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`.")
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load())
Name(id='grad', ctx=Load())
Is()
NameConstant(value=None)
Name(id='grad', ctx=Store())
Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Name(id='VQE', ctx=Load())
Store()
Load()
Store()
Name(id='self', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load()))
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[])
Name(id='param_sets', ctx=Store())
Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])
Name(id='theta1', ctx=Store())
Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[])
Name(id='op', ctx=Store())
Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])
Name(id='state_grad', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))])
Name(id='value_dict', ctx=Store())
Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)])
Name(id='state_grad_result', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[])
Load()
Load()
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Store()
Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load())
Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')
Store()
Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load())
Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Cycle detected: %s')
Name(id='match', ctx=Load())
Or()
Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])
Name(id='BaseProblem', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load())
Store()
Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load())
Store()
Name(id='ListOrDictType', ctx=Load())
Index(value=Name(id='SecondQuantizedOp', ctx=Load()))
Load()
Name(id='isinstance', ctx=Load())
Name(id='second_q_ops', ctx=Load())
Name(id='list', ctx=Load())
Name(id='main_second_q_op', ctx=Store())
Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='aux_second_q_ops', ctx=Store())
Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])
Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load()))
Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[]))
If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))
Name(id='self', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load())
Name(id='main_second_q_op', ctx=Load())
keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load()))
keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load())
Name(id='aux_second_q_ops', ctx=Load())
Name(id='aux_operators', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='wrapped_aux_operators', ctx=Store())
Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store())
Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load())
Name(id='MinimumEigensolverFactory', ctx=Load())
Name(id='vqe', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[])
Name(id='vqe', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load())
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[])
Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[])
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[])
Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[])
Name(id='self', ctx=Load())
Store()
Name(id='CircuitSampler', ctx=Load())
Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Store()
Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load())
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load())
Name(id='self', ctx=Load())
Store()
Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())
Store()
Store()
Store()
Store()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Store()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Store()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Num(n=0.0)
NameConstant(value=None)
Load()
Store()
Or()
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])
Name(id='iteration', ctx=Store())
Add()
Num(n=1)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[])
Name(id='cur_grads', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[])
Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))])
Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[])
Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)]))
AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>'))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))
Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())])
If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True))
Break()
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True))
Break()
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[])
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())
Name(id='theta', ctx=Load())
Name(id='raw_vqe_result', ctx=Store())
Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])
Name(id='theta', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[])
Name(id='max_iterations_exceeded', ctx=Store())
NameConstant(value=True)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='aux_ops', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='aux_values', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[])
Name(id='aux_values', ctx=Store())
NameConstant(value=None)
Name(id='raw_vqe_result', ctx=Load())
Store()
Load()
Load()
Name(id='finishing_criterion', ctx=Store())
Str(s='Threshold converged')
Name(id='alternating_sequence', ctx=Load())
Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))
If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])
Store()
Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load())
Name(id='raw_vqe_result', ctx=Load())
Store()
Name(id='AdaptVQEResult', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load())
Name(id='electronic_result', ctx=Load())
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='result', ctx=Load())
Store()
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='The final energy is: %s')
Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Load()
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='str', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='GradientBase', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Store()
Name(id='Gradient', ctx=Load())
keyword(arg='grad_method', value=Str(s='fin_diff'))
keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='GradientBase', ctx=Load()))
Load()
Load()
Store()
Name(id='Gradient', ctx=Load())
keyword(arg='grad_method', value=Str(s='param_shift'))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())
Add()
List(elts=[Name(id='exc', ctx=Load())], ctx=Load())
Name(id='vqe', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load())
Store()
Name(id='list', ctx=Load())
Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Store()
Name(id='dict', ctx=Load())
Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load())
Name(id='theta1', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load())
keyword(arg='operator', value=Name(id='op', ctx=Load()))
keyword(arg='params', value=Name(id='param_sets', ctx=Load()))
Store()
Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Num(n=0.0)
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Gradient computed : %s')
Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])
Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load())
Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='re', ctx=Load())
Load()
Name(id='cycle_regex', ctx=Load())
Load()
Attribute(value=Str(s=' '), attr='join', ctx=Load())
Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])
Name(id='logger', ctx=Load())
Load()
Load()
Name(id='match', ctx=Load())
IsNot()
NameConstant(value=None)
And()
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)])
Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Load()
Name(id='problem', ctx=Load())
Load()
Load()
Name(id='SecondQuantizedOp', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='second_q_ops', ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Name(id='second_q_ops', ctx=Load())
Slice(lower=Num(n=1), upper=None, step=None)
Load()
Name(id='isinstance', ctx=Load())
Name(id='second_q_ops', ctx=Load())
Name(id='dict', ctx=Load())
Name(id='name', ctx=Store())
Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())
Name(id='main_second_q_op', ctx=Store())
Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])
Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)
Name(id='aux_second_q_ops', ctx=Store())
Name(id='second_q_ops', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())
Load()
Load()
Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())
Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='ListOrDict', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='ListOrDict', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='name_aux', ctx=Store())
Name(id='aux_op', ctx=Store())
Store()
Name(id='iter', ctx=Load())
Name(id='wrapped_aux_operators', ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[])
Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))
Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])
Load()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load())
Name(id='problem', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='isinstance', ctx=Load())
Name(id='vqe', ctx=Load())
Name(id='VQE', ctx=Load())
Name(id='QiskitNatureError', ctx=Load())
Str(s='The AdaptVQE algorithm requires the use of the VQE solver')
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())
Name(id='UCC', ctx=Load())
Name(id='QiskitNatureError', ctx=Load())
Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')
Load()
Load()
Name(id='vqe', ctx=Load())
Load()
Load()
Name(id='copy', ctx=Load())
Load()
Name(id='vqe', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
Name(id='copy', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())
Is()
NameConstant(value=None)
Name(id='iteration', ctx=Load())
Lt()
Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())
Store()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='--- Iteration #%s ---')
Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load())
Name(id='theta', ctx=Load())
Name(id='vqe', ctx=Load())
Name(id='max_grad_index', ctx=Store())
Name(id='max_grad', ctx=Store())
Store()
Name(id='max', ctx=Load())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])
keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))
Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load())
Name(id='max_grad_index', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load())
Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())
Name(id='gradlog', ctx=Store())
JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])
Name(id='gradlog', ctx=Store())
Add()
Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])
AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)]))
If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Lt()
Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())
Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)])
Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='threshold_satisfied', ctx=Store())
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load())
Name(id='prev_op_indices', ctx=Load())
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='alternating_sequence', ctx=Store())
NameConstant(value=True)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load())
Num(n=0.0)
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='vqe', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='vqe', ctx=Load())
Store()
Load()
Store()
Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load())
Store()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Maximum number of iterations reached. Finishing.')
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Final maximum gradient: %s')
Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load())
Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load())
Name(id='aux_ops', ctx=Load())
Store()
Load()
Store()
Load()
Name(id='finishing_criterion', ctx=Store())
Str(s='Aborted due to cyclicity')
Name(id='max_iterations_exceeded', ctx=Load())
Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))
Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)
Name(id='problem', ctx=Load())
Load()
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Num(n=0)
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Load()
Name(id='GradientBase', ctx=Load())
Load()
Str(s='fin_diff')
Name(id='gradient', ctx=Load())
Name(id='super', ctx=Load())
Load()
Load()
Load()
Name(id='GradientBase', ctx=Load())
Load()
Str(s='param_shift')
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='exc', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Name(id='zip', ctx=Load())
Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Name(id='theta', ctx=Load())
Name(id='vqe', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load())
Load()
Name(id='op', ctx=Load())
Name(id='param_sets', ctx=Load())
Name(id='param_sets', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))])
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Name(id='state_grad_result', ctx=Load())
Name(id='res', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Name(id='exc', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Load()
Str(s=' ')
Load()
Name(id='map', ctx=Load())
Name(id='str', ctx=Load())
Name(id='indices', ctx=Load())
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[])
Gt()
Num(n=1)
Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())
Eq()
Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Load()
Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Load()
Load()
Load()
Num(n=0)
Load()
Num(n=1)
Load()
Load()
Load()
Store()
Name(id='problem', ctx=Load())
Load()
Store()
Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load())
Name(id='name', ctx=Load())
NameConstant(value=None)
Name(id='main_second_q_op', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[])
Store()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='problem', ctx=Load())
Load()
Name(id='problem', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Store()
Store()
Load()
Load()
Name(id='isinstance', ctx=Load())
Name(id='aux_op', ctx=Load())
Name(id='SecondQuantizedOp', ctx=Load())
Name(id='converted_aux_op', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[])
Name(id='converted_aux_op', ctx=Store())
Name(id='aux_op', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_ops', ctx=Load())
Name(id='list', ctx=Load())
Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])
If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='vqe', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Name(id='iteration', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Store()
Store()
Load()
Name(id='enumerate', ctx=Load())
Name(id='cur_grads', ctx=Load())
Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Name(id='prev_op_indices', ctx=Load())
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='logging', ctx=Load())
Load()
Store()
Str(s='\nGradients in iteration #')
FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Store()
Name(id='i', ctx=Store())
Name(id='grad', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='cur_grads', ctx=Load())
Name(id='gradlog', ctx=Store())
Add()
JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])
Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())])
AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Name(id='gradlog', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='iteration', ctx=Load())
Eq()
Num(n=1)
Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[])
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s')
Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])
Store()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Alternating sequence found. Finishing.')
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Final maximum gradient: %s')
Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=1))
Load()
Name(id='theta', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='vqe', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Load()
Name(id='raw_vqe_result', ctx=Load())
Load()
Load()
Store()
Load()
Name(id='finishing_criterion', ctx=Store())
Str(s='Maximum number of iterations reached')
Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[])
Load()
Load()
Load()
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='super', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='vqe', ctx=Load())
Load()
Load()
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load())
Name(id='state_grad', ctx=Load())
keyword(arg='params', value=Name(id='value_dict', ctx=Load()))
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='PauliSumOp', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='len', ctx=Load())
Name(id='indices', ctx=Load())
Name(id='indices', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=2)))
Load()
Name(id='indices', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='ListOrDictType', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Name(id='second_q_ops', ctx=Load())
Load()
Load()
Load()
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load())
Name(id='aux_op', ctx=Load())
NameConstant(value=True)
Store()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load())
Name(id='converted_aux_op', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_ops', ctx=Load())
Name(id='dict', ctx=Load())
Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])])
Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)
Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())
Name(id='converted_aux_op', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='PauliSumOp', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Load()
Load()
Load()
Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])
Store()
Store()
Load()
Load()
Store()
Str(s='\n')
FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Str(s=': ')
FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Str(s=': ')
FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Eq()
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Name(id='gradlog', ctx=Store())
Add()
Str(s='\t(*)')
Name(id='logger', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Name(id='QiskitNatureError', ctx=Load())
Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Load()
Load()
Num(n=1)
Load()
Load()
Load()
Load()
Name(id='raw_vqe_result', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Store()
Name(id='QiskitNatureError', ctx=Load())
Str(s='The algorithm finished due to an unforeseen reason!')
Name(id='result', ctx=Load())
Load()
Num(n=0)
Load()
Load()
Load()
Name(id='vqe', ctx=Load())
Load()
Load()
USub()
Num(n=1)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
Load()
Load()
Name(id='value_dict', ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='state_grad_result', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Load()
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Str(s='The main `SecondQuantizedOp` associated with the ')
FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None)
Str(s=' property cannot be `None`.')
Load()
Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())
Load()
Load()
Name(id='aux_ops', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='name_aux', ctx=Load())
In()
Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])
Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[])
Name(id='aux_ops', ctx=Load())
Index(value=Name(id='name_aux', ctx=Load()))
Store()
Load()
Load()
Load()
Name(id='PauliSumOp', ctx=Load())
arg(arg='item', annotation=None)
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='str', ctx=Load())
Name(id='iteration', ctx=Load())
Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])
Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])
Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='grad', ctx=Load())
Index(value=Num(n=1))
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=1))
Load()
Store()
Load()
Load()
Load()
Num(n=0)
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
USub()
Num(n=2)
USub()
Num(n=1)
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load()))
Load()
Name(id='name', ctx=Load())
Name(id='SecondQuantizedOp', ctx=Load())
Name(id='PauliSumOp', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load())
Name(id='QiskitNatureError', ctx=Load())
JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])
Load()
Name(id='name_aux', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Name(id='str', ctx=Load())
Name(id='i', ctx=Load())
Name(id='str', ctx=Load())
Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Name(id='str', ctx=Load())
Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Num(n=1)
Load()
Num(n=1)
Name(id='np', ctx=Load())
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Num(n=0)
Load()
USub()
Num(n=1)
Load()
Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Name(id='aux_ops', ctx=Load())
Load()
Load()
Str(s="The key '")
FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None)
Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")
Load()
Load()
Name(id='item', ctx=Load())
Index(value=Num(n=1))
Load()
Num(n=0)
Load()
Load()
Load()
Name(id='grad', ctx=Load())
Index(value=Num(n=1))
Load()
Load()
Name(id='grad', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Num(n=0)
Load()
Load()
Num(n=0)
Name(id='SecondQuantizedOp', ctx=Load())
Name(id='PauliSumOp', ctx=Load())
Load()
Load()
Name(id='name_aux', ctx=Load())
Load()
Num(n=1)
Load()
Num(n=1)
Load()
Num(n=0)
Load()
Load()
Load()
Module(body=[Expr(value=Str(s='A ground state calculation employing the AdaptVQE algorithm.')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None), alias(name='Union', asname=None)], level=0), Import(names=[alias(name='copy', asname=None)]), Import(names=[alias(name='re', asname=None)]), Import(names=[alias(name='logging', asname=None)]), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit.algorithms', names=[alias(name='VQE', asname=None)], level=0), ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None)], level=0), ImportFrom(module='qiskit.opflow', names=[alias(name='OperatorBase', asname=None), alias(name='PauliSumOp', asname=None), alias(name='CircuitSampler', asname=None)], level=0), ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None), alias(name='Gradient', asname=None)], level=0), ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0), ImportFrom(module='qiskit_nature', names=[alias(name='ListOrDictType', asname=None)], level=0), ImportFrom(module='qiskit_nature.exceptions', names=[alias(name='QiskitNatureError', asname=None)], level=0), ImportFrom(module='qiskit_nature.circuit.library', names=[alias(name='UCC', asname=None)], level=0), ImportFrom(module='qiskit_nature.operators.second_quantization', names=[alias(name='SecondQuantizedOp', asname=None)], level=0), ImportFrom(module='qiskit_nature.converters.second_quantization', names=[alias(name='QubitConverter', asname=None)], level=0), ImportFrom(module='qiskit_nature.converters.second_quantization.utils', names=[alias(name='ListOrDict', asname=None)], level=0), ImportFrom(module='qiskit_nature.problems.second_quantization', names=[alias(name='BaseProblem', asname=None)], level=0), ImportFrom(module='qiskit_nature.results', names=[alias(name='ElectronicStructureResult', asname=None)], level=0), ImportFrom(module='qiskit_nature.deprecation', names=[alias(name='deprecate_arguments', asname=None)], level=0), ImportFrom(module='minimum_eigensolver_factories', names=[alias(name='MinimumEigensolverFactory', asname=None)], level=1), ImportFrom(module='ground_state_eigensolver', names=[alias(name='GroundStateEigensolver', asname=None)], level=1), Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])), ClassDef(name='AdaptVQE', bases=[Name(id='GroundStateEigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='A ground state calculation employing the AdaptVQE algorithm.\n\n    The performance of AdaptVQE significantly depends on the choice of `gradient` (see also\n    `qiskit.opflow.gradients`) and its parameters such as `grad_method`, `qfi_method` (if\n    applicable) and `epilson`.\n\n    To reproduce the default behavior of AdaptVQE prior to Qiskit Nature 0.4 you should supply\n    `delta=1` explicitly. This will use a finite difference scheme for the gradient evaluation\n    whereas after version 0.4 a parameter shift gradient will be used.\n    For more information refer to the gradient framework of Qiskit Terra:\n    https://qiskit.org/documentation/tutorials/operators/02_gradients_framework.html\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qubit_converter', annotation=Name(id='QubitConverter', ctx=Load())), arg(arg='solver', annotation=Name(id='MinimumEigensolverFactory', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='delta', annotation=Name(id='float', ctx=Load())), arg(arg='max_iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-05), Num(n=1.0), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            qubit_converter: a class that converts second quantized operator to qubit operator\n            solver: a factory for the VQE solver employing a UCCSD ansatz.\n            threshold: the energy convergence threshold. It has a minimum value of 1e-15.\n            delta: the finite difference step size for the gradient computation. It has a minimum\n                value of 1e-5.\n            max_iterations: the maximum number of iterations of the AdaptVQE algorithm.\n            gradient: a class that converts operator expression to the first-order gradient based\n                on the method mentioned.\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='threshold'), Name(id='threshold', ctx=Load()), Num(n=1e-15)], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='gradient', ctx=Load()), Name(id='float', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='qubit_converter', ctx=Load()), Name(id='solver', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Store())], value=Name(id='threshold', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Store())], value=Name(id='max_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store()), annotation=Name(id='PauliSumOp', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store()), annotation=Name(id='CircuitSampler', ctx=Load()), value=NameConstant(value=None), simple=0)], decorator_list=[Call(func=Name(id='deprecate_arguments', ctx=Load()), args=[Str(s='0.4.0'), Dict(keys=[Str(s='delta')], values=[Str(s='gradient')])], keywords=[keyword(arg='additional_msg', value=Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`."))])], returns=NameConstant(value=None)), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='GradientBase', ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='grad', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Sets the gradient.')), If(test=Compare(left=Name(id='grad', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='grad', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='grad', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='returns_groundstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Whether this class returns only the ground state energy or also the ground state itself.')), Return(value=NameConstant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compute_gradients', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='theta', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='vqe', annotation=Name(id='VQE', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Computes the gradients for all available excitation operators.\n\n        Args:\n            theta: list of (up to now) optimal parameters\n            vqe: the variational quantum eigensolver instance used for solving\n\n        Returns:\n            List of pairs consisting of gradient and excitation operator.\n        ')), Assign(targets=[Name(id='res', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='exc', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load()))), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='param_sets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta1', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='op', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_grad', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))])), Assign(targets=[Name(id='value_dict', ctx=Store())], value=Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)])), Assign(targets=[Name(id='state_grad_result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='_check_cyclicity', args=arguments(args=[arg(arg='indices', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Auxiliary function to check for cycles in the indices of the selected excitations.\n\n        Args:\n            indices: the list of chosen gradient indices.\n        Returns:\n            Whether repeating sequences of indices have been detected.\n        ')), Assign(targets=[Name(id='cycle_regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')], keywords=[])), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cycle detected: %s'), Name(id='match', ctx=Load())], keywords=[])), Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='BaseProblem', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Computes the ground state.\n\n        Args:\n            problem: a class encoding a problem to be solved.\n            aux_operators: Additional auxiliary operators to evaluate.\n\n        Raises:\n            QiskitNatureError: if a solver other than VQE or a ansatz other than UCCSD is provided\n                or if the algorithm finishes due to an unforeseen reason.\n            ValueError: if the grouped property object returned by the driver does not contain a\n                main property as requested by the problem being solved (`problem.main_property_name`)\n            QiskitNatureError: if the user-provided `aux_operators` contain a name which clashes\n                with an internally constructed auxiliary operator. Note: the names used for the\n                internal auxiliary operators correspond to the `Property.name` attributes which\n                generated the respective operators.\n            QiskitNatureError: if the chosen gradient method appears to result in all-zero gradients.\n\n        Returns:\n            An AdaptVQEResult which is an ElectronicStructureResult but also includes runtime\n            information about the AdaptVQE algorithm like the number of iterations, finishing\n            criterion, and the final maximum gradient.\n        ')), Assign(targets=[Name(id='second_q_ops', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Name(id='aux_second_q_ops', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Name(id='SecondQuantizedOp', ctx=Load())), ctx=Load()), value=None, simple=1), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())), Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))], orelse=[])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='main_second_q_op', ctx=Load())], keywords=[keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())), keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))])), Assign(targets=[Name(id='aux_ops', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_second_q_ops', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AnnAssign(target=Name(id='wrapped_aux_operators', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), value=Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])], orelse=[])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), Name(id='MinimumEigensolverFactory', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()))]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=False)), AnnAssign(target=Name(id='prev_op_indices', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='theta', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='max_grad', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), value=Tuple(elts=[Num(n=0.0), NameConstant(value=None)], ctx=Load()), simple=1), Assign(targets=[Name(id='iteration', ctx=Store())], value=Num(n=0)), While(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])]), body=[AugAssign(target=Name(id='iteration', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='cur_grads', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))])), Expr(value=Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())]), body=[If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Name(id='raw_vqe_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))]), If(test=Compare(left=Name(id='aux_ops', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=NameConstant(value=None))]), Assign(targets=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load())), If(test=Name(id='threshold_satisfied', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Threshold converged'))], orelse=[If(test=Name(id='alternating_sequence', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))], orelse=[If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])])]), Assign(targets=[Name(id='electronic_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load()), args=[Name(id='raw_vqe_result', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='AdaptVQEResult', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load()), args=[Name(id='electronic_result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_iterations', ctx=Store())], value=Name(id='iteration', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='final_max_gradient', ctx=Store())], value=Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='finishing_criterion', ctx=Store())], value=Name(id='finishing_criterion', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The final energy is: %s'), Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='AdaptVQEResult'))], decorator_list=[]), ClassDef(name='AdaptVQEResult', bases=[Name(id='ElectronicStructureResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='AdaptVQE Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Num(n=0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store()), annotation=Name(id='float', ctx=Load()), value=Num(n=0.0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Str(s=''), simple=0)], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of iterations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of iterations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='num_iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns final maximum gradient')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets final maximum gradient')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='final_max_gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns finishing criterion')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets finishing criterion')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='finishing_criterion', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])])
Expr(value=Str(s='A ground state calculation employing the AdaptVQE algorithm.'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='List', asname=None), alias(name='Tuple', asname=None), alias(name='Union', asname=None)], level=0)
Import(names=[alias(name='copy', asname=None)])
Import(names=[alias(name='re', asname=None)])
Import(names=[alias(name='logging', asname=None)])
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit.algorithms', names=[alias(name='VQE', asname=None)], level=0)
ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None)], level=0)
ImportFrom(module='qiskit.opflow', names=[alias(name='OperatorBase', asname=None), alias(name='PauliSumOp', asname=None), alias(name='CircuitSampler', asname=None)], level=0)
ImportFrom(module='qiskit.opflow.gradients', names=[alias(name='GradientBase', asname=None), alias(name='Gradient', asname=None)], level=0)
ImportFrom(module='qiskit.utils.validation', names=[alias(name='validate_min', asname=None)], level=0)
ImportFrom(module='qiskit_nature', names=[alias(name='ListOrDictType', asname=None)], level=0)
ImportFrom(module='qiskit_nature.exceptions', names=[alias(name='QiskitNatureError', asname=None)], level=0)
ImportFrom(module='qiskit_nature.circuit.library', names=[alias(name='UCC', asname=None)], level=0)
ImportFrom(module='qiskit_nature.operators.second_quantization', names=[alias(name='SecondQuantizedOp', asname=None)], level=0)
ImportFrom(module='qiskit_nature.converters.second_quantization', names=[alias(name='QubitConverter', asname=None)], level=0)
ImportFrom(module='qiskit_nature.converters.second_quantization.utils', names=[alias(name='ListOrDict', asname=None)], level=0)
ImportFrom(module='qiskit_nature.problems.second_quantization', names=[alias(name='BaseProblem', asname=None)], level=0)
ImportFrom(module='qiskit_nature.results', names=[alias(name='ElectronicStructureResult', asname=None)], level=0)
ImportFrom(module='qiskit_nature.deprecation', names=[alias(name='deprecate_arguments', asname=None)], level=0)
ImportFrom(module='minimum_eigensolver_factories', names=[alias(name='MinimumEigensolverFactory', asname=None)], level=1)
ImportFrom(module='ground_state_eigensolver', names=[alias(name='GroundStateEigensolver', asname=None)], level=1)
Assign(targets=[Name(id='logger', ctx=Store())], value=Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[]))
ClassDef(name='AdaptVQE', bases=[Name(id='GroundStateEigensolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='A ground state calculation employing the AdaptVQE algorithm.\n\n    The performance of AdaptVQE significantly depends on the choice of `gradient` (see also\n    `qiskit.opflow.gradients`) and its parameters such as `grad_method`, `qfi_method` (if\n    applicable) and `epilson`.\n\n    To reproduce the default behavior of AdaptVQE prior to Qiskit Nature 0.4 you should supply\n    `delta=1` explicitly. This will use a finite difference scheme for the gradient evaluation\n    whereas after version 0.4 a parameter shift gradient will be used.\n    For more information refer to the gradient framework of Qiskit Terra:\n    https://qiskit.org/documentation/tutorials/operators/02_gradients_framework.html\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qubit_converter', annotation=Name(id='QubitConverter', ctx=Load())), arg(arg='solver', annotation=Name(id='MinimumEigensolverFactory', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='delta', annotation=Name(id='float', ctx=Load())), arg(arg='max_iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-05), Num(n=1.0), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            qubit_converter: a class that converts second quantized operator to qubit operator\n            solver: a factory for the VQE solver employing a UCCSD ansatz.\n            threshold: the energy convergence threshold. It has a minimum value of 1e-15.\n            delta: the finite difference step size for the gradient computation. It has a minimum\n                value of 1e-5.\n            max_iterations: the maximum number of iterations of the AdaptVQE algorithm.\n            gradient: a class that converts operator expression to the first-order gradient based\n                on the method mentioned.\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='threshold'), Name(id='threshold', ctx=Load()), Num(n=1e-15)], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='gradient', ctx=Load()), Name(id='float', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='qubit_converter', ctx=Load()), Name(id='solver', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Store())], value=Name(id='threshold', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Store())], value=Name(id='max_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store()), annotation=Name(id='PauliSumOp', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store()), annotation=Name(id='CircuitSampler', ctx=Load()), value=NameConstant(value=None), simple=0)], decorator_list=[Call(func=Name(id='deprecate_arguments', ctx=Load()), args=[Str(s='0.4.0'), Dict(keys=[Str(s='delta')], values=[Str(s='gradient')])], keywords=[keyword(arg='additional_msg', value=Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`."))])], returns=NameConstant(value=None)), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='GradientBase', ctx=Load())), FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='grad', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Sets the gradient.')), If(test=Compare(left=Name(id='grad', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='grad', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='grad', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='returns_groundstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Whether this class returns only the ground state energy or also the ground state itself.')), Return(value=NameConstant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load())), FunctionDef(name='_compute_gradients', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='theta', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='vqe', annotation=Name(id='VQE', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Computes the gradients for all available excitation operators.\n\n        Args:\n            theta: list of (up to now) optimal parameters\n            vqe: the variational quantum eigensolver instance used for solving\n\n        Returns:\n            List of pairs consisting of gradient and excitation operator.\n        ')), Assign(targets=[Name(id='res', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='exc', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load()))), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='param_sets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta1', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='op', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_grad', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))])), Assign(targets=[Name(id='value_dict', ctx=Store())], value=Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)])), Assign(targets=[Name(id='state_grad_result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), FunctionDef(name='_check_cyclicity', args=arguments(args=[arg(arg='indices', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Auxiliary function to check for cycles in the indices of the selected excitations.\n\n        Args:\n            indices: the list of chosen gradient indices.\n        Returns:\n            Whether repeating sequences of indices have been detected.\n        ')), Assign(targets=[Name(id='cycle_regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')], keywords=[])), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cycle detected: %s'), Name(id='match', ctx=Load())], keywords=[])), Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='bool', ctx=Load())), FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='BaseProblem', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Computes the ground state.\n\n        Args:\n            problem: a class encoding a problem to be solved.\n            aux_operators: Additional auxiliary operators to evaluate.\n\n        Raises:\n            QiskitNatureError: if a solver other than VQE or a ansatz other than UCCSD is provided\n                or if the algorithm finishes due to an unforeseen reason.\n            ValueError: if the grouped property object returned by the driver does not contain a\n                main property as requested by the problem being solved (`problem.main_property_name`)\n            QiskitNatureError: if the user-provided `aux_operators` contain a name which clashes\n                with an internally constructed auxiliary operator. Note: the names used for the\n                internal auxiliary operators correspond to the `Property.name` attributes which\n                generated the respective operators.\n            QiskitNatureError: if the chosen gradient method appears to result in all-zero gradients.\n\n        Returns:\n            An AdaptVQEResult which is an ElectronicStructureResult but also includes runtime\n            information about the AdaptVQE algorithm like the number of iterations, finishing\n            criterion, and the final maximum gradient.\n        ')), Assign(targets=[Name(id='second_q_ops', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Name(id='aux_second_q_ops', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Name(id='SecondQuantizedOp', ctx=Load())), ctx=Load()), value=None, simple=1), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())), Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))], orelse=[])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='main_second_q_op', ctx=Load())], keywords=[keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())), keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))])), Assign(targets=[Name(id='aux_ops', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_second_q_ops', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AnnAssign(target=Name(id='wrapped_aux_operators', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), value=Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])], orelse=[])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), Name(id='MinimumEigensolverFactory', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()))]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=False)), AnnAssign(target=Name(id='prev_op_indices', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='theta', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='max_grad', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), value=Tuple(elts=[Num(n=0.0), NameConstant(value=None)], ctx=Load()), simple=1), Assign(targets=[Name(id='iteration', ctx=Store())], value=Num(n=0)), While(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])]), body=[AugAssign(target=Name(id='iteration', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='cur_grads', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))])), Expr(value=Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())]), body=[If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Name(id='raw_vqe_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))]), If(test=Compare(left=Name(id='aux_ops', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=NameConstant(value=None))]), Assign(targets=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load())), If(test=Name(id='threshold_satisfied', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Threshold converged'))], orelse=[If(test=Name(id='alternating_sequence', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))], orelse=[If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])])]), Assign(targets=[Name(id='electronic_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load()), args=[Name(id='raw_vqe_result', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='AdaptVQEResult', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load()), args=[Name(id='electronic_result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_iterations', ctx=Store())], value=Name(id='iteration', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='final_max_gradient', ctx=Store())], value=Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='finishing_criterion', ctx=Store())], value=Name(id='finishing_criterion', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The final energy is: %s'), Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='AdaptVQEResult'))], decorator_list=[])
ClassDef(name='AdaptVQEResult', bases=[Name(id='ElectronicStructureResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='AdaptVQE Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Num(n=0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store()), annotation=Name(id='float', ctx=Load()), value=Num(n=0.0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Str(s=''), simple=0)], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of iterations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load())), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of iterations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='num_iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns final maximum gradient')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets final maximum gradient')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='final_max_gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns finishing criterion')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load())), FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets finishing criterion')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='finishing_criterion', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))], decorator_list=[])
Str(s='A ground state calculation employing the AdaptVQE algorithm.')
alias(name='Optional', asname=None)
alias(name='List', asname=None)
alias(name='Tuple', asname=None)
alias(name='Union', asname=None)
alias(name='copy', asname=None)
alias(name='re', asname=None)
alias(name='logging', asname=None)
alias(name='numpy', asname='np')
alias(name='VQE', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='OperatorBase', asname=None)
alias(name='PauliSumOp', asname=None)
alias(name='CircuitSampler', asname=None)
alias(name='GradientBase', asname=None)
alias(name='Gradient', asname=None)
alias(name='validate_min', asname=None)
alias(name='ListOrDictType', asname=None)
alias(name='QiskitNatureError', asname=None)
alias(name='UCC', asname=None)
alias(name='SecondQuantizedOp', asname=None)
alias(name='QubitConverter', asname=None)
alias(name='ListOrDict', asname=None)
alias(name='BaseProblem', asname=None)
alias(name='ElectronicStructureResult', asname=None)
alias(name='deprecate_arguments', asname=None)
alias(name='MinimumEigensolverFactory', asname=None)
alias(name='GroundStateEigensolver', asname=None)
Name(id='logger', ctx=Store())
Call(func=Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load()), args=[Name(id='__name__', ctx=Load())], keywords=[])
Name(id='GroundStateEigensolver', ctx=Load())
Expr(value=Str(s='A ground state calculation employing the AdaptVQE algorithm.\n\n    The performance of AdaptVQE significantly depends on the choice of `gradient` (see also\n    `qiskit.opflow.gradients`) and its parameters such as `grad_method`, `qfi_method` (if\n    applicable) and `epilson`.\n\n    To reproduce the default behavior of AdaptVQE prior to Qiskit Nature 0.4 you should supply\n    `delta=1` explicitly. This will use a finite difference scheme for the gradient evaluation\n    whereas after version 0.4 a parameter shift gradient will be used.\n    For more information refer to the gradient framework of Qiskit Terra:\n    https://qiskit.org/documentation/tutorials/operators/02_gradients_framework.html\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qubit_converter', annotation=Name(id='QubitConverter', ctx=Load())), arg(arg='solver', annotation=Name(id='MinimumEigensolverFactory', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='delta', annotation=Name(id='float', ctx=Load())), arg(arg='max_iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-05), Num(n=1.0), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            qubit_converter: a class that converts second quantized operator to qubit operator\n            solver: a factory for the VQE solver employing a UCCSD ansatz.\n            threshold: the energy convergence threshold. It has a minimum value of 1e-15.\n            delta: the finite difference step size for the gradient computation. It has a minimum\n                value of 1e-5.\n            max_iterations: the maximum number of iterations of the AdaptVQE algorithm.\n            gradient: a class that converts operator expression to the first-order gradient based\n                on the method mentioned.\n        ')), Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='threshold'), Name(id='threshold', ctx=Load()), Num(n=1e-15)], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='gradient', ctx=Load()), Name(id='float', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='qubit_converter', ctx=Load()), Name(id='solver', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Store())], value=Name(id='threshold', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Store())], value=Name(id='max_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store()), annotation=Name(id='PauliSumOp', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store()), annotation=Name(id='CircuitSampler', ctx=Load()), value=NameConstant(value=None), simple=0)], decorator_list=[Call(func=Name(id='deprecate_arguments', ctx=Load()), args=[Str(s='0.4.0'), Dict(keys=[Str(s='delta')], values=[Str(s='gradient')])], keywords=[keyword(arg='additional_msg', value=Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`."))])], returns=NameConstant(value=None))
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns the gradient.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='GradientBase', ctx=Load()))
FunctionDef(name='gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='grad', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Sets the gradient.')), If(test=Compare(left=Name(id='grad', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='grad', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='grad', ctx=Load()))], decorator_list=[Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='returns_groundstate', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Whether this class returns only the ground state energy or also the ground state itself.')), Return(value=NameConstant(value=True))], decorator_list=[], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='_compute_gradients', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='theta', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='vqe', annotation=Name(id='VQE', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Computes the gradients for all available excitation operators.\n\n        Args:\n            theta: list of (up to now) optimal parameters\n            vqe: the variational quantum eigensolver instance used for solving\n\n        Returns:\n            List of pairs consisting of gradient and excitation operator.\n        ')), Assign(targets=[Name(id='res', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='exc', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load()))), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='param_sets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta1', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='op', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_grad', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))])), Assign(targets=[Name(id='value_dict', ctx=Store())], value=Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)])), Assign(targets=[Name(id='state_grad_result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='res', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
FunctionDef(name='_check_cyclicity', args=arguments(args=[arg(arg='indices', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Auxiliary function to check for cycles in the indices of the selected excitations.\n\n        Args:\n            indices: the list of chosen gradient indices.\n        Returns:\n            Whether repeating sequences of indices have been detected.\n        ')), Assign(targets=[Name(id='cycle_regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')], keywords=[])), Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cycle detected: %s'), Name(id='match', ctx=Load())], keywords=[])), Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Name(id='bool', ctx=Load()))
FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='BaseProblem', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Computes the ground state.\n\n        Args:\n            problem: a class encoding a problem to be solved.\n            aux_operators: Additional auxiliary operators to evaluate.\n\n        Raises:\n            QiskitNatureError: if a solver other than VQE or a ansatz other than UCCSD is provided\n                or if the algorithm finishes due to an unforeseen reason.\n            ValueError: if the grouped property object returned by the driver does not contain a\n                main property as requested by the problem being solved (`problem.main_property_name`)\n            QiskitNatureError: if the user-provided `aux_operators` contain a name which clashes\n                with an internally constructed auxiliary operator. Note: the names used for the\n                internal auxiliary operators correspond to the `Property.name` attributes which\n                generated the respective operators.\n            QiskitNatureError: if the chosen gradient method appears to result in all-zero gradients.\n\n        Returns:\n            An AdaptVQEResult which is an ElectronicStructureResult but also includes runtime\n            information about the AdaptVQE algorithm like the number of iterations, finishing\n            criterion, and the final maximum gradient.\n        ')), Assign(targets=[Name(id='second_q_ops', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Name(id='aux_second_q_ops', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Name(id='SecondQuantizedOp', ctx=Load())), ctx=Load()), value=None, simple=1), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())), Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))], orelse=[])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='main_second_q_op', ctx=Load())], keywords=[keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())), keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))])), Assign(targets=[Name(id='aux_ops', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_second_q_ops', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AnnAssign(target=Name(id='wrapped_aux_operators', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), value=Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])], orelse=[])], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), Name(id='MinimumEigensolverFactory', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()))]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=False)), AnnAssign(target=Name(id='prev_op_indices', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='theta', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1), AnnAssign(target=Name(id='max_grad', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), value=Tuple(elts=[Num(n=0.0), NameConstant(value=None)], ctx=Load()), simple=1), Assign(targets=[Name(id='iteration', ctx=Store())], value=Num(n=0)), While(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])]), body=[AugAssign(target=Name(id='iteration', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='cur_grads', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))])), Expr(value=Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())]), body=[If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Name(id='raw_vqe_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))]), If(test=Compare(left=Name(id='aux_ops', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=NameConstant(value=None))]), Assign(targets=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load())), If(test=Name(id='threshold_satisfied', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Threshold converged'))], orelse=[If(test=Name(id='alternating_sequence', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))], orelse=[If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])])]), Assign(targets=[Name(id='electronic_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load()), args=[Name(id='raw_vqe_result', ctx=Load())], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='AdaptVQEResult', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load()), args=[Name(id='electronic_result', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_iterations', ctx=Store())], value=Name(id='iteration', ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='final_max_gradient', ctx=Store())], value=Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='finishing_criterion', ctx=Store())], value=Name(id='finishing_criterion', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The final energy is: %s'), Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])), Return(value=Name(id='result', ctx=Load()))], decorator_list=[], returns=Str(s='AdaptVQEResult'))
Name(id='ElectronicStructureResult', ctx=Load())
Expr(value=Str(s='AdaptVQE Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Num(n=0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store()), annotation=Name(id='float', ctx=Load()), value=Num(n=0.0), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Str(s=''), simple=0)], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns number of iterations')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets number of iterations')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='num_iterations', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns final maximum gradient')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='final_max_gradient', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets final maximum gradient')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='final_max_gradient', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Returns finishing criterion')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='str', ctx=Load()))
FunctionDef(name='finishing_criterion', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Sets finishing criterion')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())], value=Name(id='value', ctx=Load()))], decorator_list=[Attribute(value=Name(id='finishing_criterion', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
Store()
Attribute(value=Name(id='logging', ctx=Load()), attr='getLogger', ctx=Load())
Name(id='__name__', ctx=Load())
Load()
Str(s='A ground state calculation employing the AdaptVQE algorithm.\n\n    The performance of AdaptVQE significantly depends on the choice of `gradient` (see also\n    `qiskit.opflow.gradients`) and its parameters such as `grad_method`, `qfi_method` (if\n    applicable) and `epilson`.\n\n    To reproduce the default behavior of AdaptVQE prior to Qiskit Nature 0.4 you should supply\n    `delta=1` explicitly. This will use a finite difference scheme for the gradient evaluation\n    whereas after version 0.4 a parameter shift gradient will be used.\n    For more information refer to the gradient framework of Qiskit Terra:\n    https://qiskit.org/documentation/tutorials/operators/02_gradients_framework.html\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='qubit_converter', annotation=Name(id='QubitConverter', ctx=Load())), arg(arg='solver', annotation=Name(id='MinimumEigensolverFactory', ctx=Load())), arg(arg='threshold', annotation=Name(id='float', ctx=Load())), arg(arg='delta', annotation=Name(id='float', ctx=Load())), arg(arg='max_iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())), arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=1e-05), Num(n=1.0), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='\n        Args:\n            qubit_converter: a class that converts second quantized operator to qubit operator\n            solver: a factory for the VQE solver employing a UCCSD ansatz.\n            threshold: the energy convergence threshold. It has a minimum value of 1e-15.\n            delta: the finite difference step size for the gradient computation. It has a minimum\n                value of 1e-5.\n            max_iterations: the maximum number of iterations of the AdaptVQE algorithm.\n            gradient: a class that converts operator expression to the first-order gradient based\n                on the method mentioned.\n        '))
Expr(value=Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='threshold'), Name(id='threshold', ctx=Load()), Num(n=1e-15)], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='gradient', ctx=Load()), Name(id='float', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))]))], orelse=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='qubit_converter', ctx=Load()), Name(id='solver', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Store())], value=Name(id='threshold', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Store())], value=Name(id='max_iterations', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())], value=Name(id='gradient', ctx=Load()))
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store()), annotation=Name(id='PauliSumOp', ctx=Load()), value=NameConstant(value=None), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store()), annotation=Name(id='QuantumCircuit', ctx=Load()), value=NameConstant(value=None), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store()), annotation=Name(id='CircuitSampler', ctx=Load()), value=NameConstant(value=None), simple=0)
Call(func=Name(id='deprecate_arguments', ctx=Load()), args=[Str(s='0.4.0'), Dict(keys=[Str(s='delta')], values=[Str(s='gradient')])], keywords=[keyword(arg='additional_msg', value=Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`."))])
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns the gradient.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='GradientBase', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='grad', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='Sets the gradient.'))
If(test=Compare(left=Name(id='grad', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='grad', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())], value=Name(id='grad', ctx=Load()))
Attribute(value=Name(id='gradient', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Whether this class returns only the ground state energy or also the ground state itself.'))
Return(value=NameConstant(value=True))
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='theta', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())), arg(arg='vqe', annotation=Name(id='VQE', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Computes the gradients for all available excitation operators.\n\n        Args:\n            theta: list of (up to now) optimal parameters\n            vqe: the variational quantum eigensolver instance used for solving\n\n        Returns:\n            List of pairs consisting of gradient and excitation operator.\n        '))
Assign(targets=[Name(id='res', ctx=Store())], value=List(elts=[], ctx=Load()))
For(target=Name(id='exc', ctx=Store()), iter=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Load()), body=[Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load()))), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='param_sets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta1', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='op', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='state_grad', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))])), Assign(targets=[Name(id='value_dict', ctx=Store())], value=Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)])), Assign(targets=[Name(id='state_grad_result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[]))], orelse=[])
Return(value=Name(id='res', ctx=Load()))
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
arguments(args=[arg(arg='indices', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Auxiliary function to check for cycles in the indices of the selected excitations.\n\n        Args:\n            indices: the list of chosen gradient indices.\n        Returns:\n            Whether repeating sequences of indices have been detected.\n        '))
Assign(targets=[Name(id='cycle_regex', ctx=Store())], value=Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')], keywords=[]))
Assign(targets=[Name(id='match', ctx=Store())], value=Call(func=Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cycle detected: %s'), Name(id='match', ctx=Load())], keywords=[]))
Return(value=BoolOp(op=Or(), values=[Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])]))
Name(id='staticmethod', ctx=Load())
Name(id='bool', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='problem', annotation=Name(id='BaseProblem', ctx=Load())), arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='Computes the ground state.\n\n        Args:\n            problem: a class encoding a problem to be solved.\n            aux_operators: Additional auxiliary operators to evaluate.\n\n        Raises:\n            QiskitNatureError: if a solver other than VQE or a ansatz other than UCCSD is provided\n                or if the algorithm finishes due to an unforeseen reason.\n            ValueError: if the grouped property object returned by the driver does not contain a\n                main property as requested by the problem being solved (`problem.main_property_name`)\n            QiskitNatureError: if the user-provided `aux_operators` contain a name which clashes\n                with an internally constructed auxiliary operator. Note: the names used for the\n                internal auxiliary operators correspond to the `Property.name` attributes which\n                generated the respective operators.\n            QiskitNatureError: if the chosen gradient method appears to result in all-zero gradients.\n\n        Returns:\n            An AdaptVQEResult which is an ElectronicStructureResult but also includes runtime\n            information about the AdaptVQE algorithm like the number of iterations, finishing\n            criterion, and the final maximum gradient.\n        '))
Assign(targets=[Name(id='second_q_ops', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load()), args=[], keywords=[]))
AnnAssign(target=Name(id='aux_second_q_ops', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Name(id='SecondQuantizedOp', ctx=Load())), ctx=Load()), value=None, simple=1)
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())), Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))], orelse=[])])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='main_second_q_op', ctx=Load())], keywords=[keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())), keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))]))
Assign(targets=[Name(id='aux_ops', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_second_q_ops', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AnnAssign(target=Name(id='wrapped_aux_operators', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), value=Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]), simple=1), For(target=Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])], orelse=[])], orelse=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), Name(id='MinimumEigensolverFactory', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='vqe', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()))])
If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[]), cause=None)], orelse=[])
If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=False))
Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=False))
Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=False))
AnnAssign(target=Name(id='prev_op_indices', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1)
AnnAssign(target=Name(id='theta', ctx=Store()), annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()), value=List(elts=[], ctx=Load()), simple=1)
AnnAssign(target=Name(id='max_grad', ctx=Store()), annotation=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), value=Tuple(elts=[Num(n=0.0), NameConstant(value=None)], ctx=Load()), simple=1)
Assign(targets=[Name(id='iteration', ctx=Store())], value=Num(n=0))
While(test=BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])]), body=[AugAssign(target=Name(id='iteration', ctx=Store()), op=Add(), value=Num(n=1)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='cur_grads', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))])), Expr(value=Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[])), If(test=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())]), body=[If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[]), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())), Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='theta', ctx=Load())), Assign(targets=[Name(id='raw_vqe_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])), Assign(targets=[Name(id='theta', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=True)), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))])
If(test=Compare(left=Name(id='aux_ops', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='aux_values', ctx=Store())], value=NameConstant(value=None))])
Assign(targets=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())], value=Name(id='aux_values', ctx=Load()))
If(test=Name(id='threshold_satisfied', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Threshold converged'))], orelse=[If(test=Name(id='alternating_sequence', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))], orelse=[If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])])])
Assign(targets=[Name(id='electronic_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load()), args=[Name(id='raw_vqe_result', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='AdaptVQEResult', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load()), args=[Name(id='electronic_result', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='num_iterations', ctx=Store())], value=Name(id='iteration', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='final_max_gradient', ctx=Store())], value=Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Attribute(value=Name(id='result', ctx=Load()), attr='finishing_criterion', ctx=Store())], value=Name(id='finishing_criterion', ctx=Load()))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The final energy is: %s'), Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[]))
Return(value=Name(id='result', ctx=Load()))
Str(s='AdaptVQEResult')
Load()
Str(s='AdaptVQE Result.')
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Num(n=0), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store()), annotation=Name(id='float', ctx=Load()), value=Num(n=0.0), simple=0)
AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Str(s=''), simple=0)
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns number of iterations'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets number of iterations'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='num_iterations', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns final maximum gradient'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets final maximum gradient'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='final_max_gradient', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Returns finishing criterion'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='str', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='value', annotation=Name(id='str', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Sets finishing criterion'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())], value=Name(id='value', ctx=Load()))
Attribute(value=Name(id='finishing_criterion', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
Name(id='logging', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='qubit_converter', annotation=Name(id='QubitConverter', ctx=Load()))
arg(arg='solver', annotation=Name(id='MinimumEigensolverFactory', ctx=Load()))
arg(arg='threshold', annotation=Name(id='float', ctx=Load()))
arg(arg='delta', annotation=Name(id='float', ctx=Load()))
arg(arg='max_iterations', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
arg(arg='gradient', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))
Num(n=1e-05)
Num(n=1.0)
NameConstant(value=None)
NameConstant(value=None)
Str(s='\n        Args:\n            qubit_converter: a class that converts second quantized operator to qubit operator\n            solver: a factory for the VQE solver employing a UCCSD ansatz.\n            threshold: the energy convergence threshold. It has a minimum value of 1e-15.\n            delta: the finite difference step size for the gradient computation. It has a minimum\n                value of 1e-5.\n            max_iterations: the maximum number of iterations of the AdaptVQE algorithm.\n            gradient: a class that converts operator expression to the first-order gradient based\n                on the method mentioned.\n        ')
Call(func=Name(id='validate_min', ctx=Load()), args=[Str(s='threshold'), Name(id='threshold', ctx=Load()), Num(n=1e-15)], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='gradient', ctx=Load()), Name(id='float', ctx=Load())], keywords=[])
Assign(targets=[Name(id='gradient', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))]))
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[Name(id='qubit_converter', ctx=Load()), Name(id='solver', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Store())
Name(id='threshold', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Store())
Name(id='max_iterations', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Store())
Name(id='gradient', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())
List(elts=[], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Store())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='OperatorBase', ctx=Load())), ctx=Load())
List(elts=[], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())
Name(id='PauliSumOp', ctx=Load())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
Name(id='QuantumCircuit', ctx=Load())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())
Name(id='CircuitSampler', ctx=Load())
NameConstant(value=None)
Name(id='deprecate_arguments', ctx=Load())
Str(s='0.4.0')
Dict(keys=[Str(s='delta')], values=[Str(s='gradient')])
keyword(arg='additional_msg', value=Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`."))
arg(arg='self', annotation=None)
Str(s='Returns the gradient.')
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='grad', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='Sets the gradient.')
Compare(left=Name(id='grad', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='grad', ctx=Store())], value=Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))]))
Attribute(value=Name(id='self', ctx=Load()), attr='_gradient', ctx=Store())
Name(id='grad', ctx=Load())
Name(id='gradient', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Whether this class returns only the ground state energy or also the ground state itself.')
NameConstant(value=True)
Load()
arg(arg='self', annotation=None)
arg(arg='theta', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load()))
arg(arg='vqe', annotation=Name(id='VQE', ctx=Load()))
Str(s='\n        Computes the gradients for all available excitation operators.\n\n        Args:\n            theta: list of (up to now) optimal parameters\n            vqe: the variational quantum eigensolver instance used for solving\n\n        Returns:\n            List of pairs consisting of gradient and excitation operator.\n        ')
Name(id='res', ctx=Store())
List(elts=[], ctx=Load())
Name(id='exc', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Load())
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load())))
Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='param_sets', ctx=Store())], value=Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='theta1', ctx=Store())], value=Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Name(id='op', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='state_grad', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))]))
Assign(targets=[Name(id='value_dict', ctx=Store())], value=Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)]))
Assign(targets=[Name(id='state_grad_result', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[]))
Name(id='res', ctx=Load())
Name(id='List', ctx=Load())
Index(value=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
arg(arg='indices', annotation=Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
Str(s='\n        Auxiliary function to check for cycles in the indices of the selected excitations.\n\n        Args:\n            indices: the list of chosen gradient indices.\n        Returns:\n            Whether repeating sequences of indices have been detected.\n        ')
Name(id='cycle_regex', ctx=Store())
Call(func=Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load()), args=[Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')], keywords=[])
Name(id='match', ctx=Store())
Call(func=Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load()), args=[Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load()), args=[Str(s='Cycle detected: %s'), Name(id='match', ctx=Load())], keywords=[])
BoolOp(op=Or(), values=[Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])])
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='problem', annotation=Name(id='BaseProblem', ctx=Load()))
arg(arg='aux_operators', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='Computes the ground state.\n\n        Args:\n            problem: a class encoding a problem to be solved.\n            aux_operators: Additional auxiliary operators to evaluate.\n\n        Raises:\n            QiskitNatureError: if a solver other than VQE or a ansatz other than UCCSD is provided\n                or if the algorithm finishes due to an unforeseen reason.\n            ValueError: if the grouped property object returned by the driver does not contain a\n                main property as requested by the problem being solved (`problem.main_property_name`)\n            QiskitNatureError: if the user-provided `aux_operators` contain a name which clashes\n                with an internally constructed auxiliary operator. Note: the names used for the\n                internal auxiliary operators correspond to the `Property.name` attributes which\n                generated the respective operators.\n            QiskitNatureError: if the chosen gradient method appears to result in all-zero gradients.\n\n        Returns:\n            An AdaptVQEResult which is an ElectronicStructureResult but also includes runtime\n            information about the AdaptVQE algorithm like the number of iterations, finishing\n            criterion, and the final maximum gradient.\n        ')
Name(id='second_q_ops', ctx=Store())
Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load()), args=[], keywords=[])
Name(id='aux_second_q_ops', ctx=Store())
Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Name(id='SecondQuantizedOp', ctx=Load())), ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load()))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())), Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])), If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))], orelse=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='main_second_q_op', ctx=Load())], keywords=[keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())), keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))])
Name(id='aux_ops', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_second_q_ops', ctx=Load())], keywords=[])
Compare(left=Name(id='aux_operators', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
AnnAssign(target=Name(id='wrapped_aux_operators', ctx=Store()), annotation=Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()), value=Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[]), simple=1)
For(target=Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])], orelse=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), Name(id='MinimumEigensolverFactory', ctx=Load())], keywords=[])
Assign(targets=[Name(id='vqe', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='vqe', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()))
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[]))
Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[]), cause=None)
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[]))
Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[]), cause=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())
Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Store())
Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())], keywords=[])
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_pool', ctx=Store())
Call(func=Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())], keywords=[])
Name(id='threshold_satisfied', ctx=Store())
NameConstant(value=False)
Name(id='alternating_sequence', ctx=Store())
NameConstant(value=False)
Name(id='max_iterations_exceeded', ctx=Store())
NameConstant(value=False)
Name(id='prev_op_indices', ctx=Store())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
List(elts=[], ctx=Load())
Name(id='theta', ctx=Store())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
List(elts=[], ctx=Load())
Name(id='max_grad', ctx=Store())
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Tuple(elts=[Num(n=0.0), NameConstant(value=None)], ctx=Load())
Name(id='iteration', ctx=Store())
Num(n=0)
BoolOp(op=Or(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])])
AugAssign(target=Name(id='iteration', ctx=Store()), op=Add(), value=Num(n=1))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Name(id='cur_grads', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[]))
Assign(targets=[Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))]))
Expr(value=Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[]))
If(test=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))], orelse=[])
If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())]), body=[If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[])
If(test=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True)), Break()], orelse=[])
Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[]))
Assign(targets=[Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())], value=Name(id='theta', ctx=Load()))
Assign(targets=[Name(id='raw_vqe_result', ctx=Store())], value=Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='theta', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='max_iterations_exceeded', ctx=Store())], value=NameConstant(value=True))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Compare(left=Name(id='aux_ops', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='aux_values', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='aux_values', ctx=Store())], value=NameConstant(value=None))
Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='aux_operator_eigenvalues', ctx=Store())
Name(id='aux_values', ctx=Load())
Name(id='threshold_satisfied', ctx=Load())
Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Threshold converged'))
If(test=Name(id='alternating_sequence', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))], orelse=[If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])])
Name(id='electronic_result', ctx=Store())
Call(func=Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load()), args=[Name(id='raw_vqe_result', ctx=Load())], keywords=[])
Name(id='result', ctx=Store())
Call(func=Name(id='AdaptVQEResult', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load()), args=[Name(id='electronic_result', ctx=Load())], keywords=[])
Attribute(value=Name(id='result', ctx=Load()), attr='num_iterations', ctx=Store())
Name(id='iteration', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='final_max_gradient', ctx=Store())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='finishing_criterion', ctx=Store())
Name(id='finishing_criterion', ctx=Load())
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='The final energy is: %s'), Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])
Name(id='result', ctx=Load())
arg(arg='self', annotation=None)
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())
Name(id='int', ctx=Load())
Num(n=0)
Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())
Name(id='float', ctx=Load())
Num(n=0.0)
Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())
Name(id='str', ctx=Load())
Str(s='')
arg(arg='self', annotation=None)
Str(s='Returns number of iterations')
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='int', ctx=Load()))
Str(s='Sets number of iterations')
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())
Name(id='value', ctx=Load())
Name(id='num_iterations', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns final maximum gradient')
Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='float', ctx=Load()))
Str(s='Sets final maximum gradient')
Attribute(value=Name(id='self', ctx=Load()), attr='_final_max_gradient', ctx=Store())
Name(id='value', ctx=Load())
Name(id='final_max_gradient', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='Returns finishing criterion')
Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='value', annotation=Name(id='str', ctx=Load()))
Str(s='Sets finishing criterion')
Attribute(value=Name(id='self', ctx=Load()), attr='_finishing_criterion', ctx=Store())
Name(id='value', ctx=Load())
Name(id='finishing_criterion', ctx=Load())
Load()
Load()
Name(id='QubitConverter', ctx=Load())
Name(id='MinimumEigensolverFactory', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load())
Name(id='validate_min', ctx=Load())
Str(s='threshold')
Name(id='threshold', ctx=Load())
Num(n=1e-15)
Name(id='isinstance', ctx=Load())
Name(id='gradient', ctx=Load())
Name(id='float', ctx=Load())
Name(id='gradient', ctx=Store())
Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='fin_diff')), keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))])
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='qubit_converter', ctx=Load())
Name(id='solver', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='List', ctx=Load())
Index(value=Name(id='OperatorBase', ctx=Load()))
Load()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='List', ctx=Load())
Index(value=Name(id='OperatorBase', ctx=Load()))
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Str(s='delta')
Str(s='gradient')
Str(s="Instead of `delta=1.0` you have to construct a gradient, like so `gradient=Gradient(grad_method='fin_diff', epsilon=1.0)`.")
Name(id='self', ctx=Load())
Load()
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='GradientBase', ctx=Load())), ctx=Load())
Name(id='grad', ctx=Load())
Is()
NameConstant(value=None)
Name(id='grad', ctx=Store())
Call(func=Name(id='Gradient', ctx=Load()), args=[], keywords=[keyword(arg='grad_method', value=Str(s='param_shift'))])
Name(id='self', ctx=Load())
Store()
Load()
Load()
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Name(id='VQE', ctx=Load())
Store()
Load()
Store()
Name(id='self', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), op=Add(), right=List(elts=[Name(id='exc', ctx=Load())], ctx=Load()))
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load()), args=[], keywords=[])
Name(id='param_sets', ctx=Store())
Call(func=Name(id='list', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())], keywords=[])
Name(id='theta1', ctx=Store())
Call(func=Name(id='dict', ctx=Load()), args=[Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])], keywords=[])
Name(id='op', ctx=Store())
Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load()), args=[Name(id='theta1', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])
Name(id='state_grad', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load()), args=[], keywords=[keyword(arg='operator', value=Name(id='op', ctx=Load())), keyword(arg='params', value=Name(id='param_sets', ctx=Load()))])
Name(id='value_dict', ctx=Store())
Dict(keys=[Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], values=[Num(n=0.0)])
Name(id='state_grad_result', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Gradient computed : %s'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])], keywords=[])
Call(func=Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load()), args=[Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())], keywords=[])
Load()
Load()
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Store()
Attribute(value=Name(id='re', ctx=Load()), attr='compile', ctx=Load())
Str(s='(\\b.+ .+\\b)( \\b\\1\\b)+')
Store()
Attribute(value=Name(id='cycle_regex', ctx=Load()), attr='search', ctx=Load())
Call(func=Attribute(value=Str(s=' '), attr='join', ctx=Load()), args=[Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])], keywords=[])
Attribute(value=Name(id='logger', ctx=Load()), attr='debug', ctx=Load())
Str(s='Cycle detected: %s')
Name(id='match', ctx=Load())
Or()
Compare(left=Name(id='match', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
BoolOp(op=And(), values=[Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)]), Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])])
Name(id='BaseProblem', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), ctx=Load())
Store()
Attribute(value=Name(id='problem', ctx=Load()), attr='second_q_ops', ctx=Load())
Store()
Name(id='ListOrDictType', ctx=Load())
Index(value=Name(id='SecondQuantizedOp', ctx=Load()))
Load()
Name(id='isinstance', ctx=Load())
Name(id='second_q_ops', ctx=Load())
Name(id='list', ctx=Load())
Name(id='main_second_q_op', ctx=Store())
Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='aux_second_q_ops', ctx=Store())
Subscript(value=Name(id='second_q_ops', ctx=Load()), slice=Slice(lower=Num(n=1), upper=None, step=None), ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='second_q_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])
Assign(targets=[Name(id='name', ctx=Store())], value=Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load()))
Assign(targets=[Name(id='main_second_q_op', ctx=Store())], value=Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[]))
If(test=Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='aux_second_q_ops', ctx=Store())], value=Name(id='second_q_ops', ctx=Load()))
Name(id='self', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert', ctx=Load())
Name(id='main_second_q_op', ctx=Load())
keyword(arg='num_particles', value=Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load()))
keyword(arg='sector_locator', value=Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load()))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load())
Name(id='aux_second_q_ops', ctx=Load())
Name(id='aux_operators', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='wrapped_aux_operators', ctx=Store())
Subscript(value=Name(id='ListOrDict', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Call(func=Name(id='ListOrDict', ctx=Load()), args=[Name(id='aux_operators', ctx=Load())], keywords=[])
Tuple(elts=[Name(id='name_aux', ctx=Store()), Name(id='aux_op', ctx=Store())], ctx=Store())
Call(func=Name(id='iter', ctx=Load()), args=[Name(id='wrapped_aux_operators', ctx=Load())], keywords=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))], orelse=[Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])])
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load())
Name(id='MinimumEigensolverFactory', ctx=Load())
Name(id='vqe', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load()), args=[Name(id='problem', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())], keywords=[])
Name(id='vqe', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load())
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vqe', ctx=Load()), Name(id='VQE', ctx=Load())], keywords=[])
Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the VQE solver')], keywords=[])
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), Name(id='UCC', ctx=Load())], keywords=[])
Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')], keywords=[])
Name(id='self', ctx=Load())
Store()
Name(id='CircuitSampler', ctx=Load())
Attribute(value=Name(id='vqe', ctx=Load()), attr='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Store()
Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load())
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='_build', ctx=Load())
Name(id='self', ctx=Load())
Store()
Attribute(value=Name(id='copy', ctx=Load()), attr='deepcopy', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Load())
Store()
Store()
Store()
Store()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Store()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Store()
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Num(n=0.0)
NameConstant(value=None)
Load()
Store()
Or()
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='iteration', ctx=Load()), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())])
Name(id='iteration', ctx=Store())
Add()
Num(n=1)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='--- Iteration #%s ---'), Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])], keywords=[])
Name(id='cur_grads', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load()), args=[Name(id='theta', ctx=Load()), Name(id='vqe', ctx=Load())], keywords=[])
Tuple(elts=[Name(id='max_grad_index', ctx=Store()), Name(id='max_grad', ctx=Store())], ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])], keywords=[keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))])
Call(func=Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='max_grad_index', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load()), args=[Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())], keywords=[])
Assign(targets=[Name(id='gradlog', ctx=Store())], value=JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)]))
AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>'))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])), If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[]))
Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), ops=[Lt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())])
If(test=Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)], orelse=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='threshold_satisfied', ctx=Store())], value=NameConstant(value=True))
Break()
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load()), args=[Name(id='prev_op_indices', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='alternating_sequence', ctx=Store())], value=NameConstant(value=True))
Break()
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load()), args=[Num(n=0.0)], keywords=[])
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='operators', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Attribute(value=Name(id='vqe', ctx=Load()), attr='initial_point', ctx=Store())
Name(id='theta', ctx=Load())
Name(id='raw_vqe_result', ctx=Store())
Call(func=Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())], keywords=[])
Name(id='theta', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load()), args=[], keywords=[])
Name(id='max_iterations_exceeded', ctx=Store())
NameConstant(value=True)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Maximum number of iterations reached. Finishing.')], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='aux_ops', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='aux_values', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load()), args=[Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load()), Name(id='aux_ops', ctx=Load())], keywords=[])
Name(id='aux_values', ctx=Store())
NameConstant(value=None)
Name(id='raw_vqe_result', ctx=Load())
Store()
Load()
Load()
Name(id='finishing_criterion', ctx=Store())
Str(s='Threshold converged')
Name(id='alternating_sequence', ctx=Load())
Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Aborted due to cyclicity'))
If(test=Name(id='max_iterations_exceeded', ctx=Load()), body=[Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))], orelse=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)])
Store()
Attribute(value=Name(id='problem', ctx=Load()), attr='interpret', ctx=Load())
Name(id='raw_vqe_result', ctx=Load())
Store()
Name(id='AdaptVQEResult', ctx=Load())
Attribute(value=Name(id='result', ctx=Load()), attr='combine', ctx=Load())
Name(id='electronic_result', ctx=Load())
Name(id='result', ctx=Load())
Store()
Load()
Name(id='result', ctx=Load())
Store()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='result', ctx=Load())
Store()
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='The final energy is: %s')
Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Load()
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='str', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='GradientBase', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Store()
Name(id='Gradient', ctx=Load())
keyword(arg='grad_method', value=Str(s='fin_diff'))
keyword(arg='epsilon', value=Name(id='gradient', ctx=Load()))
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Load()
Load()
Name(id='OperatorBase', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='GradientBase', ctx=Load()))
Load()
Load()
Store()
Name(id='Gradient', ctx=Load())
keyword(arg='grad_method', value=Str(s='param_shift'))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())
Add()
List(elts=[Name(id='exc', ctx=Load())], ctx=Load())
Name(id='vqe', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load()), attr='decompose', ctx=Load())
Store()
Name(id='list', ctx=Load())
Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Store()
Name(id='dict', ctx=Load())
Call(func=Name(id='zip', ctx=Load()), args=[Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load()), Name(id='theta', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='vqe', ctx=Load()), attr='construct_expectation', ctx=Load())
Name(id='theta1', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load()), attr='convert', ctx=Load())
keyword(arg='operator', value=Name(id='op', ctx=Load()))
keyword(arg='params', value=Name(id='param_sets', ctx=Load()))
Store()
Subscript(value=Name(id='param_sets', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Num(n=0.0)
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))]), attr='eval', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Gradient computed : %s')
Call(func=Name(id='str', ctx=Load()), args=[Name(id='state_grad_result', ctx=Load())], keywords=[])
Attribute(value=Name(id='res', ctx=Load()), attr='append', ctx=Load())
Tuple(elts=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[]), Name(id='exc', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Name(id='re', ctx=Load())
Load()
Name(id='cycle_regex', ctx=Load())
Load()
Attribute(value=Str(s=' '), attr='join', ctx=Load())
Call(func=Name(id='map', ctx=Load()), args=[Name(id='str', ctx=Load()), Name(id='indices', ctx=Load())], keywords=[])
Name(id='logger', ctx=Load())
Load()
Load()
Name(id='match', ctx=Load())
IsNot()
NameConstant(value=None)
And()
Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Num(n=1)])
Compare(left=Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())])
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Load()
Name(id='problem', ctx=Load())
Load()
Load()
Name(id='SecondQuantizedOp', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='second_q_ops', ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Name(id='second_q_ops', ctx=Load())
Slice(lower=Num(n=1), upper=None, step=None)
Load()
Name(id='isinstance', ctx=Load())
Name(id='second_q_ops', ctx=Load())
Name(id='dict', ctx=Load())
Name(id='name', ctx=Store())
Attribute(value=Name(id='problem', ctx=Load()), attr='main_property_name', ctx=Load())
Name(id='main_second_q_op', ctx=Store())
Call(func=Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load()), args=[Name(id='name', ctx=Load()), NameConstant(value=None)], keywords=[])
Compare(left=Name(id='main_second_q_op', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[]), cause=None)
Name(id='aux_second_q_ops', ctx=Store())
Name(id='second_q_ops', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())
Load()
Load()
Attribute(value=Name(id='problem', ctx=Load()), attr='num_particles', ctx=Load())
Attribute(value=Name(id='problem', ctx=Load()), attr='symmetry_sector_locator', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='ListOrDict', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='ListOrDict', ctx=Load())
Name(id='aux_operators', ctx=Load())
Name(id='name_aux', ctx=Store())
Name(id='aux_op', ctx=Store())
Store()
Name(id='iter', ctx=Load())
Name(id='wrapped_aux_operators', ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), Name(id='SecondQuantizedOp', ctx=Load())], keywords=[])
Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[]))
Assign(targets=[Name(id='converted_aux_op', ctx=Store())], value=Name(id='aux_op', ctx=Load()))
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[]), body=[If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))], orelse=[])
Load()
Name(id='self', ctx=Load())
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load()), attr='get_solver', ctx=Load())
Name(id='problem', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='isinstance', ctx=Load())
Name(id='vqe', ctx=Load())
Name(id='VQE', ctx=Load())
Name(id='QiskitNatureError', ctx=Load())
Str(s='The AdaptVQE algorithm requires the use of the VQE solver')
Name(id='isinstance', ctx=Load())
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())
Name(id='UCC', ctx=Load())
Name(id='QiskitNatureError', ctx=Load())
Str(s='The AdaptVQE algorithm requires the use of the UCC ansatz')
Load()
Load()
Name(id='vqe', ctx=Load())
Load()
Load()
Name(id='copy', ctx=Load())
Load()
Name(id='vqe', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
Name(id='copy', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())
Is()
NameConstant(value=None)
Name(id='iteration', ctx=Load())
Lt()
Attribute(value=Name(id='self', ctx=Load()), attr='_max_iterations', ctx=Load())
Store()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='--- Iteration #%s ---')
Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_compute_gradients', ctx=Load())
Name(id='theta', ctx=Load())
Name(id='vqe', ctx=Load())
Name(id='max_grad_index', ctx=Store())
Name(id='max_grad', ctx=Store())
Store()
Name(id='max', ctx=Load())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])
keyword(arg='key', value=Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])))
Attribute(value=Name(id='prev_op_indices', ctx=Load()), attr='append', ctx=Load())
Name(id='max_grad_index', ctx=Load())
Attribute(value=Name(id='logger', ctx=Load()), attr='isEnabledFor', ctx=Load())
Attribute(value=Name(id='logging', ctx=Load()), attr='INFO', ctx=Load())
Name(id='gradlog', ctx=Store())
JoinedStr(values=[Str(s='\nGradients in iteration #'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])
Name(id='gradlog', ctx=Store())
Add()
Str(s='\nID: Excitation Operator: Gradient  <(*) maximum>')
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='grad', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='cur_grads', ctx=Load())], keywords=[])
AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)]))
If(test=Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))], orelse=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Name(id='gradlog', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Lt()
Attribute(value=Name(id='self', ctx=Load()), attr='_threshold', ctx=Load())
Compare(left=Name(id='iteration', ctx=Load()), ops=[Eq()], comparators=[Num(n=1)])
Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[]), cause=None)
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='threshold_satisfied', ctx=Store())
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='_check_cyclicity', ctx=Load())
Name(id='prev_op_indices', ctx=Load())
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Alternating sequence found. Finishing.')], keywords=[])
Call(func=Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load()), args=[Str(s='Final maximum gradient: %s'), Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='alternating_sequence', ctx=Store())
NameConstant(value=True)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load()), attr='append', ctx=Load())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Attribute(value=Name(id='theta', ctx=Load()), attr='append', ctx=Load())
Num(n=0.0)
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='vqe', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='vqe', ctx=Load())
Store()
Load()
Store()
Attribute(value=Name(id='vqe', ctx=Load()), attr='compute_minimum_eigenvalue', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_main_operator', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load()), attr='tolist', ctx=Load())
Store()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Maximum number of iterations reached. Finishing.')
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Final maximum gradient: %s')
Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='evaluate_operators', ctx=Load())
Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='eigenstate', ctx=Load())
Name(id='aux_ops', ctx=Load())
Store()
Load()
Store()
Load()
Name(id='finishing_criterion', ctx=Store())
Str(s='Aborted due to cyclicity')
Name(id='max_iterations_exceeded', ctx=Load())
Assign(targets=[Name(id='finishing_criterion', ctx=Store())], value=Str(s='Maximum number of iterations reached'))
Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[]), cause=None)
Name(id='problem', ctx=Load())
Load()
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Num(n=0)
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Subscript(value=Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='int', ctx=Load())
Load()
Name(id='GradientBase', ctx=Load())
Load()
Str(s='fin_diff')
Name(id='gradient', ctx=Load())
Name(id='super', ctx=Load())
Load()
Load()
Load()
Name(id='GradientBase', ctx=Load())
Load()
Str(s='param_shift')
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='exc', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_ansatz', ctx=Load())
Load()
Load()
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Name(id='zip', ctx=Load())
Attribute(value=Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load()), attr='parameters', ctx=Load())
Name(id='theta', ctx=Load())
Name(id='vqe', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='gradient', ctx=Load())
Load()
Name(id='op', ctx=Load())
Name(id='param_sets', ctx=Load())
Name(id='param_sets', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='state_grad', ctx=Load())], keywords=[keyword(arg='params', value=Name(id='value_dict', ctx=Load()))])
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Name(id='state_grad_result', ctx=Load())
Name(id='res', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())], keywords=[])
Name(id='exc', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Load()
Str(s=' ')
Load()
Name(id='map', ctx=Load())
Name(id='str', ctx=Load())
Name(id='indices', ctx=Load())
Load()
Load()
Call(func=Name(id='len', ctx=Load()), args=[Name(id='indices', ctx=Load())], keywords=[])
Gt()
Num(n=1)
Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=2))), ctx=Load())
Eq()
Subscript(value=Name(id='indices', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Load()
Subscript(value=Name(id='ListOrDictType', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Load()
Load()
Load()
Num(n=0)
Load()
Num(n=1)
Load()
Load()
Load()
Store()
Name(id='problem', ctx=Load())
Load()
Store()
Attribute(value=Name(id='second_q_ops', ctx=Load()), attr='pop', ctx=Load())
Name(id='name', ctx=Load())
NameConstant(value=None)
Name(id='main_second_q_op', ctx=Load())
Is()
NameConstant(value=None)
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])], keywords=[])
Store()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='problem', ctx=Load())
Load()
Name(id='problem', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Store()
Store()
Load()
Load()
Name(id='isinstance', ctx=Load())
Name(id='aux_op', ctx=Load())
Name(id='SecondQuantizedOp', ctx=Load())
Name(id='converted_aux_op', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load()), args=[Name(id='aux_op', ctx=Load()), NameConstant(value=True)], keywords=[])
Name(id='converted_aux_op', ctx=Store())
Name(id='aux_op', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_ops', ctx=Load())
Name(id='list', ctx=Load())
Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='converted_aux_op', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='aux_ops', ctx=Load()), Name(id='dict', ctx=Load())], keywords=[])
If(test=Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())], value=Name(id='converted_aux_op', ctx=Load()))
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_solver', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='vqe', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='PauliSumOp', ctx=Load())), ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Name(id='iteration', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Store()
Store()
Load()
Name(id='enumerate', ctx=Load())
Name(id='cur_grads', ctx=Load())
Lambda(args=arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Name(id='prev_op_indices', ctx=Load())
Load()
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='logging', ctx=Load())
Load()
Store()
Str(s='\nGradients in iteration #')
FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Store()
Name(id='i', ctx=Store())
Name(id='grad', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='cur_grads', ctx=Load())
Name(id='gradlog', ctx=Store())
Add()
JoinedStr(values=[Str(s='\n'), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s=': '), FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)])
Compare(left=Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), ops=[Eq()], comparators=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())])
AugAssign(target=Name(id='gradlog', ctx=Store()), op=Add(), value=Str(s='\t(*)'))
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Name(id='gradlog', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='iteration', ctx=Load())
Eq()
Num(n=1)
Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')], keywords=[])
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Adaptive VQE terminated successfully with a final maximum gradient: %s')
Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])
Store()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Alternating sequence found. Finishing.')
Attribute(value=Name(id='logger', ctx=Load()), attr='info', ctx=Load())
Str(s='Final maximum gradient: %s')
Call(func=Name(id='str', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_excitation_list', ctx=Load())
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=1))
Load()
Name(id='theta', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='vqe', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='raw_vqe_result', ctx=Load()), attr='optimal_point', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Load()
Name(id='raw_vqe_result', ctx=Load())
Load()
Load()
Store()
Load()
Name(id='finishing_criterion', ctx=Store())
Str(s='Maximum number of iterations reached')
Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[Str(s='The algorithm finished due to an unforeseen reason!')], keywords=[])
Load()
Load()
Load()
Load()
Attribute(value=Name(id='result', ctx=Load()), attr='computed_energies', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='super', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='vqe', ctx=Load())
Load()
Load()
Attribute(value=Name(id='vqe', ctx=Load()), attr='ansatz', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load())
Name(id='state_grad', ctx=Load())
keyword(arg='params', value=Name(id='value_dict', ctx=Load()))
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Name(id='state_grad_result', ctx=Load()), slice=Index(value=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='PauliSumOp', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='len', ctx=Load())
Name(id='indices', ctx=Load())
Name(id='indices', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=2)))
Load()
Name(id='indices', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Name(id='ListOrDictType', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Name(id='second_q_ops', ctx=Load())
Load()
Load()
Load()
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='The main `SecondQuantizedOp` associated with the '), FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None), Str(s=' property cannot be `None`.')])
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load()), attr='convert_match', ctx=Load())
Name(id='aux_op', ctx=Load())
NameConstant(value=True)
Store()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='aux_ops', ctx=Load()), attr='append', ctx=Load())
Name(id='converted_aux_op', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='aux_ops', ctx=Load())
Name(id='dict', ctx=Load())
Compare(left=Name(id='name_aux', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])])
Raise(exc=Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[]), cause=None)
Subscript(value=Name(id='aux_ops', ctx=Load()), slice=Index(value=Name(id='name_aux', ctx=Load())), ctx=Store())
Name(id='converted_aux_op', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='PauliSumOp', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
arguments(args=[arg(arg='item', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Load()
Load()
Load()
Call(func=Name(id='str', ctx=Load()), args=[Name(id='iteration', ctx=Load())], keywords=[])
Store()
Store()
Load()
Load()
Store()
Str(s='\n')
FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Str(s=': ')
FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Str(s=': ')
FormattedValue(value=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Eq()
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Name(id='gradlog', ctx=Store())
Add()
Str(s='\t(*)')
Name(id='logger', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Name(id='QiskitNatureError', ctx=Load())
Str(s='Gradient choice is not suited as it leads to all zero gradients gradients. Try a different gradient method.')
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='logger', ctx=Load())
Load()
Name(id='str', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Load()
Load()
Num(n=1)
Load()
Load()
Load()
Load()
Name(id='raw_vqe_result', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Store()
Name(id='QiskitNatureError', ctx=Load())
Str(s='The algorithm finished due to an unforeseen reason!')
Name(id='result', ctx=Load())
Load()
Num(n=0)
Load()
Load()
Load()
Name(id='vqe', ctx=Load())
Load()
Load()
USub()
Num(n=1)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
Load()
Load()
Name(id='value_dict', ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='state_grad_result', ctx=Load())
Index(value=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Load()
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Str(s='The main `SecondQuantizedOp` associated with the ')
FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1, format_spec=None)
Str(s=' property cannot be `None`.')
Load()
Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_qubit_converter', ctx=Load())
Load()
Load()
Name(id='aux_ops', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='name_aux', ctx=Load())
In()
Call(func=Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])
Call(func=Name(id='QiskitNatureError', ctx=Load()), args=[JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])], keywords=[])
Name(id='aux_ops', ctx=Load())
Index(value=Name(id='name_aux', ctx=Load()))
Store()
Load()
Load()
Load()
Name(id='PauliSumOp', ctx=Load())
arg(arg='item', annotation=None)
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='str', ctx=Load())
Name(id='iteration', ctx=Load())
Call(func=Name(id='str', ctx=Load()), args=[Name(id='i', ctx=Load())], keywords=[])
Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())], keywords=[])
Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='grad', ctx=Load())
Index(value=Num(n=1))
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=1))
Load()
Store()
Load()
Load()
Load()
Num(n=0)
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
Subscript(value=Name(id='max_grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
USub()
Num(n=2)
USub()
Num(n=1)
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load()))
Load()
Name(id='name', ctx=Load())
Name(id='SecondQuantizedOp', ctx=Load())
Name(id='PauliSumOp', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='aux_ops', ctx=Load()), attr='keys', ctx=Load())
Name(id='QiskitNatureError', ctx=Load())
JoinedStr(values=[Str(s="The key '"), FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None), Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")])
Load()
Name(id='name_aux', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Subscript(value=Name(id='item', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Name(id='str', ctx=Load())
Name(id='i', ctx=Load())
Name(id='str', ctx=Load())
Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Name(id='str', ctx=Load())
Subscript(value=Name(id='grad', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Num(n=1)
Load()
Num(n=1)
Name(id='np', ctx=Load())
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='max_grad', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Num(n=0)
Load()
USub()
Num(n=1)
Load()
Tuple(elts=[Name(id='SecondQuantizedOp', ctx=Load()), Name(id='PauliSumOp', ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Name(id='aux_ops', ctx=Load())
Load()
Load()
Str(s="The key '")
FormattedValue(value=Name(id='name_aux', ctx=Load()), conversion=-1, format_spec=None)
Str(s="' is already taken by an internally constructed auxiliary operator! Please use a different name for your custom operator.")
Load()
Load()
Name(id='item', ctx=Load())
Index(value=Num(n=1))
Load()
Num(n=0)
Load()
Load()
Load()
Name(id='grad', ctx=Load())
Index(value=Num(n=1))
Load()
Load()
Name(id='grad', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Num(n=0)
Load()
Load()
Num(n=0)
Name(id='SecondQuantizedOp', ctx=Load())
Name(id='PauliSumOp', ctx=Load())
Load()
Load()
Name(id='name_aux', ctx=Load())
Load()
Num(n=1)
Load()
Num(n=1)
Load()
Num(n=0)
Load()
Load()
Load()
  metric  value
0     NC      0
DONE!
