Python 3.7.8
Module(body=[Expr(value=Str(s='The Iterative Quantum Phase Estimation Algorithm.')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0), Import(names=[alias(name='numpy', asname=None)]), Import(names=[alias(name='qiskit', asname=None)]), ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None)], level=0), ImportFrom(module='qiskit.circuit.classicalregister', names=[alias(name='ClassicalRegister', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimator', asname=None)], level=1), ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimatorResult', asname=None)], level=1), ClassDef(name='IterativePhaseEstimation', bases=[Name(id='PhaseEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Run the Iterative quantum phase estimation (QPE) algorithm.\n\n    Given a unitary circuit and a circuit preparing an eigenstate, return the phase of the\n    eigenvalue as a number in :math:`[0,1)` using the iterative phase estimation algorithm.\n\n    [1]: Dobsicek et al. (2006), Arbitrary accuracy iterative phase estimation algorithm as a two\n       qubit benchmark, `arxiv/quant-ph/0610214 <https://arxiv.org/abs/quant-ph/0610214>`_\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Args:\n          num_iterations: The number of iterations (rounds) of the phase estimation to run.\n          quantum_instance: The quantum instance on which the circuit will be run.\n\n        Raises:\n          ValueError: if num_iterations is not greater than zero.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='omega', annotation=Name(id='float', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the kth iteration Quantum Phase Estimation circuit.\n\n        For details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n            k: the iteration idx.\n            omega: the feedback angle.\n            measurement: Boolean flag to indicate if measurement should\n                    be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the quantum circuit per iteration\n        ')), Assign(targets=[Name(id='k', ctx=Store())], value=IfExp(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), orelse=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='phase_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='a'))])), Assign(targets=[Name(id='eigenstate_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='q'))])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='eigenstate_register', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='phase_register', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='unitary_power', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='unitary_power', ctx=Load()), BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='omega', ctx=Load()), Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_estimate_phase_iteratively', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=None), arg(arg='state_preparation', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Main loop of iterative phase estimation.\n        ')), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=Num(n=0)), For(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Num(n=0), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[]), body=[AugAssign(target=Name(id='omega_coef', ctx=Store()), op=Div(), value=Num(n=2)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))]), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))))], orelse=[]), Return(value=Name(id='omega_coef', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Estimate the eigenphase of the input unitary and initial-state pair.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n\n        Returns:\n            Estimated phase in an IterativePhaseEstimationResult object.\n        ')), Assign(targets=[Name(id='phase', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='IterativePhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Name(id='phase', ctx=Load())], keywords=[]))], decorator_list=[], returns=Str(s='IterativePhaseEstimationResult'))], decorator_list=[]), ClassDef(name='IterativePhaseEstimationResult', bases=[Name(id='PhaseEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Phase Estimation Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='phase', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Args:\n            num_iterations: number of iterations used in the phase estimation.\n            phase: the estimated phase.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Store())], value=Name(id='phase', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='phase', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n        1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\n        eigenvector of the unitary so that the peak of the probability density occurs at the bit\n        string that most closely approximates the true phase.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the number of iterations used in the estimation algorithm.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[])])
Expr(value=Str(s='The Iterative Quantum Phase Estimation Algorithm.'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0)
Import(names=[alias(name='numpy', asname=None)])
Import(names=[alias(name='qiskit', asname=None)])
ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.classicalregister', names=[alias(name='ClassicalRegister', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimator', asname=None)], level=1)
ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimatorResult', asname=None)], level=1)
ClassDef(name='IterativePhaseEstimation', bases=[Name(id='PhaseEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Run the Iterative quantum phase estimation (QPE) algorithm.\n\n    Given a unitary circuit and a circuit preparing an eigenstate, return the phase of the\n    eigenvalue as a number in :math:`[0,1)` using the iterative phase estimation algorithm.\n\n    [1]: Dobsicek et al. (2006), Arbitrary accuracy iterative phase estimation algorithm as a two\n       qubit benchmark, `arxiv/quant-ph/0610214 <https://arxiv.org/abs/quant-ph/0610214>`_\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Args:\n          num_iterations: The number of iterations (rounds) of the phase estimation to run.\n          quantum_instance: The quantum instance on which the circuit will be run.\n\n        Raises:\n          ValueError: if num_iterations is not greater than zero.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='omega', annotation=Name(id='float', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the kth iteration Quantum Phase Estimation circuit.\n\n        For details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n            k: the iteration idx.\n            omega: the feedback angle.\n            measurement: Boolean flag to indicate if measurement should\n                    be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the quantum circuit per iteration\n        ')), Assign(targets=[Name(id='k', ctx=Store())], value=IfExp(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), orelse=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='phase_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='a'))])), Assign(targets=[Name(id='eigenstate_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='q'))])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='eigenstate_register', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='phase_register', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='unitary_power', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='unitary_power', ctx=Load()), BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='omega', ctx=Load()), Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_estimate_phase_iteratively', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=None), arg(arg='state_preparation', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Main loop of iterative phase estimation.\n        ')), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=Num(n=0)), For(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Num(n=0), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[]), body=[AugAssign(target=Name(id='omega_coef', ctx=Store()), op=Div(), value=Num(n=2)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))]), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))))], orelse=[]), Return(value=Name(id='omega_coef', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Estimate the eigenphase of the input unitary and initial-state pair.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n\n        Returns:\n            Estimated phase in an IterativePhaseEstimationResult object.\n        ')), Assign(targets=[Name(id='phase', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='IterativePhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Name(id='phase', ctx=Load())], keywords=[]))], decorator_list=[], returns=Str(s='IterativePhaseEstimationResult'))], decorator_list=[])
ClassDef(name='IterativePhaseEstimationResult', bases=[Name(id='PhaseEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Phase Estimation Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='phase', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Args:\n            num_iterations: number of iterations used in the phase estimation.\n            phase: the estimated phase.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Store())], value=Name(id='phase', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='phase', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n        1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\n        eigenvector of the unitary so that the peak of the probability density occurs at the bit\n        string that most closely approximates the true phase.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the number of iterations used in the estimation algorithm.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[])
Str(s='The Iterative Quantum Phase Estimation Algorithm.')
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='numpy', asname=None)
alias(name='qiskit', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='QuantumRegister', asname=None)
alias(name='ClassicalRegister', asname=None)
alias(name='Backend', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='PhaseEstimator', asname=None)
alias(name='PhaseEstimatorResult', asname=None)
Name(id='PhaseEstimator', ctx=Load())
Expr(value=Str(s='Run the Iterative quantum phase estimation (QPE) algorithm.\n\n    Given a unitary circuit and a circuit preparing an eigenstate, return the phase of the\n    eigenvalue as a number in :math:`[0,1)` using the iterative phase estimation algorithm.\n\n    [1]: Dobsicek et al. (2006), Arbitrary accuracy iterative phase estimation algorithm as a two\n       qubit benchmark, `arxiv/quant-ph/0610214 <https://arxiv.org/abs/quant-ph/0610214>`_\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Args:\n          num_iterations: The number of iterations (rounds) of the phase estimation to run.\n          quantum_instance: The quantum instance on which the circuit will be run.\n\n        Raises:\n          ValueError: if num_iterations is not greater than zero.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='omega', annotation=Name(id='float', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the kth iteration Quantum Phase Estimation circuit.\n\n        For details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n            k: the iteration idx.\n            omega: the feedback angle.\n            measurement: Boolean flag to indicate if measurement should\n                    be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the quantum circuit per iteration\n        ')), Assign(targets=[Name(id='k', ctx=Store())], value=IfExp(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), orelse=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='phase_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='a'))])), Assign(targets=[Name(id='eigenstate_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='q'))])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='eigenstate_register', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='phase_register', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='unitary_power', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='unitary_power', ctx=Load()), BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='omega', ctx=Load()), Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='_estimate_phase_iteratively', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=None), arg(arg='state_preparation', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Main loop of iterative phase estimation.\n        ')), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=Num(n=0)), For(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Num(n=0), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[]), body=[AugAssign(target=Name(id='omega_coef', ctx=Store()), op=Div(), value=Num(n=2)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))]), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))))], orelse=[]), Return(value=Name(id='omega_coef', ctx=Load()))], decorator_list=[], returns=None)
FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Estimate the eigenphase of the input unitary and initial-state pair.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n\n        Returns:\n            Estimated phase in an IterativePhaseEstimationResult object.\n        ')), Assign(targets=[Name(id='phase', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='IterativePhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Name(id='phase', ctx=Load())], keywords=[]))], decorator_list=[], returns=Str(s='IterativePhaseEstimationResult'))
Name(id='PhaseEstimatorResult', ctx=Load())
Expr(value=Str(s='Phase Estimation Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='phase', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Args:\n            num_iterations: number of iterations used in the phase estimation.\n            phase: the estimated phase.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Store())], value=Name(id='phase', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='phase', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n        1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\n        eigenvector of the unitary so that the peak of the probability density occurs at the bit\n        string that most closely approximates the true phase.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the number of iterations used in the estimation algorithm.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
Load()
Str(s='Run the Iterative quantum phase estimation (QPE) algorithm.\n\n    Given a unitary circuit and a circuit preparing an eigenstate, return the phase of the\n    eigenvalue as a number in :math:`[0,1)` using the iterative phase estimation algorithm.\n\n    [1]: Dobsicek et al. (2006), Arbitrary accuracy iterative phase estimation algorithm as a two\n       qubit benchmark, `arxiv/quant-ph/0610214 <https://arxiv.org/abs/quant-ph/0610214>`_\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='Args:\n          num_iterations: The number of iterations (rounds) of the phase estimation to run.\n          quantum_instance: The quantum instance on which the circuit will be run.\n\n        Raises:\n          ValueError: if num_iterations is not greater than zero.\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load()))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='omega', annotation=Name(id='float', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)])
Expr(value=Str(s='Construct the kth iteration Quantum Phase Estimation circuit.\n\n        For details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n            k: the iteration idx.\n            omega: the feedback angle.\n            measurement: Boolean flag to indicate if measurement should\n                    be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the quantum circuit per iteration\n        '))
Assign(targets=[Name(id='k', ctx=Store())], value=IfExp(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), orelse=Name(id='k', ctx=Load())))
Assign(targets=[Name(id='phase_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='a'))]))
Assign(targets=[Name(id='eigenstate_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='q'))]))
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='eigenstate_register', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='phase_register', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[])])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Assign(targets=[Name(id='unitary_power', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='unitary_power', ctx=Load()), BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='omega', ctx=Load()), Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[]))], orelse=[])
Return(value=Name(id='qc', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=None), arg(arg='state_preparation', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Main loop of iterative phase estimation.\n        '))
Assign(targets=[Name(id='omega_coef', ctx=Store())], value=Num(n=0))
For(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Num(n=0), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[]), body=[AugAssign(target=Name(id='omega_coef', ctx=Store()), op=Div(), value=Num(n=2)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))]), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))))], orelse=[])
Return(value=Name(id='omega_coef', ctx=Load()))
arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Estimate the eigenphase of the input unitary and initial-state pair.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n\n        Returns:\n            Estimated phase in an IterativePhaseEstimationResult object.\n        '))
Assign(targets=[Name(id='phase', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[]))
Return(value=Call(func=Name(id='IterativePhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Name(id='phase', ctx=Load())], keywords=[]))
Str(s='IterativePhaseEstimationResult')
Load()
Str(s='Phase Estimation Result.')
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='phase', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Args:\n            num_iterations: number of iterations used in the phase estimation.\n            phase: the estimated phase.\n        '))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Store())], value=Name(id='phase', ctx=Load()))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n        1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\n        eigenvector of the unitary so that the peak of the probability density occurs at the bit\n        string that most closely approximates the true phase.\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the number of iterations used in the estimation algorithm.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='num_iterations', annotation=Name(id='int', ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='Args:\n          num_iterations: The number of iterations (rounds) of the phase estimation to run.\n          quantum_instance: The quantum instance on which the circuit will be run.\n\n        Raises:\n          ValueError: if num_iterations is not greater than zero.\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Compare(left=Name(id='num_iterations', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[]), cause=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())
Name(id='num_iterations', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='k', annotation=Name(id='int', ctx=Load()))
arg(arg='omega', annotation=Name(id='float', ctx=Load()))
arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))
Num(n=0)
NameConstant(value=False)
Str(s='Construct the kth iteration Quantum Phase Estimation circuit.\n\n        For details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n            k: the iteration idx.\n            omega: the feedback angle.\n            measurement: Boolean flag to indicate if measurement should\n                    be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the quantum circuit per iteration\n        ')
Name(id='k', ctx=Store())
IfExp(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), orelse=Name(id='k', ctx=Load()))
Name(id='phase_register', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='a'))])
Name(id='eigenstate_register', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='q'))])
Name(id='qc', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='eigenstate_register', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='phase_register', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='unitary_power', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load()), args=[], keywords=[])
Name(id='qc', ctx=Store())
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='unitary_power', ctx=Load()), BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='omega', ctx=Load()), Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='measurement', ctx=Load())
Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[]))
Name(id='qc', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='unitary', annotation=None)
arg(arg='state_preparation', annotation=None)
Str(s='\n        Main loop of iterative phase estimation.\n        ')
Name(id='omega_coef', ctx=Store())
Num(n=0)
Name(id='k', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Num(n=0), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[])
AugAssign(target=Name(id='omega_coef', ctx=Store()), op=Div(), value=Num(n=2))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))])
Assign(targets=[Name(id='omega_coef', ctx=Store())], value=BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))))
Name(id='omega_coef', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))
Str(s='\n        Estimate the eigenphase of the input unitary and initial-state pair.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n\n        Returns:\n            Estimated phase in an IterativePhaseEstimationResult object.\n        ')
Name(id='phase', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])
Call(func=Name(id='IterativePhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Name(id='phase', ctx=Load())], keywords=[])
arg(arg='self', annotation=None)
arg(arg='num_iterations', annotation=Name(id='int', ctx=Load()))
arg(arg='phase', annotation=Name(id='float', ctx=Load()))
Str(s='\n        Args:\n            num_iterations: number of iterations used in the phase estimation.\n            phase: the estimated phase.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())
Name(id='num_iterations', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Store())
Name(id='phase', ctx=Load())
arg(arg='self', annotation=None)
Str(s='Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n        1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\n        eigenvector of the unitary so that the peak of the probability density occurs at the bit\n        string that most closely approximates the true phase.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
Str(s='Return the number of iterations used in the estimation algorithm.')
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='num_iterations', ctx=Load())
LtE()
Num(n=0)
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load())
Name(id='k', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
Num(n=1)
keyword(arg='name', value=Str(s='a'))
Store()
Name(id='QuantumRegister', ctx=Load())
Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())
keyword(arg='name', value=Str(s='q'))
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='eigenstate_register', ctx=Load())
Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load())
Name(id='phase_register', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='state_preparation', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[])
Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))
Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load())
Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load())
Store()
Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load())
Name(id='unitary_power', ctx=Load())
BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))
Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load())
Name(id='omega', ctx=Load())
Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load())
Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Name(id='c', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[])
Load()
Store()
Store()
Name(id='range', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load())
Num(n=0)
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='omega_coef', ctx=Store())
Div()
Num(n=2)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))]))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))]))
Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))]))
Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))
Name(id='omega_coef', ctx=Store())
BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2)))
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load())
Name(id='unitary', ctx=Load())
Name(id='state_preparation', ctx=Load())
Name(id='IterativePhaseEstimationResult', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load())
Name(id='phase', ctx=Load())
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Name(id='ValueError', ctx=Load())
Str(s='`num_iterations` must be greater than zero.')
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='k', ctx=Load())
Is()
NameConstant(value=None)
Name(id='self', ctx=Load())
Load()
Load()
Load()
Str(s='a')
Load()
Name(id='unitary', ctx=Load())
Load()
Str(s='q')
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Name(id='state_preparation', ctx=Load())
Name(id='eigenstate_register', ctx=Load())
Name(id='state_preparation', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='qc', ctx=Store())
Add()
Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[])
Name(id='qc', ctx=Load())
Load()
Name(id='phase_register', ctx=Load())
Index(value=Num(n=0))
Load()
Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[])
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])
Add()
List(elts=[Num(n=0)], ctx=Load())
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='phase_register', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='qc', ctx=Load())
Load()
Name(id='phase_register', ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Name(id='ClassicalRegister', ctx=Load())
Num(n=1)
keyword(arg='name', value=Str(s='c'))
Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load())
Name(id='c', ctx=Load())
Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load())
Name(id='phase_register', ctx=Load())
Name(id='c', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
USub()
Num(n=1)
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='qc', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])
Name(id='result', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
  Found a method call call at line 124
Name(id='complete_state_vec', ctx=Store())
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Name(id='ancilla_density_mat', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])
Name(id='ancilla_density_mat_diag', ctx=Store())
Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])
Name(id='max_amplitude', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])
Name(id='x', ctx=Store())
Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='qc', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])
Name(id='measurements', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Name(id='x', ctx=Store())
IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0))
Store()
Name(id='omega_coef', ctx=Load())
Add()
BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load())
Str(s='circuit')
Name(id='eigenstate_register', ctx=Load())
Load()
Load()
Num(n=0)
Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load())
BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))
Load()
Name(id='list', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Num(n=0)
Load()
Load()
Load()
Num(n=0)
Load()
Load()
Num(n=0)
Load()
Str(s='c')
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='unitary', ctx=Load())
Name(id='state_preparation', ctx=Load())
Name(id='k', ctx=Load())
BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))
keyword(arg='measurement', value=NameConstant(value=False))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='qc', ctx=Load())
Store()
Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load())
Name(id='qc', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load())
Name(id='complete_state_vec', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load())
Name(id='ancilla_density_mat', ctx=Load())
Store()
Name(id='max', ctx=Load())
Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])
keyword(arg='key', value=Name(id='abs', ctx=Load()))
Store()
Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='unitary', ctx=Load())
Name(id='state_preparation', ctx=Load())
Name(id='k', ctx=Load())
BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))
keyword(arg='measurement', value=NameConstant(value=True))
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load())
Name(id='qc', ctx=Load())
Store()
Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])])
Num(n=1)
Num(n=0)
Load()
Name(id='x', ctx=Load())
Div()
Num(n=2)
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='state_preparation', ctx=Load())
Load()
Load()
Name(id='unitary', ctx=Load())
Load()
Num(n=2)
Pow()
BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1))
Load()
Name(id='range', ctx=Load())
Num(n=1)
BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load()))
Mult()
Name(id='omega_coef', ctx=Load())
NameConstant(value=False)
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load())
Load()
Load()
Name(id='range', ctx=Load())
Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='numpy', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load())
Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load())
Name(id='abs', ctx=Load())
Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[])
Index(value=Num(n=0))
Load()
Num(n=0)
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load()))
Mult()
Name(id='omega_coef', ctx=Load())
NameConstant(value=True)
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
  Found a method call call at line 138
Load()
Load()
Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[])
Gt()
Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='k', ctx=Load())
Sub()
Num(n=1)
Load()
Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())
Add()
Num(n=1)
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Mult()
Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='qiskit', ctx=Load())
Load()
Load()
Name(id='unitary', ctx=Load())
Load()
Load()
Name(id='ancilla_density_mat_diag', ctx=Load())
Load()
Name(id='ancilla_density_mat_diag', ctx=Load())
Load()
Load()
Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load())
Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])
Num(n=0)
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Mult()
Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='qc', ctx=Load())
Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load())
Str(s='1')
Num(n=0)
Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load())
Str(s='0')
Num(n=0)
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Name(id='unitary', ctx=Load())
Load()
USub()
Num(n=2)
Name(id='numpy', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='numpy', ctx=Load())
Load()
Name(id='ancilla_density_mat_diag', ctx=Load())
Eq()
Name(id='max_amplitude', ctx=Load())
USub()
Num(n=2)
Name(id='numpy', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='measurements', ctx=Load())
Load()
Name(id='measurements', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Module(body=[Expr(value=Str(s='The Iterative Quantum Phase Estimation Algorithm.')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0), Import(names=[alias(name='numpy', asname=None)]), Import(names=[alias(name='qiskit', asname=None)]), ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None)], level=0), ImportFrom(module='qiskit.circuit.classicalregister', names=[alias(name='ClassicalRegister', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimator', asname=None)], level=1), ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimatorResult', asname=None)], level=1), ClassDef(name='IterativePhaseEstimation', bases=[Name(id='PhaseEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Run the Iterative quantum phase estimation (QPE) algorithm.\n\n    Given a unitary circuit and a circuit preparing an eigenstate, return the phase of the\n    eigenvalue as a number in :math:`[0,1)` using the iterative phase estimation algorithm.\n\n    [1]: Dobsicek et al. (2006), Arbitrary accuracy iterative phase estimation algorithm as a two\n       qubit benchmark, `arxiv/quant-ph/0610214 <https://arxiv.org/abs/quant-ph/0610214>`_\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Args:\n          num_iterations: The number of iterations (rounds) of the phase estimation to run.\n          quantum_instance: The quantum instance on which the circuit will be run.\n\n        Raises:\n          ValueError: if num_iterations is not greater than zero.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='omega', annotation=Name(id='float', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the kth iteration Quantum Phase Estimation circuit.\n\n        For details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n            k: the iteration idx.\n            omega: the feedback angle.\n            measurement: Boolean flag to indicate if measurement should\n                    be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the quantum circuit per iteration\n        ')), Assign(targets=[Name(id='k', ctx=Store())], value=IfExp(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), orelse=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='phase_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='a'))])), Assign(targets=[Name(id='eigenstate_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='q'))])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='eigenstate_register', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='phase_register', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='unitary_power', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='unitary_power', ctx=Load()), BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='omega', ctx=Load()), Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_estimate_phase_iteratively', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=None), arg(arg='state_preparation', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Main loop of iterative phase estimation.\n        ')), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=Num(n=0)), For(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Num(n=0), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[]), body=[AugAssign(target=Name(id='omega_coef', ctx=Store()), op=Div(), value=Num(n=2)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))]), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))))], orelse=[]), Return(value=Name(id='omega_coef', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Estimate the eigenphase of the input unitary and initial-state pair.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n\n        Returns:\n            Estimated phase in an IterativePhaseEstimationResult object.\n        ')), Assign(targets=[Name(id='phase', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='IterativePhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Name(id='phase', ctx=Load())], keywords=[]))], decorator_list=[], returns=Str(s='IterativePhaseEstimationResult'))], decorator_list=[]), ClassDef(name='IterativePhaseEstimationResult', bases=[Name(id='PhaseEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Phase Estimation Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='phase', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Args:\n            num_iterations: number of iterations used in the phase estimation.\n            phase: the estimated phase.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Store())], value=Name(id='phase', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='phase', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n        1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\n        eigenvector of the unitary so that the peak of the probability density occurs at the bit\n        string that most closely approximates the true phase.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the number of iterations used in the estimation algorithm.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[])])
Expr(value=Str(s='The Iterative Quantum Phase Estimation Algorithm.'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0)
Import(names=[alias(name='numpy', asname=None)])
Import(names=[alias(name='qiskit', asname=None)])
ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.classicalregister', names=[alias(name='ClassicalRegister', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimator', asname=None)], level=1)
ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimatorResult', asname=None)], level=1)
ClassDef(name='IterativePhaseEstimation', bases=[Name(id='PhaseEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Run the Iterative quantum phase estimation (QPE) algorithm.\n\n    Given a unitary circuit and a circuit preparing an eigenstate, return the phase of the\n    eigenvalue as a number in :math:`[0,1)` using the iterative phase estimation algorithm.\n\n    [1]: Dobsicek et al. (2006), Arbitrary accuracy iterative phase estimation algorithm as a two\n       qubit benchmark, `arxiv/quant-ph/0610214 <https://arxiv.org/abs/quant-ph/0610214>`_\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Args:\n          num_iterations: The number of iterations (rounds) of the phase estimation to run.\n          quantum_instance: The quantum instance on which the circuit will be run.\n\n        Raises:\n          ValueError: if num_iterations is not greater than zero.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='omega', annotation=Name(id='float', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the kth iteration Quantum Phase Estimation circuit.\n\n        For details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n            k: the iteration idx.\n            omega: the feedback angle.\n            measurement: Boolean flag to indicate if measurement should\n                    be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the quantum circuit per iteration\n        ')), Assign(targets=[Name(id='k', ctx=Store())], value=IfExp(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), orelse=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='phase_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='a'))])), Assign(targets=[Name(id='eigenstate_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='q'))])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='eigenstate_register', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='phase_register', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='unitary_power', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='unitary_power', ctx=Load()), BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='omega', ctx=Load()), Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_estimate_phase_iteratively', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=None), arg(arg='state_preparation', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Main loop of iterative phase estimation.\n        ')), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=Num(n=0)), For(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Num(n=0), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[]), body=[AugAssign(target=Name(id='omega_coef', ctx=Store()), op=Div(), value=Num(n=2)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))]), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))))], orelse=[]), Return(value=Name(id='omega_coef', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Estimate the eigenphase of the input unitary and initial-state pair.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n\n        Returns:\n            Estimated phase in an IterativePhaseEstimationResult object.\n        ')), Assign(targets=[Name(id='phase', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='IterativePhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Name(id='phase', ctx=Load())], keywords=[]))], decorator_list=[], returns=Str(s='IterativePhaseEstimationResult'))], decorator_list=[])
ClassDef(name='IterativePhaseEstimationResult', bases=[Name(id='PhaseEstimatorResult', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Phase Estimation Result.')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='phase', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Args:\n            num_iterations: number of iterations used in the phase estimation.\n            phase: the estimated phase.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Store())], value=Name(id='phase', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='phase', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n        1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\n        eigenvector of the unitary so that the peak of the probability density occurs at the bit\n        string that most closely approximates the true phase.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the number of iterations used in the estimation algorithm.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))], decorator_list=[])
Str(s='The Iterative Quantum Phase Estimation Algorithm.')
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='numpy', asname=None)
alias(name='qiskit', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='QuantumRegister', asname=None)
alias(name='ClassicalRegister', asname=None)
alias(name='Backend', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='PhaseEstimator', asname=None)
alias(name='PhaseEstimatorResult', asname=None)
Name(id='PhaseEstimator', ctx=Load())
Expr(value=Str(s='Run the Iterative quantum phase estimation (QPE) algorithm.\n\n    Given a unitary circuit and a circuit preparing an eigenstate, return the phase of the\n    eigenvalue as a number in :math:`[0,1)` using the iterative phase estimation algorithm.\n\n    [1]: Dobsicek et al. (2006), Arbitrary accuracy iterative phase estimation algorithm as a two\n       qubit benchmark, `arxiv/quant-ph/0610214 <https://arxiv.org/abs/quant-ph/0610214>`_\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Args:\n          num_iterations: The number of iterations (rounds) of the phase estimation to run.\n          quantum_instance: The quantum instance on which the circuit will be run.\n\n        Raises:\n          ValueError: if num_iterations is not greater than zero.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='omega', annotation=Name(id='float', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)]), body=[Expr(value=Str(s='Construct the kth iteration Quantum Phase Estimation circuit.\n\n        For details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n            k: the iteration idx.\n            omega: the feedback angle.\n            measurement: Boolean flag to indicate if measurement should\n                    be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the quantum circuit per iteration\n        ')), Assign(targets=[Name(id='k', ctx=Store())], value=IfExp(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), orelse=Name(id='k', ctx=Load()))), Assign(targets=[Name(id='phase_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='a'))])), Assign(targets=[Name(id='eigenstate_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='q'))])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='eigenstate_register', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='phase_register', ctx=Load())], keywords=[])), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[])]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Assign(targets=[Name(id='unitary_power', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='unitary_power', ctx=Load()), BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='omega', ctx=Load()), Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])), If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='_estimate_phase_iteratively', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=None), arg(arg='state_preparation', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Main loop of iterative phase estimation.\n        ')), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=Num(n=0)), For(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Num(n=0), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[]), body=[AugAssign(target=Name(id='omega_coef', ctx=Store()), op=Div(), value=Num(n=2)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))]), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))))], orelse=[]), Return(value=Name(id='omega_coef', ctx=Load()))], decorator_list=[], returns=None)
FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Estimate the eigenphase of the input unitary and initial-state pair.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n\n        Returns:\n            Estimated phase in an IterativePhaseEstimationResult object.\n        ')), Assign(targets=[Name(id='phase', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='IterativePhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Name(id='phase', ctx=Load())], keywords=[]))], decorator_list=[], returns=Str(s='IterativePhaseEstimationResult'))
Name(id='PhaseEstimatorResult', ctx=Load())
Expr(value=Str(s='Phase Estimation Result.'))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='phase', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='\n        Args:\n            num_iterations: number of iterations used in the phase estimation.\n            phase: the estimated phase.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Store())], value=Name(id='phase', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='phase', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n        1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\n        eigenvector of the unitary so that the peak of the probability density occurs at the bit\n        string that most closely approximates the true phase.\n        ')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='num_iterations', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Return the number of iterations used in the estimation algorithm.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='int', ctx=Load()))
Load()
Str(s='Run the Iterative quantum phase estimation (QPE) algorithm.\n\n    Given a unitary circuit and a circuit preparing an eigenstate, return the phase of the\n    eigenvalue as a number in :math:`[0,1)` using the iterative phase estimation algorithm.\n\n    [1]: Dobsicek et al. (2006), Arbitrary accuracy iterative phase estimation algorithm as a two\n       qubit benchmark, `arxiv/quant-ph/0610214 <https://arxiv.org/abs/quant-ph/0610214>`_\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='Args:\n          num_iterations: The number of iterations (rounds) of the phase estimation to run.\n          quantum_instance: The quantum instance on which the circuit will be run.\n\n        Raises:\n          ValueError: if num_iterations is not greater than zero.\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
If(test=Compare(left=Name(id='num_iterations', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load()))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='k', annotation=Name(id='int', ctx=Load())), arg(arg='omega', annotation=Name(id='float', ctx=Load())), arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0), NameConstant(value=False)])
Expr(value=Str(s='Construct the kth iteration Quantum Phase Estimation circuit.\n\n        For details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n            k: the iteration idx.\n            omega: the feedback angle.\n            measurement: Boolean flag to indicate if measurement should\n                    be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the quantum circuit per iteration\n        '))
Assign(targets=[Name(id='k', ctx=Store())], value=IfExp(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), orelse=Name(id='k', ctx=Load())))
Assign(targets=[Name(id='phase_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='a'))]))
Assign(targets=[Name(id='eigenstate_register', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='q'))]))
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='eigenstate_register', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='phase_register', ctx=Load())], keywords=[]))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[])])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Assign(targets=[Name(id='unitary_power', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='unitary_power', ctx=Load()), BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='omega', ctx=Load()), Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
If(test=Name(id='measurement', ctx=Load()), body=[Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[]))], orelse=[])
Return(value=Name(id='qc', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=None), arg(arg='state_preparation', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Main loop of iterative phase estimation.\n        '))
Assign(targets=[Name(id='omega_coef', ctx=Store())], value=Num(n=0))
For(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Num(n=0), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[]), body=[AugAssign(target=Name(id='omega_coef', ctx=Store()), op=Div(), value=Num(n=2)), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))]), Assign(targets=[Name(id='omega_coef', ctx=Store())], value=BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))))], orelse=[])
Return(value=Name(id='omega_coef', ctx=Load()))
arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Estimate the eigenphase of the input unitary and initial-state pair.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n\n        Returns:\n            Estimated phase in an IterativePhaseEstimationResult object.\n        '))
Assign(targets=[Name(id='phase', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[]))
Return(value=Call(func=Name(id='IterativePhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Name(id='phase', ctx=Load())], keywords=[]))
Str(s='IterativePhaseEstimationResult')
Load()
Str(s='Phase Estimation Result.')
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_iterations', annotation=Name(id='int', ctx=Load())), arg(arg='phase', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='\n        Args:\n            num_iterations: number of iterations used in the phase estimation.\n            phase: the estimated phase.\n        '))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())], value=Name(id='num_iterations', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Store())], value=Name(id='phase', ctx=Load()))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n        1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\n        eigenvector of the unitary so that the peak of the probability density occurs at the bit\n        string that most closely approximates the true phase.\n        '))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Return the number of iterations used in the estimation algorithm.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='int', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='num_iterations', annotation=Name(id='int', ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='Args:\n          num_iterations: The number of iterations (rounds) of the phase estimation to run.\n          quantum_instance: The quantum instance on which the circuit will be run.\n\n        Raises:\n          ValueError: if num_iterations is not greater than zero.\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Compare(left=Name(id='num_iterations', ctx=Load()), ops=[LtE()], comparators=[Num(n=0)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[]), cause=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())
Name(id='num_iterations', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='k', annotation=Name(id='int', ctx=Load()))
arg(arg='omega', annotation=Name(id='float', ctx=Load()))
arg(arg='measurement', annotation=Name(id='bool', ctx=Load()))
Num(n=0)
NameConstant(value=False)
Str(s='Construct the kth iteration Quantum Phase Estimation circuit.\n\n        For details of parameters, see Fig. 2 in https://arxiv.org/pdf/quant-ph/0610214.pdf.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n            k: the iteration idx.\n            omega: the feedback angle.\n            measurement: Boolean flag to indicate if measurement should\n                    be included in the circuit.\n\n        Returns:\n            QuantumCircuit: the quantum circuit per iteration\n        ')
Name(id='k', ctx=Store())
IfExp(test=Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), orelse=Name(id='k', ctx=Load()))
Name(id='phase_register', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='a'))])
Name(id='eigenstate_register', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[keyword(arg='name', value=Str(s='q'))])
Name(id='qc', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='eigenstate_register', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='phase_register', ctx=Load())], keywords=[])
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))], orelse=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='unitary_power', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load()), args=[], keywords=[])
Name(id='qc', ctx=Store())
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='unitary_power', ctx=Load()), BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load()), args=[Name(id='omega', ctx=Load()), Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load()), args=[Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Name(id='measurement', ctx=Load())
Assign(targets=[Name(id='c', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[]))
Name(id='qc', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='unitary', annotation=None)
arg(arg='state_preparation', annotation=None)
Str(s='\n        Main loop of iterative phase estimation.\n        ')
Name(id='omega_coef', ctx=Store())
Num(n=0)
Name(id='k', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Num(n=0), UnaryOp(op=USub(), operand=Num(n=1))], keywords=[])
AugAssign(target=Name(id='omega_coef', ctx=Store()), op=Div(), value=Num(n=2))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])), Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])), Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))])
Assign(targets=[Name(id='omega_coef', ctx=Store())], value=BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))))
Name(id='omega_coef', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='state_preparation', annotation=Name(id='QuantumCircuit', ctx=Load()))
Str(s='\n        Estimate the eigenphase of the input unitary and initial-state pair.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalue (via phase)\n                     will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                     measured.  If this parameter is omitted, no preparation circuit\n                     will be run and input state will be the all-zero state in the\n                     computational basis.\n\n        Returns:\n            Estimated phase in an IterativePhaseEstimationResult object.\n        ')
Name(id='phase', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])
Call(func=Name(id='IterativePhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load()), Name(id='phase', ctx=Load())], keywords=[])
arg(arg='self', annotation=None)
arg(arg='num_iterations', annotation=Name(id='int', ctx=Load()))
arg(arg='phase', annotation=Name(id='float', ctx=Load()))
Str(s='\n        Args:\n            num_iterations: number of iterations used in the phase estimation.\n            phase: the estimated phase.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Store())
Name(id='num_iterations', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Store())
Name(id='phase', ctx=Load())
arg(arg='self', annotation=None)
Str(s='Return the estimated phase as a number in :math:`[0.0, 1.0)`.\n\n        1.0 corresponds to a phase of :math:`2\\pi`. It is assumed that the input vector is an\n        eigenvector of the unitary so that the peak of the probability density occurs at the bit\n        string that most closely approximates the true phase.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_phase', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
Str(s='Return the number of iterations used in the estimation algorithm.')
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load())
Load()
Load()
Name(id='int', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='num_iterations', ctx=Load())
LtE()
Num(n=0)
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='`num_iterations` must be greater than zero.')], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Name(id='bool', ctx=Load())
Store()
Compare(left=Name(id='k', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load())
Name(id='k', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
Num(n=1)
keyword(arg='name', value=Str(s='a'))
Store()
Name(id='QuantumRegister', ctx=Load())
Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())
keyword(arg='name', value=Str(s='q'))
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='eigenstate_register', ctx=Load())
Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load())
Name(id='phase_register', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='state_preparation', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='state_preparation', ctx=Load()), Name(id='eigenstate_register', ctx=Load())], keywords=[])
Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
AugAssign(target=Name(id='qc', ctx=Store()), op=Add(), value=Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[]))
Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load())
Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Store()
Attribute(value=Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[]), attr='control', ctx=Load())
Store()
Attribute(value=Name(id='qc', ctx=Load()), attr='compose', ctx=Load())
Name(id='unitary_power', ctx=Load())
BinOp(left=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[]), op=Add(), right=List(elts=[Num(n=0)], ctx=Load()))
Attribute(value=Name(id='qc', ctx=Load()), attr='p', ctx=Load())
Name(id='omega', ctx=Load())
Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='qc', ctx=Load()), attr='h', ctx=Load())
Subscript(value=Name(id='phase_register', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Name(id='c', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Num(n=1)], keywords=[keyword(arg='name', value=Str(s='c'))])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='c', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load()), args=[Name(id='phase_register', ctx=Load()), Name(id='c', ctx=Load())], keywords=[])
Load()
Store()
Store()
Name(id='range', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load())
Num(n=0)
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='omega_coef', ctx=Store())
Div()
Num(n=2)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))]))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='complete_state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='ancilla_density_mat', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Name(id='ancilla_density_mat_diag', ctx=Store())], value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='max_amplitude', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))]))
Assign(targets=[Name(id='x', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))]))
Assign(targets=[Name(id='measurements', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='x', ctx=Store())], value=IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0)))
Name(id='omega_coef', ctx=Store())
BinOp(left=Name(id='omega_coef', ctx=Load()), op=Add(), right=BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2)))
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_estimate_phase_iteratively', ctx=Load())
Name(id='unitary', ctx=Load())
Name(id='state_preparation', ctx=Load())
Name(id='IterativePhaseEstimationResult', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_iterations', ctx=Load())
Name(id='phase', ctx=Load())
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Name(id='ValueError', ctx=Load())
Str(s='`num_iterations` must be greater than zero.')
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='k', ctx=Load())
Is()
NameConstant(value=None)
Name(id='self', ctx=Load())
Load()
Load()
Load()
Str(s='a')
Load()
Name(id='unitary', ctx=Load())
Load()
Str(s='q')
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Name(id='state_preparation', ctx=Load())
Name(id='eigenstate_register', ctx=Load())
Name(id='state_preparation', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='qc', ctx=Store())
Add()
Call(func=Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Str(s='circuit'), Name(id='eigenstate_register', ctx=Load())], keywords=[])
Name(id='qc', ctx=Load())
Load()
Name(id='phase_register', ctx=Load())
Index(value=Num(n=0))
Load()
Call(func=Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load()), args=[BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))], keywords=[])
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])
Add()
List(elts=[Num(n=0)], ctx=Load())
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='phase_register', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='qc', ctx=Load())
Load()
Name(id='phase_register', ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Name(id='ClassicalRegister', ctx=Load())
Num(n=1)
keyword(arg='name', value=Str(s='c'))
Attribute(value=Name(id='qc', ctx=Load()), attr='add_register', ctx=Load())
Name(id='c', ctx=Load())
Attribute(value=Name(id='qc', ctx=Load()), attr='measure', ctx=Load())
Name(id='phase_register', ctx=Load())
Name(id='c', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
USub()
Num(n=1)
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='qc', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=False))])
Name(id='result', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Name(id='complete_state_vec', ctx=Store())
Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Name(id='ancilla_density_mat', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='complete_state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])], keywords=[])
Name(id='ancilla_density_mat_diag', ctx=Store())
Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load()), args=[Name(id='ancilla_density_mat', ctx=Load())], keywords=[])
Name(id='max_amplitude', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[]), Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='key', value=Name(id='abs', ctx=Load()))])
Name(id='x', ctx=Store())
Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='qc', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load()), Name(id='k', ctx=Load()), BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))], keywords=[keyword(arg='measurement', value=NameConstant(value=True))])
Name(id='measurements', ctx=Store())
Call(func=Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Name(id='x', ctx=Store())
IfExp(test=Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])]), body=Num(n=1), orelse=Num(n=0))
Store()
Name(id='omega_coef', ctx=Load())
Add()
BinOp(left=Name(id='x', ctx=Load()), op=Div(), right=Num(n=2))
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Attribute(value=Name(id='state_preparation', ctx=Load()), attr='construct_circuit', ctx=Load())
Str(s='circuit')
Name(id='eigenstate_register', ctx=Load())
Load()
Load()
Num(n=0)
Attribute(value=Name(id='unitary', ctx=Load()), attr='power', ctx=Load())
BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1)))
Load()
Name(id='list', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Num(n=1), BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Num(n=0)
Load()
Load()
Load()
Num(n=0)
Load()
Load()
Num(n=0)
Load()
Str(s='c')
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='unitary', ctx=Load())
Name(id='state_preparation', ctx=Load())
Name(id='k', ctx=Load())
BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))
keyword(arg='measurement', value=NameConstant(value=False))
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='qc', ctx=Load())
Store()
Attribute(value=Name(id='result', ctx=Load()), attr='get_statevector', ctx=Load())
Name(id='qc', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load())
Name(id='complete_state_vec', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='numpy', ctx=Load()), attr='diag', ctx=Load())
Name(id='ancilla_density_mat', ctx=Load())
Store()
Name(id='max', ctx=Load())
Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load()), args=[], keywords=[])
keyword(arg='key', value=Name(id='abs', ctx=Load()))
Store()
Subscript(value=Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[]), slice=Index(value=Num(n=0)), ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='unitary', ctx=Load())
Name(id='state_preparation', ctx=Load())
Name(id='k', ctx=Load())
BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='omega_coef', ctx=Load()))
keyword(arg='measurement', value=NameConstant(value=True))
Store()
Attribute(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]), attr='get_counts', ctx=Load())
Name(id='qc', ctx=Load())
Store()
Compare(left=Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[]), ops=[Gt()], comparators=[Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])])
Num(n=1)
Num(n=0)
Load()
Name(id='x', ctx=Load())
Div()
Num(n=2)
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='state_preparation', ctx=Load())
Load()
Load()
Name(id='unitary', ctx=Load())
Load()
Num(n=2)
Pow()
BinOp(left=Name(id='k', ctx=Load()), op=Sub(), right=Num(n=1))
Load()
Name(id='range', ctx=Load())
Num(n=1)
BinOp(left=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()), op=Add(), right=Num(n=1))
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load()))
Mult()
Name(id='omega_coef', ctx=Load())
NameConstant(value=False)
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='result', ctx=Load())
Load()
Load()
Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load())
Load()
Load()
Name(id='range', ctx=Load())
Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='numpy', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='min', ctx=Load())
Attribute(value=Name(id='ancilla_density_mat_diag', ctx=Load()), attr='max', ctx=Load())
Name(id='abs', ctx=Load())
Call(func=Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load()), args=[Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])], keywords=[])
Index(value=Num(n=0))
Load()
Num(n=0)
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
BinOp(left=UnaryOp(op=USub(), operand=Num(n=2)), op=Mult(), right=Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load()))
Mult()
Name(id='omega_coef', ctx=Load())
NameConstant(value=True)
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Load()
Load()
Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='1'), Num(n=0)], keywords=[])
Gt()
Call(func=Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load()), args=[Str(s='0'), Num(n=0)], keywords=[])
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='k', ctx=Load())
Sub()
Num(n=1)
Load()
Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())
Add()
Num(n=1)
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Mult()
Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='qiskit', ctx=Load())
Load()
Load()
Name(id='unitary', ctx=Load())
Load()
Load()
Name(id='ancilla_density_mat_diag', ctx=Load())
Load()
Name(id='ancilla_density_mat_diag', ctx=Load())
Load()
Load()
Attribute(value=Name(id='numpy', ctx=Load()), attr='where', ctx=Load())
Compare(left=Name(id='ancilla_density_mat_diag', ctx=Load()), ops=[Eq()], comparators=[Name(id='max_amplitude', ctx=Load())])
Num(n=0)
Load()
UnaryOp(op=USub(), operand=Num(n=2))
Mult()
Attribute(value=Name(id='numpy', ctx=Load()), attr='pi', ctx=Load())
Load()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='qc', ctx=Load())
Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load())
Str(s='1')
Num(n=0)
Attribute(value=Name(id='measurements', ctx=Load()), attr='get', ctx=Load())
Str(s='0')
Num(n=0)
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Name(id='unitary', ctx=Load())
Load()
USub()
Num(n=2)
Name(id='numpy', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='numpy', ctx=Load())
Load()
Name(id='ancilla_density_mat_diag', ctx=Load())
Eq()
Name(id='max_amplitude', ctx=Load())
USub()
Num(n=2)
Name(id='numpy', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='measurements', ctx=Load())
Load()
Name(id='measurements', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
  metric  value
0     NC      4
DONE!
