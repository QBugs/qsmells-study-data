Python 3.7.8
Module(body=[Expr(value=Str(s='The HHL algorithm.')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Callable', asname=None), alias(name='Tuple', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None), alias(name='AncillaRegister', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library', names=[alias(name='PhaseEstimation', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library.arithmetic.piecewise_chebyshev', names=[alias(name='PiecewiseChebyshev', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library.arithmetic.exact_reciprocal', names=[alias(name='ExactReciprocal', asname=None)], level=0), ImportFrom(module='qiskit.opflow', names=[alias(name='Z', asname=None), alias(name='I', asname=None), alias(name='StateFn', asname=None), alias(name='TensoredOp', asname=None), alias(name='ExpectationBase', asname=None), alias(name='CircuitSampler', asname=None), alias(name='ListOp', asname=None), alias(name='ExpectationFactory', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.quantum_info.operators.base_operator', names=[alias(name='BaseOperator', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='linear_solver', names=[alias(name='LinearSolver', asname=None), alias(name='LinearSolverResult', asname=None)], level=1), ImportFrom(module='matrices.numpy_matrix', names=[alias(name='NumPyMatrix', asname=None)], level=1), ImportFrom(module='observables.linear_system_observable', names=[alias(name='LinearSystemObservable', asname=None)], level=1), ClassDef(name='HHL', bases=[Name(id='LinearSolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Systems of linear equations arise naturally in many real-life applications in a wide range\n    of areas, such as in the solution of Partial Differential Equations, the calibration of\n    financial models, fluid simulation or numerical field calculation. The problem can be defined\n    as, given a matrix :math:`A\\in\\mathbb{C}^{N\\times N}` and a vector\n    :math:`\\vec{b}\\in\\mathbb{C}^{N}`, find :math:`\\vec{x}\\in\\mathbb{C}^{N}` satisfying\n    :math:`A\\vec{x}=\\vec{b}`.\n\n    A system of linear equations is called :math:`s`-sparse if :math:`A` has at most :math:`s`\n    non-zero entries per row or column. Solving an :math:`s`-sparse system of size :math:`N` with\n    a classical computer requires :math:`\\mathcal{ O }(Ns\\kappa\\log(1/\\epsilon))` running time\n    using the conjugate gradient method. Here :math:`\\kappa` denotes the condition number of the\n    system and :math:`\\epsilon` the accuracy of the approximation.\n\n    The HHL is a quantum algorithm to estimate a function of the solution with running time\n    complexity of :math:`\\mathcal{ O }(\\log(N)s^{2}\\kappa^{2}/\\epsilon)` when\n    :math:`A` is a Hermitian matrix under the assumptions of efficient oracles for loading the\n    data, Hamiltonian simulation and computing a function of the solution. This is an exponential\n    speed up in the size of the system, however one crucial remark to keep in mind is that the\n    classical algorithm returns the full solution, while the HHL can only approximate functions of\n    the solution vector.\n\n    Examples:\n\n        .. jupyter-execute::\n\n            import numpy as np\n            from qiskit import QuantumCircuit\n            from qiskit.algorithms.linear_solvers.hhl import HHL\n            from qiskit.algorithms.linear_solvers.matrices import TridiagonalToeplitz\n            from qiskit.algorithms.linear_solvers.observables import MatrixFunctional\n\n            matrix = TridiagonalToeplitz(2, 1, 1 / 3, trotter_steps=2)\n            right_hand_side = [1.0, -2.1, 3.2, -4.3]\n            observable = MatrixFunctional(1, 1 / 2)\n            rhs = right_hand_side / np.linalg.norm(right_hand_side)\n\n            # Initial state circuit\n            num_qubits = matrix.num_state_qubits\n            qc = QuantumCircuit(num_qubits)\n            qc.isometry(rhs, list(range(num_qubits)), None)\n\n            hhl = HHL()\n            solution = hhl.solve(matrix, qc, observable)\n            approx_result = solution.observable\n\n    References:\n\n        [1]: Harrow, A. W., Hassidim, A., Lloyd, S. (2009).\n        Quantum algorithm for linear systems of equations.\n        `Phys. Rev. Lett. 103, 15 (2009), 1â€“15. <https://doi.org/10.1103/PhysRevLett.103.150502>`_\n\n        [2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2020).\n        Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n        `arXiv:2009.04484 <http://arxiv.org/abs/2009.04484>`_\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.01), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            epsilon: Error tolerance of the approximation to the solution, i.e. if :math:`x` is the\n                exact solution and :math:`\\tilde{x}` the one calculated by the algorithm, then\n                :math:`||x - \\tilde{x}|| \\le epsilon`.\n            expectation: The expectation converter applied to the expectation values before\n                evaluation. If None then PauliExpectation is used.\n            quantum_instance: Quantum Instance or Backend. If None, a Statevector calculation is\n                done.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_s', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=6))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Store())], value=NameConstant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Num(n=1))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=NameConstant(value=None), orelse=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n                If None, a Statevector calculation is done.\n        ')), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))])], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The scaling of the solution vector.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='scaling', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the new scaling of the solution vector.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=Name(id='scaling', ctx=Load()))], decorator_list=[Attribute(value=Name(id='scaling', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ExpectationBase', ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the expectation value algorithm.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_get_delta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n_l', annotation=Name(id='int', ctx=Load())), arg(arg='lambda_min', annotation=Name(id='float', ctx=Load())), arg(arg='lambda_max', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the scaling factor to represent exactly lambda_min on nl binary digits.\n\n        Args:\n            n_l: The number of qubits to represent the eigenvalues.\n            lambda_min: the smallest eigenvalue.\n            lambda_max: the largest eigenvalue.\n\n        Returns:\n            The value of the scaling factor.\n        ')), Assign(targets=[Name(id='formatstr', ctx=Store())], value=BinOp(left=BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])), op=Add(), right=Str(s='b'))), Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), ops=[Lt()], comparators=[Num(n=1e-07)]), body=[Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Num(n=1))], orelse=[]), Assign(targets=[Name(id='binstr', ctx=Store())], value=Subscript(value=Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())), Assign(targets=[Name(id='lamb_min_rep', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='char', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='binstr', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='lamb_min_rep', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))))], orelse=[]), Return(value=Name(id='lamb_min_rep', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='_calculate_norm', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qc', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the value of the euclidean norm of the solution.\n\n        Args:\n            qc: The quantum circuit preparing the solution x to the system.\n\n        Returns:\n            The value of the euclidean norm of the solution.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='qc', ctx=Load()), attr='num_ancillas', ctx=Load())), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))), Assign(targets=[Name(id='norm_2', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='_calculate_observable', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='solution', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Calculates the value of the observable(s) given.\n\n        Args:\n            solution: The quantum circuit preparing the solution x to the system.\n            observable: Information to be extracted from the solution.\n            observable_circuit: Circuit to be applied to the solution to extract information.\n            post_processing: Function to compute the value of the observable.\n\n        Returns:\n            The value of the observable(s) and the circuit results before post-processing as a\n             tuple.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='solution', ctx=Load()), attr='num_ancillas', ctx=Load())), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='post_processing', ctx=Store())], value=Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))]), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=True)), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='observable', ctx=Store())], value=List(elts=[Name(id='observable', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='expectations', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='circ', ctx=Store()), Name(id='obs', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='observable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ob', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='expectation_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='post_processing', ctx=Load()), args=[Name(id='expectation_results', ctx=Load()), Name(id='nb', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='result', ctx=Load()), Name(id='expectation_results', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='neg_vals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=True)]), body=[Expr(value=Str(s='Construct the HHL circuit.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            neg_vals: States whether the matrix has negative eigenvalues. If False the\n            computation becomes cheaper.\n\n        Returns:\n            The HHL circuit.\n\n        Raises:\n            ValueError: If the input is not in the correct format.\n            ValueError: If the type of the input matrix is not supported.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Name(id='vector', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='nf', ctx=Store())], value=Num(n=1)), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Name(id='matrix', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='tolerance')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load()))], orelse=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Num(n=1))]), Assign(targets=[Name(id='nl', ctx=Store())], value=BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[]), op=Add(), right=Name(id='neg_vals', ctx=Load()))), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='delta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load())))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Name(id='lambda_min', ctx=Load()))], orelse=[Assign(targets=[Name(id='delta', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))])), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))], orelse=[Assign(targets=[Name(id='num_values', ctx=Store())], value=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))), Assign(targets=[Name(id='constant', ctx=Store())], value=Name(id='delta', ctx=Load())), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[]))), Assign(targets=[Name(id='degree', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='num_intervals', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[])), Assign(targets=[Name(id='breakpoints', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[])), Assign(targets=[Name(id='na', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='qb', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ql', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nl', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qa', ctx=Store())], value=Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='qf', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nf', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector_circuit', ctx=Load()), Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])), Assign(targets=[Name(id='phase_estimation', ctx=Store())], value=Call(func=Name(id='PhaseEstimation', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='matrix_circuit', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))]), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Tries to solve the given linear system of equations.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            observable: Optional information to be extracted from the solution.\n                Default is the probability of success of the algorithm.\n            observable_circuit: Optional circuit to be applied to the solution to extract\n                information. Default is `None`.\n            post_processing: Optional function to compute the value of the observable.\n                Default is the raw value of measuring the observable.\n\n        Raises:\n            ValueError: If an invalid combination of observable, observable_circuit and\n                post_processing is passed.\n\n        Returns:\n            The result object containing information about the solution vector of the linear\n            system.\n        ')), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)], orelse=[])], orelse=[]), Assign(targets=[Name(id='solution', ctx=Store())], value=Call(func=Name(id='LinearSolverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='vector', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='euclidean_norm', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='solution', ctx=Load()))], decorator_list=[], returns=Name(id='LinearSolverResult', ctx=Load()))], decorator_list=[])])
Expr(value=Str(s='The HHL algorithm.'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Callable', asname=None), alias(name='Tuple', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None), alias(name='AncillaRegister', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library', names=[alias(name='PhaseEstimation', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library.arithmetic.piecewise_chebyshev', names=[alias(name='PiecewiseChebyshev', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library.arithmetic.exact_reciprocal', names=[alias(name='ExactReciprocal', asname=None)], level=0)
ImportFrom(module='qiskit.opflow', names=[alias(name='Z', asname=None), alias(name='I', asname=None), alias(name='StateFn', asname=None), alias(name='TensoredOp', asname=None), alias(name='ExpectationBase', asname=None), alias(name='CircuitSampler', asname=None), alias(name='ListOp', asname=None), alias(name='ExpectationFactory', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.quantum_info.operators.base_operator', names=[alias(name='BaseOperator', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='linear_solver', names=[alias(name='LinearSolver', asname=None), alias(name='LinearSolverResult', asname=None)], level=1)
ImportFrom(module='matrices.numpy_matrix', names=[alias(name='NumPyMatrix', asname=None)], level=1)
ImportFrom(module='observables.linear_system_observable', names=[alias(name='LinearSystemObservable', asname=None)], level=1)
ClassDef(name='HHL', bases=[Name(id='LinearSolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Systems of linear equations arise naturally in many real-life applications in a wide range\n    of areas, such as in the solution of Partial Differential Equations, the calibration of\n    financial models, fluid simulation or numerical field calculation. The problem can be defined\n    as, given a matrix :math:`A\\in\\mathbb{C}^{N\\times N}` and a vector\n    :math:`\\vec{b}\\in\\mathbb{C}^{N}`, find :math:`\\vec{x}\\in\\mathbb{C}^{N}` satisfying\n    :math:`A\\vec{x}=\\vec{b}`.\n\n    A system of linear equations is called :math:`s`-sparse if :math:`A` has at most :math:`s`\n    non-zero entries per row or column. Solving an :math:`s`-sparse system of size :math:`N` with\n    a classical computer requires :math:`\\mathcal{ O }(Ns\\kappa\\log(1/\\epsilon))` running time\n    using the conjugate gradient method. Here :math:`\\kappa` denotes the condition number of the\n    system and :math:`\\epsilon` the accuracy of the approximation.\n\n    The HHL is a quantum algorithm to estimate a function of the solution with running time\n    complexity of :math:`\\mathcal{ O }(\\log(N)s^{2}\\kappa^{2}/\\epsilon)` when\n    :math:`A` is a Hermitian matrix under the assumptions of efficient oracles for loading the\n    data, Hamiltonian simulation and computing a function of the solution. This is an exponential\n    speed up in the size of the system, however one crucial remark to keep in mind is that the\n    classical algorithm returns the full solution, while the HHL can only approximate functions of\n    the solution vector.\n\n    Examples:\n\n        .. jupyter-execute::\n\n            import numpy as np\n            from qiskit import QuantumCircuit\n            from qiskit.algorithms.linear_solvers.hhl import HHL\n            from qiskit.algorithms.linear_solvers.matrices import TridiagonalToeplitz\n            from qiskit.algorithms.linear_solvers.observables import MatrixFunctional\n\n            matrix = TridiagonalToeplitz(2, 1, 1 / 3, trotter_steps=2)\n            right_hand_side = [1.0, -2.1, 3.2, -4.3]\n            observable = MatrixFunctional(1, 1 / 2)\n            rhs = right_hand_side / np.linalg.norm(right_hand_side)\n\n            # Initial state circuit\n            num_qubits = matrix.num_state_qubits\n            qc = QuantumCircuit(num_qubits)\n            qc.isometry(rhs, list(range(num_qubits)), None)\n\n            hhl = HHL()\n            solution = hhl.solve(matrix, qc, observable)\n            approx_result = solution.observable\n\n    References:\n\n        [1]: Harrow, A. W., Hassidim, A., Lloyd, S. (2009).\n        Quantum algorithm for linear systems of equations.\n        `Phys. Rev. Lett. 103, 15 (2009), 1â€“15. <https://doi.org/10.1103/PhysRevLett.103.150502>`_\n\n        [2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2020).\n        Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n        `arXiv:2009.04484 <http://arxiv.org/abs/2009.04484>`_\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.01), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            epsilon: Error tolerance of the approximation to the solution, i.e. if :math:`x` is the\n                exact solution and :math:`\\tilde{x}` the one calculated by the algorithm, then\n                :math:`||x - \\tilde{x}|| \\le epsilon`.\n            expectation: The expectation converter applied to the expectation values before\n                evaluation. If None then PauliExpectation is used.\n            quantum_instance: Quantum Instance or Backend. If None, a Statevector calculation is\n                done.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_s', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=6))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Store())], value=NameConstant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Num(n=1))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=NameConstant(value=None), orelse=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n                If None, a Statevector calculation is done.\n        ')), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))])], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The scaling of the solution vector.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='scaling', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the new scaling of the solution vector.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=Name(id='scaling', ctx=Load()))], decorator_list=[Attribute(value=Name(id='scaling', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ExpectationBase', ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the expectation value algorithm.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_get_delta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n_l', annotation=Name(id='int', ctx=Load())), arg(arg='lambda_min', annotation=Name(id='float', ctx=Load())), arg(arg='lambda_max', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the scaling factor to represent exactly lambda_min on nl binary digits.\n\n        Args:\n            n_l: The number of qubits to represent the eigenvalues.\n            lambda_min: the smallest eigenvalue.\n            lambda_max: the largest eigenvalue.\n\n        Returns:\n            The value of the scaling factor.\n        ')), Assign(targets=[Name(id='formatstr', ctx=Store())], value=BinOp(left=BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])), op=Add(), right=Str(s='b'))), Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), ops=[Lt()], comparators=[Num(n=1e-07)]), body=[Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Num(n=1))], orelse=[]), Assign(targets=[Name(id='binstr', ctx=Store())], value=Subscript(value=Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())), Assign(targets=[Name(id='lamb_min_rep', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='char', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='binstr', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='lamb_min_rep', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))))], orelse=[]), Return(value=Name(id='lamb_min_rep', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='_calculate_norm', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qc', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the value of the euclidean norm of the solution.\n\n        Args:\n            qc: The quantum circuit preparing the solution x to the system.\n\n        Returns:\n            The value of the euclidean norm of the solution.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='qc', ctx=Load()), attr='num_ancillas', ctx=Load())), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))), Assign(targets=[Name(id='norm_2', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='_calculate_observable', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='solution', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Calculates the value of the observable(s) given.\n\n        Args:\n            solution: The quantum circuit preparing the solution x to the system.\n            observable: Information to be extracted from the solution.\n            observable_circuit: Circuit to be applied to the solution to extract information.\n            post_processing: Function to compute the value of the observable.\n\n        Returns:\n            The value of the observable(s) and the circuit results before post-processing as a\n             tuple.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='solution', ctx=Load()), attr='num_ancillas', ctx=Load())), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='post_processing', ctx=Store())], value=Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))]), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=True)), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='observable', ctx=Store())], value=List(elts=[Name(id='observable', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='expectations', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='circ', ctx=Store()), Name(id='obs', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='observable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ob', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='expectation_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='post_processing', ctx=Load()), args=[Name(id='expectation_results', ctx=Load()), Name(id='nb', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='result', ctx=Load()), Name(id='expectation_results', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='neg_vals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=True)]), body=[Expr(value=Str(s='Construct the HHL circuit.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            neg_vals: States whether the matrix has negative eigenvalues. If False the\n            computation becomes cheaper.\n\n        Returns:\n            The HHL circuit.\n\n        Raises:\n            ValueError: If the input is not in the correct format.\n            ValueError: If the type of the input matrix is not supported.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Name(id='vector', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='nf', ctx=Store())], value=Num(n=1)), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Name(id='matrix', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='tolerance')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load()))], orelse=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Num(n=1))]), Assign(targets=[Name(id='nl', ctx=Store())], value=BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[]), op=Add(), right=Name(id='neg_vals', ctx=Load()))), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='delta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load())))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Name(id='lambda_min', ctx=Load()))], orelse=[Assign(targets=[Name(id='delta', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))])), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))], orelse=[Assign(targets=[Name(id='num_values', ctx=Store())], value=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))), Assign(targets=[Name(id='constant', ctx=Store())], value=Name(id='delta', ctx=Load())), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[]))), Assign(targets=[Name(id='degree', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='num_intervals', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[])), Assign(targets=[Name(id='breakpoints', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[])), Assign(targets=[Name(id='na', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='qb', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ql', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nl', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qa', ctx=Store())], value=Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='qf', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nf', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector_circuit', ctx=Load()), Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])), Assign(targets=[Name(id='phase_estimation', ctx=Store())], value=Call(func=Name(id='PhaseEstimation', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='matrix_circuit', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))]), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Tries to solve the given linear system of equations.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            observable: Optional information to be extracted from the solution.\n                Default is the probability of success of the algorithm.\n            observable_circuit: Optional circuit to be applied to the solution to extract\n                information. Default is `None`.\n            post_processing: Optional function to compute the value of the observable.\n                Default is the raw value of measuring the observable.\n\n        Raises:\n            ValueError: If an invalid combination of observable, observable_circuit and\n                post_processing is passed.\n\n        Returns:\n            The result object containing information about the solution vector of the linear\n            system.\n        ')), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)], orelse=[])], orelse=[]), Assign(targets=[Name(id='solution', ctx=Store())], value=Call(func=Name(id='LinearSolverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='vector', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='euclidean_norm', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='solution', ctx=Load()))], decorator_list=[], returns=Name(id='LinearSolverResult', ctx=Load()))], decorator_list=[])
Str(s='The HHL algorithm.')
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='List', asname=None)
alias(name='Callable', asname=None)
alias(name='Tuple', asname=None)
alias(name='numpy', asname='np')
alias(name='QuantumCircuit', asname=None)
alias(name='QuantumRegister', asname=None)
alias(name='AncillaRegister', asname=None)
alias(name='PhaseEstimation', asname=None)
alias(name='PiecewiseChebyshev', asname=None)
alias(name='ExactReciprocal', asname=None)
alias(name='Z', asname=None)
alias(name='I', asname=None)
alias(name='StateFn', asname=None)
alias(name='TensoredOp', asname=None)
alias(name='ExpectationBase', asname=None)
alias(name='CircuitSampler', asname=None)
alias(name='ListOp', asname=None)
alias(name='ExpectationFactory', asname=None)
alias(name='Backend', asname=None)
alias(name='BaseOperator', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='LinearSolver', asname=None)
alias(name='LinearSolverResult', asname=None)
alias(name='NumPyMatrix', asname=None)
alias(name='LinearSystemObservable', asname=None)
Name(id='LinearSolver', ctx=Load())
Expr(value=Str(s='Systems of linear equations arise naturally in many real-life applications in a wide range\n    of areas, such as in the solution of Partial Differential Equations, the calibration of\n    financial models, fluid simulation or numerical field calculation. The problem can be defined\n    as, given a matrix :math:`A\\in\\mathbb{C}^{N\\times N}` and a vector\n    :math:`\\vec{b}\\in\\mathbb{C}^{N}`, find :math:`\\vec{x}\\in\\mathbb{C}^{N}` satisfying\n    :math:`A\\vec{x}=\\vec{b}`.\n\n    A system of linear equations is called :math:`s`-sparse if :math:`A` has at most :math:`s`\n    non-zero entries per row or column. Solving an :math:`s`-sparse system of size :math:`N` with\n    a classical computer requires :math:`\\mathcal{ O }(Ns\\kappa\\log(1/\\epsilon))` running time\n    using the conjugate gradient method. Here :math:`\\kappa` denotes the condition number of the\n    system and :math:`\\epsilon` the accuracy of the approximation.\n\n    The HHL is a quantum algorithm to estimate a function of the solution with running time\n    complexity of :math:`\\mathcal{ O }(\\log(N)s^{2}\\kappa^{2}/\\epsilon)` when\n    :math:`A` is a Hermitian matrix under the assumptions of efficient oracles for loading the\n    data, Hamiltonian simulation and computing a function of the solution. This is an exponential\n    speed up in the size of the system, however one crucial remark to keep in mind is that the\n    classical algorithm returns the full solution, while the HHL can only approximate functions of\n    the solution vector.\n\n    Examples:\n\n        .. jupyter-execute::\n\n            import numpy as np\n            from qiskit import QuantumCircuit\n            from qiskit.algorithms.linear_solvers.hhl import HHL\n            from qiskit.algorithms.linear_solvers.matrices import TridiagonalToeplitz\n            from qiskit.algorithms.linear_solvers.observables import MatrixFunctional\n\n            matrix = TridiagonalToeplitz(2, 1, 1 / 3, trotter_steps=2)\n            right_hand_side = [1.0, -2.1, 3.2, -4.3]\n            observable = MatrixFunctional(1, 1 / 2)\n            rhs = right_hand_side / np.linalg.norm(right_hand_side)\n\n            # Initial state circuit\n            num_qubits = matrix.num_state_qubits\n            qc = QuantumCircuit(num_qubits)\n            qc.isometry(rhs, list(range(num_qubits)), None)\n\n            hhl = HHL()\n            solution = hhl.solve(matrix, qc, observable)\n            approx_result = solution.observable\n\n    References:\n\n        [1]: Harrow, A. W., Hassidim, A., Lloyd, S. (2009).\n        Quantum algorithm for linear systems of equations.\n        `Phys. Rev. Lett. 103, 15 (2009), 1â€“15. <https://doi.org/10.1103/PhysRevLett.103.150502>`_\n\n        [2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2020).\n        Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n        `arXiv:2009.04484 <http://arxiv.org/abs/2009.04484>`_\n\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.01), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            epsilon: Error tolerance of the approximation to the solution, i.e. if :math:`x` is the\n                exact solution and :math:`\\tilde{x}` the one calculated by the algorithm, then\n                :math:`||x - \\tilde{x}|| \\le epsilon`.\n            expectation: The expectation converter applied to the expectation values before\n                evaluation. If None then PauliExpectation is used.\n            quantum_instance: Quantum Instance or Backend. If None, a Statevector calculation is\n                done.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_s', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=6))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Store())], value=NameConstant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Num(n=1))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=NameConstant(value=None), orelse=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n                If None, a Statevector calculation is done.\n        ')), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))])], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The scaling of the solution vector.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='scaling', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the new scaling of the solution vector.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=Name(id='scaling', ctx=Load()))], decorator_list=[Attribute(value=Name(id='scaling', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ExpectationBase', ctx=Load()))
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the expectation value algorithm.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='_get_delta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n_l', annotation=Name(id='int', ctx=Load())), arg(arg='lambda_min', annotation=Name(id='float', ctx=Load())), arg(arg='lambda_max', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the scaling factor to represent exactly lambda_min on nl binary digits.\n\n        Args:\n            n_l: The number of qubits to represent the eigenvalues.\n            lambda_min: the smallest eigenvalue.\n            lambda_max: the largest eigenvalue.\n\n        Returns:\n            The value of the scaling factor.\n        ')), Assign(targets=[Name(id='formatstr', ctx=Store())], value=BinOp(left=BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])), op=Add(), right=Str(s='b'))), Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), ops=[Lt()], comparators=[Num(n=1e-07)]), body=[Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Num(n=1))], orelse=[]), Assign(targets=[Name(id='binstr', ctx=Store())], value=Subscript(value=Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())), Assign(targets=[Name(id='lamb_min_rep', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='char', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='binstr', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='lamb_min_rep', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))))], orelse=[]), Return(value=Name(id='lamb_min_rep', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load()))
FunctionDef(name='_calculate_norm', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qc', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the value of the euclidean norm of the solution.\n\n        Args:\n            qc: The quantum circuit preparing the solution x to the system.\n\n        Returns:\n            The value of the euclidean norm of the solution.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='qc', ctx=Load()), attr='num_ancillas', ctx=Load())), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))), Assign(targets=[Name(id='norm_2', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load()))
FunctionDef(name='_calculate_observable', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='solution', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Calculates the value of the observable(s) given.\n\n        Args:\n            solution: The quantum circuit preparing the solution x to the system.\n            observable: Information to be extracted from the solution.\n            observable_circuit: Circuit to be applied to the solution to extract information.\n            post_processing: Function to compute the value of the observable.\n\n        Returns:\n            The value of the observable(s) and the circuit results before post-processing as a\n             tuple.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='solution', ctx=Load()), attr='num_ancillas', ctx=Load())), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='post_processing', ctx=Store())], value=Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))]), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=True)), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='observable', ctx=Store())], value=List(elts=[Name(id='observable', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='expectations', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='circ', ctx=Store()), Name(id='obs', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='observable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ob', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='expectation_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='post_processing', ctx=Load()), args=[Name(id='expectation_results', ctx=Load()), Name(id='nb', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='result', ctx=Load()), Name(id='expectation_results', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='neg_vals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=True)]), body=[Expr(value=Str(s='Construct the HHL circuit.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            neg_vals: States whether the matrix has negative eigenvalues. If False the\n            computation becomes cheaper.\n\n        Returns:\n            The HHL circuit.\n\n        Raises:\n            ValueError: If the input is not in the correct format.\n            ValueError: If the type of the input matrix is not supported.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Name(id='vector', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='nf', ctx=Store())], value=Num(n=1)), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Name(id='matrix', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='tolerance')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load()))], orelse=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Num(n=1))]), Assign(targets=[Name(id='nl', ctx=Store())], value=BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[]), op=Add(), right=Name(id='neg_vals', ctx=Load()))), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='delta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load())))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Name(id='lambda_min', ctx=Load()))], orelse=[Assign(targets=[Name(id='delta', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))])), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))], orelse=[Assign(targets=[Name(id='num_values', ctx=Store())], value=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))), Assign(targets=[Name(id='constant', ctx=Store())], value=Name(id='delta', ctx=Load())), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[]))), Assign(targets=[Name(id='degree', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='num_intervals', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[])), Assign(targets=[Name(id='breakpoints', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[])), Assign(targets=[Name(id='na', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='qb', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ql', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nl', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qa', ctx=Store())], value=Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='qf', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nf', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector_circuit', ctx=Load()), Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])), Assign(targets=[Name(id='phase_estimation', ctx=Store())], value=Call(func=Name(id='PhaseEstimation', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='matrix_circuit', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))]), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Tries to solve the given linear system of equations.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            observable: Optional information to be extracted from the solution.\n                Default is the probability of success of the algorithm.\n            observable_circuit: Optional circuit to be applied to the solution to extract\n                information. Default is `None`.\n            post_processing: Optional function to compute the value of the observable.\n                Default is the raw value of measuring the observable.\n\n        Raises:\n            ValueError: If an invalid combination of observable, observable_circuit and\n                post_processing is passed.\n\n        Returns:\n            The result object containing information about the solution vector of the linear\n            system.\n        ')), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)], orelse=[])], orelse=[]), Assign(targets=[Name(id='solution', ctx=Store())], value=Call(func=Name(id='LinearSolverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='vector', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='euclidean_norm', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='solution', ctx=Load()))], decorator_list=[], returns=Name(id='LinearSolverResult', ctx=Load()))
Load()
Str(s='Systems of linear equations arise naturally in many real-life applications in a wide range\n    of areas, such as in the solution of Partial Differential Equations, the calibration of\n    financial models, fluid simulation or numerical field calculation. The problem can be defined\n    as, given a matrix :math:`A\\in\\mathbb{C}^{N\\times N}` and a vector\n    :math:`\\vec{b}\\in\\mathbb{C}^{N}`, find :math:`\\vec{x}\\in\\mathbb{C}^{N}` satisfying\n    :math:`A\\vec{x}=\\vec{b}`.\n\n    A system of linear equations is called :math:`s`-sparse if :math:`A` has at most :math:`s`\n    non-zero entries per row or column. Solving an :math:`s`-sparse system of size :math:`N` with\n    a classical computer requires :math:`\\mathcal{ O }(Ns\\kappa\\log(1/\\epsilon))` running time\n    using the conjugate gradient method. Here :math:`\\kappa` denotes the condition number of the\n    system and :math:`\\epsilon` the accuracy of the approximation.\n\n    The HHL is a quantum algorithm to estimate a function of the solution with running time\n    complexity of :math:`\\mathcal{ O }(\\log(N)s^{2}\\kappa^{2}/\\epsilon)` when\n    :math:`A` is a Hermitian matrix under the assumptions of efficient oracles for loading the\n    data, Hamiltonian simulation and computing a function of the solution. This is an exponential\n    speed up in the size of the system, however one crucial remark to keep in mind is that the\n    classical algorithm returns the full solution, while the HHL can only approximate functions of\n    the solution vector.\n\n    Examples:\n\n        .. jupyter-execute::\n\n            import numpy as np\n            from qiskit import QuantumCircuit\n            from qiskit.algorithms.linear_solvers.hhl import HHL\n            from qiskit.algorithms.linear_solvers.matrices import TridiagonalToeplitz\n            from qiskit.algorithms.linear_solvers.observables import MatrixFunctional\n\n            matrix = TridiagonalToeplitz(2, 1, 1 / 3, trotter_steps=2)\n            right_hand_side = [1.0, -2.1, 3.2, -4.3]\n            observable = MatrixFunctional(1, 1 / 2)\n            rhs = right_hand_side / np.linalg.norm(right_hand_side)\n\n            # Initial state circuit\n            num_qubits = matrix.num_state_qubits\n            qc = QuantumCircuit(num_qubits)\n            qc.isometry(rhs, list(range(num_qubits)), None)\n\n            hhl = HHL()\n            solution = hhl.solve(matrix, qc, observable)\n            approx_result = solution.observable\n\n    References:\n\n        [1]: Harrow, A. W., Hassidim, A., Lloyd, S. (2009).\n        Quantum algorithm for linear systems of equations.\n        `Phys. Rev. Lett. 103, 15 (2009), 1â€“15. <https://doi.org/10.1103/PhysRevLett.103.150502>`_\n\n        [2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2020).\n        Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n        `arXiv:2009.04484 <http://arxiv.org/abs/2009.04484>`_\n\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.01), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='\n        Args:\n            epsilon: Error tolerance of the approximation to the solution, i.e. if :math:`x` is the\n                exact solution and :math:`\\tilde{x}` the one calculated by the algorithm, then\n                :math:`||x - \\tilde{x}|| \\le epsilon`.\n            expectation: The expectation converter applied to the expectation values before\n                evaluation. If None then PauliExpectation is used.\n            quantum_instance: Quantum Instance or Backend. If None, a Statevector calculation is\n                done.\n        '))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3)))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_s', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3)))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=6)))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Store())], value=NameConstant(value=True))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Num(n=1))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        '))
Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=NameConstant(value=None), orelse=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n                If None, a Statevector calculation is done.\n        '))
If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))])
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='The scaling of the solution vector.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='scaling', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the new scaling of the solution vector.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=Name(id='scaling', ctx=Load()))
Attribute(value=Name(id='scaling', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='ExpectationBase', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the expectation value algorithm.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))
Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='n_l', annotation=Name(id='int', ctx=Load())), arg(arg='lambda_min', annotation=Name(id='float', ctx=Load())), arg(arg='lambda_max', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Calculates the scaling factor to represent exactly lambda_min on nl binary digits.\n\n        Args:\n            n_l: The number of qubits to represent the eigenvalues.\n            lambda_min: the smallest eigenvalue.\n            lambda_max: the largest eigenvalue.\n\n        Returns:\n            The value of the scaling factor.\n        '))
Assign(targets=[Name(id='formatstr', ctx=Store())], value=BinOp(left=BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])), op=Add(), right=Str(s='b')))
Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))], keywords=[]))
If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), ops=[Lt()], comparators=[Num(n=1e-07)]), body=[Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Num(n=1))], orelse=[])
Assign(targets=[Name(id='binstr', ctx=Store())], value=Subscript(value=Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()))
Assign(targets=[Name(id='lamb_min_rep', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='char', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='binstr', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='lamb_min_rep', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))))], orelse=[])
Return(value=Name(id='lamb_min_rep', ctx=Load()))
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='qc', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Calculates the value of the euclidean norm of the solution.\n\n        Args:\n            qc: The quantum circuit preparing the solution x to the system.\n\n        Returns:\n            The value of the euclidean norm of the solution.\n        '))
Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load()))
Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load()))
Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='qc', ctx=Load()), attr='num_ancillas', ctx=Load()))
Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load()))))
Assign(targets=[Name(id='norm_2', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load()), args=[], keywords=[]))
Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))], keywords=[]))
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='solution', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='Calculates the value of the observable(s) given.\n\n        Args:\n            solution: The quantum circuit preparing the solution x to the system.\n            observable: Information to be extracted from the solution.\n            observable_circuit: Circuit to be applied to the solution to extract information.\n            post_processing: Function to compute the value of the observable.\n\n        Returns:\n            The value of the observable(s) and the circuit results before post-processing as a\n             tuple.\n        '))
Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load()))
Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load()))
Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='solution', ctx=Load()), attr='num_ancillas', ctx=Load()))
If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='post_processing', ctx=Store())], value=Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))])
Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=True))
If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='observable', ctx=Store())], value=List(elts=[Name(id='observable', ctx=Load())], ctx=Load()))], orelse=[])
Assign(targets=[Name(id='expectations', ctx=Store())], value=List(elts=[], ctx=Load()))
For(target=Tuple(elts=[Name(id='circ', ctx=Store()), Name(id='obs', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='observable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ob', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[])
If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))])
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])])
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='expectation_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='post_processing', ctx=Load()), args=[Name(id='expectation_results', ctx=Load()), Name(id='nb', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())], keywords=[]))
Return(value=Tuple(elts=[Name(id='result', ctx=Load()), Name(id='expectation_results', ctx=Load())], ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='neg_vals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=True)])
Expr(value=Str(s='Construct the HHL circuit.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            neg_vals: States whether the matrix has negative eigenvalues. If False the\n            computation becomes cheaper.\n\n        Returns:\n            The HHL circuit.\n\n        Raises:\n            ValueError: If the input is not in the correct format.\n            ValueError: If the type of the input matrix is not supported.\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Name(id='vector', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))], orelse=[])])
Assign(targets=[Name(id='nf', ctx=Store())], value=Num(n=1))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Name(id='matrix', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)])])
If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='tolerance')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load()))], orelse=[])
If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load()))], orelse=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Num(n=1))])
Assign(targets=[Name(id='nl', ctx=Store())], value=BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[]), op=Add(), right=Name(id='neg_vals', ctx=Load())))
If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='delta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load())))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Name(id='lambda_min', ctx=Load()))], orelse=[Assign(targets=[Name(id='delta', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[]))])
If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))])), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))], orelse=[Assign(targets=[Name(id='num_values', ctx=Store())], value=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))), Assign(targets=[Name(id='constant', ctx=Store())], value=Name(id='delta', ctx=Load())), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[]))), Assign(targets=[Name(id='degree', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='num_intervals', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[])), Assign(targets=[Name(id='breakpoints', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[])), Assign(targets=[Name(id='na', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[]))])
Assign(targets=[Name(id='qb', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='ql', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nl', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qa', ctx=Store())], value=Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='qf', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nf', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector_circuit', ctx=Load()), Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))
Assign(targets=[Name(id='phase_estimation', ctx=Store())], value=Call(func=Name(id='PhaseEstimation', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='matrix_circuit', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))])
If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))])
If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))])
Return(value=Name(id='qc', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='Tries to solve the given linear system of equations.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            observable: Optional information to be extracted from the solution.\n                Default is the probability of success of the algorithm.\n            observable_circuit: Optional circuit to be applied to the solution to extract\n                information. Default is `None`.\n            post_processing: Optional function to compute the value of the observable.\n                Default is the raw value of measuring the observable.\n\n        Raises:\n            ValueError: If an invalid combination of observable, observable_circuit and\n                post_processing is passed.\n\n        Returns:\n            The result object containing information about the solution vector of the linear\n            system.\n        '))
If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)], orelse=[])], orelse=[])
Assign(targets=[Name(id='solution', ctx=Store())], value=Call(func=Name(id='LinearSolverResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='vector', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='euclidean_norm', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())], keywords=[]))
If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[]))], orelse=[])
Return(value=Name(id='solution', ctx=Load()))
Name(id='LinearSolverResult', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))
arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Num(n=0.01)
NameConstant(value=None)
NameConstant(value=None)
Str(s='\n        Args:\n            epsilon: Error tolerance of the approximation to the solution, i.e. if :math:`x` is the\n                exact solution and :math:`\\tilde{x}` the one calculated by the algorithm, then\n                :math:`||x - \\tilde{x}|| \\le epsilon`.\n            expectation: The expectation converter applied to the expectation values before\n                evaluation. If None then PauliExpectation is used.\n            quantum_instance: Quantum Instance or Backend. If None, a Statevector calculation is\n                done.\n        ')
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())
Name(id='epsilon', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Store())
BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_s', ctx=Store())
BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Store())
BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=6))
Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
Name(id='expectation', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Store())
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())
Num(n=1)
arg(arg='self', annotation=None)
Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')
IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=NameConstant(value=None), orelse=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n                If None, a Statevector calculation is done.\n        ')
Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='The scaling of the solution vector.')
Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='scaling', annotation=Name(id='float', ctx=Load()))
Str(s='Set the new scaling of the solution vector.')
Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())
Name(id='scaling', ctx=Load())
Name(id='scaling', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))
Str(s='Set the expectation value algorithm.')
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
Name(id='expectation', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='n_l', annotation=Name(id='int', ctx=Load()))
arg(arg='lambda_min', annotation=Name(id='float', ctx=Load()))
arg(arg='lambda_max', annotation=Name(id='float', ctx=Load()))
Str(s='Calculates the scaling factor to represent exactly lambda_min on nl binary digits.\n\n        Args:\n            n_l: The number of qubits to represent the eigenvalues.\n            lambda_min: the smallest eigenvalue.\n            lambda_max: the largest eigenvalue.\n\n        Returns:\n            The value of the scaling factor.\n        ')
Name(id='formatstr', ctx=Store())
BinOp(left=BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])), op=Add(), right=Str(s='b'))
Name(id='lambda_min_tilde', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))], keywords=[])
Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), ops=[Lt()], comparators=[Num(n=1e-07)])
Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Num(n=1))
Name(id='binstr', ctx=Store())
Subscript(value=Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())
Name(id='lamb_min_rep', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='char', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='binstr', ctx=Load())], keywords=[])
AugAssign(target=Name(id='lamb_min_rep', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))))
Name(id='lamb_min_rep', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='qc', annotation=Name(id='QuantumCircuit', ctx=Load()))
Str(s='Calculates the value of the euclidean norm of the solution.\n\n        Args:\n            qc: The quantum circuit preparing the solution x to the system.\n\n        Returns:\n            The value of the euclidean norm of the solution.\n        ')
Name(id='nb', ctx=Store())
Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())
Name(id='nl', ctx=Store())
Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())
Name(id='na', ctx=Store())
Attribute(value=Name(id='qc', ctx=Load()), attr='num_ancillas', ctx=Load())
Name(id='zero_op', ctx=Store())
BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))
Name(id='one_op', ctx=Store())
BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))
Name(id='observable', ctx=Store())
BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))
Name(id='norm_2', ctx=Store())
Call(func=Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))], keywords=[])
Load()
arg(arg='self', annotation=None)
arg(arg='solution', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
Str(s='Calculates the value of the observable(s) given.\n\n        Args:\n            solution: The quantum circuit preparing the solution x to the system.\n            observable: Information to be extracted from the solution.\n            observable_circuit: Circuit to be applied to the solution to extract information.\n            post_processing: Function to compute the value of the observable.\n\n        Returns:\n            The value of the observable(s) and the circuit results before post-processing as a\n             tuple.\n        ')
Name(id='nb', ctx=Store())
Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())
Name(id='nl', ctx=Store())
Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())
Name(id='na', ctx=Store())
Attribute(value=Name(id='solution', ctx=Load()), attr='num_ancillas', ctx=Load())
Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='post_processing', ctx=Store())], value=Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load()))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))
Name(id='zero_op', ctx=Store())
BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))
Name(id='one_op', ctx=Store())
BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))
Name(id='is_list', ctx=Store())
NameConstant(value=True)
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=False))
Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load()))
Assign(targets=[Name(id='observable', ctx=Store())], value=List(elts=[Name(id='observable', ctx=Load())], ctx=Load()))
Name(id='expectations', ctx=Store())
List(elts=[], ctx=Load())
Tuple(elts=[Name(id='circ', ctx=Store()), Name(id='obs', ctx=Store())], ctx=Store())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='observable', ctx=Load())], keywords=[])
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Name(id='ob', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load())))
Expr(value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[]))
Name(id='is_list', ctx=Load())
Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='expectations', ctx=Store())], value=Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))
Name(id='expectation_results', ctx=Store())
Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])
Name(id='result', ctx=Store())
Call(func=Name(id='post_processing', ctx=Load()), args=[Name(id='expectation_results', ctx=Load()), Name(id='nb', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())], keywords=[])
Tuple(elts=[Name(id='result', ctx=Load()), Name(id='expectation_results', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='neg_vals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load()))
NameConstant(value=True)
Str(s='Construct the HHL circuit.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            neg_vals: States whether the matrix has negative eigenvalues. If False the\n            computation becomes cheaper.\n\n        Returns:\n            The HHL circuit.\n\n        Raises:\n            ValueError: If the input is not in the correct format.\n            ValueError: If the type of the input matrix is not supported.\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[])
Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load()))
Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Name(id='vector', ctx=Load()))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))], orelse=[])
Name(id='nf', ctx=Store())
Num(n=1)
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[])
Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Name(id='matrix', ctx=Load()))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)])
Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='tolerance')], keywords=[])
Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load()))
BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Assign(targets=[Name(id='kappa', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load()))
Assign(targets=[Name(id='kappa', ctx=Store())], value=Num(n=1))
Name(id='nl', ctx=Store())
BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[]), op=Add(), right=Name(id='neg_vals', ctx=Load()))
BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Assign(targets=[Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='delta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load()))))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Name(id='lambda_min', ctx=Load()))
Assign(targets=[Name(id='delta', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))))
Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load())
Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))]))
Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))
Assign(targets=[Name(id='num_values', ctx=Store())], value=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))
Assign(targets=[Name(id='constant', ctx=Store())], value=Name(id='delta', ctx=Load()))
Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[]))
Assign(targets=[Name(id='r', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[])))
Assign(targets=[Name(id='degree', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='num_intervals', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[]))
Assign(targets=[Name(id='breakpoints', ctx=Store())], value=List(elts=[], ctx=Load()))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])], orelse=[])
Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='na', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[]))
Name(id='qb', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Name(id='ql', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nl', ctx=Load())], keywords=[])
Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Assign(targets=[Name(id='qa', ctx=Store())], value=Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[]))
Name(id='qf', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nf', ctx=Load())], keywords=[])
Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector_circuit', ctx=Load()), Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])
Name(id='phase_estimation', ctx=Store())
Call(func=Name(id='PhaseEstimation', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='matrix_circuit', ctx=Load())], keywords=[])
Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))
Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))
Name(id='qc', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
Str(s='Tries to solve the given linear system of equations.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            observable: Optional information to be extracted from the solution.\n                Default is the probability of success of the algorithm.\n            observable_circuit: Optional circuit to be applied to the solution to extract\n                information. Default is `None`.\n            post_processing: Optional function to compute the value of the observable.\n                Default is the raw value of measuring the observable.\n\n        Raises:\n            ValueError: If an invalid combination of observable, observable_circuit and\n                post_processing is passed.\n\n        Returns:\n            The result object containing information about the solution vector of the linear\n            system.\n        ')
Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)], orelse=[])
Name(id='solution', ctx=Store())
Call(func=Name(id='LinearSolverResult', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='vector', ctx=Load())], keywords=[])
Attribute(value=Name(id='solution', ctx=Load()), attr='euclidean_norm', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())], keywords=[])
BoolOp(op=Or(), values=[Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Assign(targets=[Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[]))
Name(id='solution', ctx=Load())
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='epsilon', ctx=Load())
Div()
Num(n=3)
Name(id='self', ctx=Load())
Store()
Name(id='epsilon', ctx=Load())
Div()
Num(n=3)
Name(id='self', ctx=Load())
Store()
Name(id='epsilon', ctx=Load())
Div()
Num(n=6)
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
NameConstant(value=None)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='quantum_instance', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())
Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())
NameConstant(value=None)
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Store()
BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[]))
Add()
Str(s='b')
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Lt()
Num(n=1e-07)
Name(id='lambda_min_tilde', ctx=Store())
Num(n=1)
Store()
Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[])
Slice(lower=Num(n=2), upper=None, step=None)
Load()
Store()
Name(id='i', ctx=Store())
Name(id='char', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='binstr', ctx=Load())
Name(id='lamb_min_rep', ctx=Store())
Add()
BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))))
Load()
Name(id='QuantumCircuit', ctx=Load())
Store()
Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Store()
Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Load()
Store()
Name(id='qc', ctx=Load())
Load()
Store()
BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load()))
Div()
Num(n=2)
Store()
BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load()))
Div()
Num(n=2)
Store()
BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[]))
BitXor()
BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load()))
Store()
Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Store()
Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Store()
Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Load()
Store()
Name(id='solution', ctx=Load())
Load()
Name(id='observable', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='observable_circuit', ctx=Store())
Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Name(id='post_processing', ctx=Store())
Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[])
Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))
Name(id='observable', ctx=Store())
BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load()))
Store()
BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load()))
Div()
Num(n=2)
Store()
BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load()))
Div()
Num(n=2)
Store()
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Name(id='is_list', ctx=Store())
NameConstant(value=False)
Name(id='observable_circuit', ctx=Store())
List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load())
Name(id='observable', ctx=Store())
List(elts=[Name(id='observable', ctx=Load())], ctx=Load())
Store()
Load()
Name(id='circ', ctx=Store())
Name(id='obs', ctx=Store())
Store()
Name(id='zip', ctx=Load())
Name(id='observable_circuit', ctx=Load())
Name(id='observable', ctx=Load())
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])
Name(id='ob', ctx=Store())
BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load()))
Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[])
Load()
Name(id='expectations', ctx=Store())
Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[])
Name(id='expectations', ctx=Store())
Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='expectations', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='expectations', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load())
Store()
Name(id='post_processing', ctx=Load())
Name(id='expectation_results', ctx=Load())
Name(id='nb', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())
Name(id='result', ctx=Load())
Name(id='expectation_results', ctx=Load())
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='vector', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Name(id='nb', ctx=Store())
Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='vector_circuit', ctx=Store())
Name(id='vector', ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))
Store()
Name(id='isinstance', ctx=Load())
Name(id='matrix', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Name(id='matrix_circuit', ctx=Store())
Name(id='matrix', ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[])
If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[])
If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[])
If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[])
If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)
Name(id='hasattr', ctx=Load())
Name(id='matrix_circuit', ctx=Load())
Str(s='tolerance')
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load())
And()
Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[])
Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])
Name(id='kappa', ctx=Store())
Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load())
Name(id='kappa', ctx=Store())
Num(n=1)
Store()
Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[])
Add()
Name(id='neg_vals', ctx=Load())
And()
Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[])
Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])
Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])
Name(id='delta', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[])
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())
BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load())))
Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())
Name(id='lambda_min', ctx=Load())
Name(id='delta', ctx=Store())
BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))
Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[])
Name(id='self', ctx=Load())
Load()
Name(id='reciprocal_circuit', ctx=Store())
Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))])
Name(id='na', ctx=Store())
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Name(id='num_values', ctx=Store())
BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))
Name(id='constant', ctx=Store())
Name(id='delta', ctx=Load())
Name(id='a', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[])
Name(id='r', ctx=Store())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[]))
Name(id='degree', ctx=Store())
Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[])
Name(id='num_intervals', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[])
Name(id='breakpoints', ctx=Store())
List(elts=[], ctx=Load())
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[]))
If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])
Name(id='reciprocal_circuit', ctx=Store())
Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[])
Name(id='na', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[])
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='nb', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='nl', ctx=Load())
Name(id='na', ctx=Load())
Gt()
Num(n=0)
Name(id='qa', ctx=Store())
Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[])
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='nf', ctx=Load())
Name(id='na', ctx=Load())
Gt()
Num(n=0)
Name(id='qc', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[])
Name(id='qc', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[])
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Name(id='vector_circuit', ctx=Load())
Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Store()
Name(id='PhaseEstimation', ctx=Load())
Name(id='nl', ctx=Load())
Name(id='matrix_circuit', ctx=Load())
Name(id='na', ctx=Load())
Gt()
Num(n=0)
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[])
Name(id='self', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[])
Name(id='na', ctx=Load())
Gt()
Num(n=0)
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[])
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='observable', ctx=Load())
IsNot()
NameConstant(value=None)
BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)
Store()
Name(id='LinearSolverResult', ctx=Load())
Name(id='solution', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='matrix', ctx=Load())
Name(id='vector', ctx=Load())
Name(id='solution', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load())
Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())
Or()
Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[])
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
Is()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='CircuitSampler', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Str(s='#0')
Add()
Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])
Name(id='np', ctx=Load())
Load()
BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1)))
Div()
Name(id='lambda_max', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))
Store()
Name(id='format', ctx=Load())
Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[])
Name(id='formatstr', ctx=Load())
Num(n=2)
Store()
Store()
Load()
Load()
Store()
Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[])
Div()
BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load())
Index(value=Num(n=0))
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load())
Index(value=Num(n=1))
Load()
Load()
Name(id='I', ctx=Load())
Add()
Name(id='Z', ctx=Load())
Name(id='I', ctx=Load())
Sub()
Name(id='Z', ctx=Load())
Name(id='one_op', ctx=Load())
BitXor()
Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])
Name(id='I', ctx=Load())
BitXor()
Name(id='nb', ctx=Load())
BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]))
Load()
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[])
Div()
Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load())
Index(value=Num(n=0))
Load()
Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load())
Index(value=Num(n=1))
Load()
Load()
Load()
Store()
Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load())
Name(id='nb', ctx=Load())
Store()
Name(id='observable', ctx=Load())
Load()
Name(id='isinstance', ctx=Load())
Name(id='observable', ctx=Load())
Name(id='LinearSystemObservable', ctx=Load())
Name(id='observable', ctx=Store())
Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Store()
Name(id='I', ctx=Load())
BitXor()
Name(id='nb', ctx=Load())
Name(id='I', ctx=Load())
Add()
Name(id='Z', ctx=Load())
Name(id='I', ctx=Load())
Sub()
Name(id='Z', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='observable_circuit', ctx=Load())
Name(id='list', ctx=Load())
Store()
Store()
Name(id='observable_circuit', ctx=Load())
Load()
Store()
Name(id='observable', ctx=Load())
Load()
Store()
Store()
Load()
Load()
Load()
Store()
Name(id='QuantumCircuit', ctx=Load())
Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='solution', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='circ', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Store()
BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[]))
BitXor()
Name(id='obs', ctx=Load())
Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load())
BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Store()
Name(id='ListOp', ctx=Load())
Name(id='expectations', ctx=Load())
Store()
Name(id='expectations', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load())
Name(id='expectations', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='is_list', ctx=Load())
Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load())
Name(id='expectations', ctx=Load())
Name(id='expectations', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='bool', ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='vector', ctx=Load())
Load()
Store()
Load()
Name(id='isinstance', ctx=Load())
Name(id='vector', ctx=Load())
Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))
Name(id='nb', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='vector_circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[])
Load()
Load()
Load()
Store()
Load()
Name(id='isinstance', ctx=Load())
Name(id='matrix', ctx=Load())
Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))
Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)
Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)
UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[]))
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)
Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)
Name(id='matrix_circuit', ctx=Store())
Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))])
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[])
Load()
Load()
Name(id='matrix_circuit', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='hasattr', ctx=Load())
Name(id='matrix_circuit', ctx=Load())
Str(s='condition_bounds')
Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[])
IsNot()
NameConstant(value=None)
Store()
Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[])
Index(value=Num(n=1))
Load()
Store()
Name(id='max', ctx=Load())
BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1))
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])
Load()
Name(id='hasattr', ctx=Load())
Name(id='matrix_circuit', ctx=Load())
Str(s='eigs_bounds')
Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])
IsNot()
NameConstant(value=None)
Name(id='lambda_min', ctx=Store())
Name(id='lambda_max', ctx=Store())
Store()
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load())
BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load()))
Name(id='lambda_min', ctx=Load())
Name(id='lambda_max', ctx=Load())
Name(id='matrix_circuit', ctx=Load())
Store()
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load()))
Div()
BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load()))
Name(id='self', ctx=Load())
Store()
Load()
Store()
Num(n=1)
Div()
BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))
Name(id='print', ctx=Load())
Str(s='The solution will be calculated up to a scaling factor.')
Load()
Store()
Name(id='ExactReciprocal', ctx=Load())
Name(id='nl', ctx=Load())
Name(id='delta', ctx=Load())
keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))
Store()
Name(id='matrix_circuit', ctx=Load())
Load()
Store()
Num(n=2)
Pow()
Name(id='nl', ctx=Load())
Store()
Load()
Store()
Name(id='int', ctx=Load())
Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])
Store()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load()))
Add()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[])
Store()
Name(id='min', ctx=Load())
Name(id='nb', ctx=Load())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])
Store()
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])
Store()
Load()
Store()
Name(id='range', ctx=Load())
Num(n=0)
Name(id='num_intervals', ctx=Load())
Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])
Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))])
Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))
Store()
Name(id='PiecewiseChebyshev', ctx=Load())
Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[]))
Name(id='degree', ctx=Load())
Name(id='breakpoints', ctx=Load())
Name(id='nl', ctx=Load())
Store()
Name(id='max', ctx=Load())
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Store()
Name(id='AncillaRegister', ctx=Load())
Name(id='na', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='qb', ctx=Load())
Name(id='ql', ctx=Load())
Name(id='qa', ctx=Load())
Name(id='qf', ctx=Load())
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='qb', ctx=Load())
Name(id='ql', ctx=Load())
Name(id='qf', ctx=Load())
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='qb', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Name(id='phase_estimation', ctx=Load())
BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Name(id='phase_estimation', ctx=Load())
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Name(id='reciprocal_circuit', ctx=Load())
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[])
BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Or()
Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[])
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='solution', ctx=Load())
Load()
Name(id='observable', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='observable_circuit', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store())
Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load())
Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())
Name(id='observable', ctx=Load())
Name(id='observable_circuit', ctx=Load())
Name(id='post_processing', ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Name(id='str', ctx=Load())
BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))
Load()
Name(id='lambda_min', ctx=Load())
Mult()
BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='lambda_min_tilde', ctx=Load())
Sub()
Num(n=1)
Load()
Name(id='int', ctx=Load())
Name(id='lambda_min_tilde', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='char', ctx=Load())
Num(n=2)
Pow()
BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))
Name(id='qc', ctx=Load())
Load()
Num(n=0)
Name(id='qc', ctx=Load())
Load()
Num(n=1)
Load()
Load()
Load()
Load()
Load()
Name(id='TensoredOp', ctx=Load())
BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))
Load()
Load()
UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[]))
MatMult()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
Name(id='norm_2', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Name(id='solution', ctx=Load())
Load()
Num(n=0)
Name(id='solution', ctx=Load())
Load()
Num(n=1)
Name(id='observable', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Store()
Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load())
Name(id='nb', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='solution', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='range', ctx=Load())
Name(id='nb', ctx=Load())
Name(id='one_op', ctx=Load())
BitXor()
Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])
Load()
Name(id='expectations', ctx=Load())
Load()
UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[]))
MatMult()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Load()
Load()
Load()
Num(n=0)
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='op', ctx=Store())
Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='op', ctx=Store())
Name(id='expectations', ctx=Load())
Name(id='self', ctx=Load())
Store()
Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load())
Name(id='op', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())
Load()
Name(id='bool', ctx=Load())
Load()
Load()
Load()
Name(id='list', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='isinstance', ctx=Load())
Name(id='vector', ctx=Load())
Name(id='list', ctx=Load())
Name(id='vector', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])
Store()
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='nb', ctx=Load())
Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load())
BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))
Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])
NameConstant(value=None)
Load()
Load()
Name(id='list', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='isinstance', ctx=Load())
Name(id='matrix', ctx=Load())
Name(id='list', ctx=Load())
Name(id='matrix', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[])
Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
NotEq()
Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[])
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1))
NotEq()
Num(n=0)
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[])
Not()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[])
Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
NotEq()
BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))
Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[])
Store()
Name(id='NumPyMatrix', ctx=Load())
Name(id='matrix', ctx=Load())
keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])
Load()
Load()
Load()
Load()
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load())
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load())
Num(n=1)
Load()
Name(id='nb', ctx=Load())
Add()
Num(n=1)
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])
Load()
Load()
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load())
Store()
Store()
Name(id='matrix_circuit', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='nl', ctx=Load())
Sub()
Name(id='neg_vals', ctx=Load())
Load()
Load()
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load()))
Div()
Name(id='lambda_min', ctx=Load())
Num(n=2)
Pow()
Name(id='neg_vals', ctx=Load())
Load()
Num(n=2)
Pow()
Name(id='nl', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='neg_vals', ctx=Load())
Load()
Load()
Load()
Name(id='round', ctx=Load())
BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))
BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load()))
Div()
Name(id='a', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])
Load()
Load()
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))
Load()
Load()
Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load())
BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))
Name(id='i', ctx=Load())
Eq()
BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))
Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Load()
arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])
Load()
Load()
Load()
Load()
Name(id='matrix_circuit', ctx=Load())
Load()
Name(id='reciprocal_circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Load()
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))
Add()
Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load())
Name(id='qc', ctx=Load())
Load()
Load()
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Add()
Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Name(id='qc', ctx=Load())
Load()
Load()
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Add()
List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())
Name(id='qc', ctx=Load())
Load()
Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load())
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))
Add()
Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load())
Name(id='qc', ctx=Load())
Load()
Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load())
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))
Add()
Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load())
Name(id='qc', ctx=Load())
Load()
Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load())
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Add()
Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Load()
Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Name(id='observable_circuit', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='post_processing', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='ValueError', ctx=Load())
Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')
Load()
Load()
Load()
Load()
Load()
Name(id='solution', ctx=Load())
Store()
Name(id='solution', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='solution', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='n_l', ctx=Load())
Add()
Num(n=2)
Load()
BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load()))
Sub()
Num(n=1)
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Add()
Num(n=1)
Load()
Load()
Load()
BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load()))
Mult()
List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load())
Invert()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])
Name(id='StateFn', ctx=Load())
Name(id='qc', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='observable', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='TensoredOp', ctx=Load())
BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))
Load()
Invert()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])
Name(id='StateFn', ctx=Load())
Name(id='circuit', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Store()
Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Load()
Load()
Name(id='ExpectationFactory', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Name(id='List', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='List', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Name(id='vector', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])
Load()
Load()
Name(id='vector_circuit', ctx=Load())
Load()
Name(id='vector', ctx=Load())
Div()
Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])
Name(id='list', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Name(id='matrix', ctx=Load())
Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load())
Index(value=Num(n=0))
Load()
Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load())
Index(value=Num(n=1))
Load()
Name(id='ValueError', ctx=Load())
Str(s='Input matrix must be square!')
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Mod()
Num(n=1)
Name(id='ValueError', ctx=Load())
Str(s='Input matrix dimension must be 2^n!')
Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load())
Name(id='matrix', ctx=Load())
Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())
Name(id='ValueError', ctx=Load())
Str(s='Input matrix must be hermitian!')
Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load())
Index(value=Num(n=0))
Load()
Num(n=2)
Pow()
Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='ValueError', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Load()
Str(s='Invalid type for matrix: ')
FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Str(s='.')
Name(id='matrix_circuit', ctx=Load())
Load()
Name(id='matrix_circuit', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Name(id='matrix_circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Mult()
Name(id='delta', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='num_values', ctx=Load())
Pow()
BinOp(left=Num(n=2), op=Div(), right=Num(n=3))
Num(n=2)
Mult()
Name(id='constant', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[])
Div()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[])
Name(id='breakpoints', ctx=Load())
Load()
Name(id='a', ctx=Load())
Mult()
BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load()))
Load()
Name(id='num_intervals', ctx=Load())
Sub()
Num(n=1)
Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load())
BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))
arg(arg='x', annotation=None)
Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load())
BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))
Load()
Load()
Load()
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Add()
Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Name(id='qa', ctx=Load())
Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None)
Load()
Load()
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Name(id='qb', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Name(id='reciprocal_circuit', ctx=Load())
Load()
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Add()
List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())
Name(id='qa', ctx=Load())
Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None)
Load()
Load()
Name(id='phase_estimation', ctx=Load())
Load()
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Add()
Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Name(id='qa', ctx=Load())
Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None)
Load()
Load()
Name(id='phase_estimation', ctx=Load())
Load()
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Name(id='qb', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Name(id='List', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='List', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Num(n=2)
Pow()
Name(id='n_l', ctx=Load())
Load()
Name(id='nl', ctx=Load())
Add()
Name(id='na', ctx=Load())
Name(id='zero_op', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='observable', ctx=Load())
Load()
Load()
Load()
Load()
Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Load()
Load()
BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load()))
Mult()
List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load())
Name(id='StateFn', ctx=Load())
Name(id='ob', ctx=Load())
Load()
Load()
Load()
Name(id='expectations', ctx=Load())
Load()
Num(n=0)
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='vector', ctx=Load())
Load()
Load()
Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load())
Name(id='vector', ctx=Load())
Load()
Name(id='range', ctx=Load())
Name(id='nb', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='matrix', ctx=Load())
Load()
Num(n=0)
Name(id='matrix', ctx=Load())
Load()
Num(n=1)
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load())
Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[])
Load()
Load()
Name(id='matrix', ctx=Load())
Load()
Num(n=0)
Name(id='vector_circuit', ctx=Load())
Load()
Load()
BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: '))
Add()
Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[])
Load()
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load())
BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))
Load()
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Load()
Num(n=2)
Div()
Num(n=3)
Load()
Load()
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2))
Name(id='np', ctx=Load())
Load()
Num(n=1)
Add()
BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
Num(n=5)
Load()
Load()
Num(n=5)
Pow()
Name(id='i', ctx=Load())
Load()
Name(id='breakpoints', ctx=Load())
Load()
Name(id='num_values', ctx=Load())
Sub()
Num(n=1)
Name(id='np', ctx=Load())
Load()
Name(id='constant', ctx=Load())
Div()
Name(id='x', ctx=Load())
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Name(id='qb', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='qf', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Load()
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Name(id='qb', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='LinearSystemObservable', ctx=Load())
Name(id='BaseOperator', ctx=Load())
Load()
List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='nl', ctx=Load())
Add()
Name(id='na', ctx=Load())
Name(id='zero_op', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load())
Load()
Load()
BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]))
Add()
Str(s='. Matrix dimension: ')
Name(id='str', ctx=Load())
Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='type', ctx=Load())
Name(id='matrix', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Name(id='kappa', ctx=Load())
Add()
Num(n=1)
Name(id='np', ctx=Load())
Load()
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load()))
Pow()
Num(n=2)
Load()
BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))
Div()
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())
Name(id='np', ctx=Load())
Load()
BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))
Div()
Name(id='a', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='matrix_circuit', ctx=Load())
Load()
USub()
Num(n=1)
Load()
Num(n=0)
Load()
Name(id='qf', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='reciprocal_circuit', ctx=Load())
Load()
Load()
Load()
Name(id='matrix_circuit', ctx=Load())
Load()
Load()
Load()
Name(id='LinearSystemObservable', ctx=Load())
Name(id='BaseOperator', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())
Load()
Name(id='QuantumCircuit', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Load()
List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Name(id='matrix', ctx=Load())
Load()
Num(n=0)
Name(id='matrix', ctx=Load())
Load()
Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: ')
Add()
Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Load()
Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load()))
Div()
Name(id='a', ctx=Load())
BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load()))
Mult()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))
Name(id='self', ctx=Load())
Load()
Load()
Name(id='num_values', ctx=Load())
Sub()
Num(n=1)
Load()
Load()
Load()
Load()
Num(n=0)
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='LinearSystemObservable', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='BaseOperator', ctx=Load()))
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='str', ctx=Load())
Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='matrix', ctx=Load())
Load()
Num(n=0)
Num(n=2)
Mult()
Name(id='constant', ctx=Load())
Load()
BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[]))
Mult()
Name(id='kappa', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load()))
Sub()
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())
Load()
Load()
Load()
Name(id='LinearSystemObservable', ctx=Load())
Load()
Name(id='BaseOperator', ctx=Load())
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='vector_circuit', ctx=Load())
Load()
Load()
Load()
Num(n=16.23)
Mult()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])
Load()
Num(n=2)
Mult()
Name(id='kappa', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='float', ctx=Load())
Name(id='np', ctx=Load())
Load()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Add()
BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[])
Pow()
Num(n=2)
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Pow()
Num(n=2)
Load()
Name(id='float', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
Name(id='r', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Module(body=[Expr(value=Str(s='The HHL algorithm.')), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Callable', asname=None), alias(name='Tuple', asname=None)], level=0), Import(names=[alias(name='numpy', asname='np')]), ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None), alias(name='AncillaRegister', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library', names=[alias(name='PhaseEstimation', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library.arithmetic.piecewise_chebyshev', names=[alias(name='PiecewiseChebyshev', asname=None)], level=0), ImportFrom(module='qiskit.circuit.library.arithmetic.exact_reciprocal', names=[alias(name='ExactReciprocal', asname=None)], level=0), ImportFrom(module='qiskit.opflow', names=[alias(name='Z', asname=None), alias(name='I', asname=None), alias(name='StateFn', asname=None), alias(name='TensoredOp', asname=None), alias(name='ExpectationBase', asname=None), alias(name='CircuitSampler', asname=None), alias(name='ListOp', asname=None), alias(name='ExpectationFactory', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.quantum_info.operators.base_operator', names=[alias(name='BaseOperator', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='linear_solver', names=[alias(name='LinearSolver', asname=None), alias(name='LinearSolverResult', asname=None)], level=1), ImportFrom(module='matrices.numpy_matrix', names=[alias(name='NumPyMatrix', asname=None)], level=1), ImportFrom(module='observables.linear_system_observable', names=[alias(name='LinearSystemObservable', asname=None)], level=1), ClassDef(name='HHL', bases=[Name(id='LinearSolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Systems of linear equations arise naturally in many real-life applications in a wide range\n    of areas, such as in the solution of Partial Differential Equations, the calibration of\n    financial models, fluid simulation or numerical field calculation. The problem can be defined\n    as, given a matrix :math:`A\\in\\mathbb{C}^{N\\times N}` and a vector\n    :math:`\\vec{b}\\in\\mathbb{C}^{N}`, find :math:`\\vec{x}\\in\\mathbb{C}^{N}` satisfying\n    :math:`A\\vec{x}=\\vec{b}`.\n\n    A system of linear equations is called :math:`s`-sparse if :math:`A` has at most :math:`s`\n    non-zero entries per row or column. Solving an :math:`s`-sparse system of size :math:`N` with\n    a classical computer requires :math:`\\mathcal{ O }(Ns\\kappa\\log(1/\\epsilon))` running time\n    using the conjugate gradient method. Here :math:`\\kappa` denotes the condition number of the\n    system and :math:`\\epsilon` the accuracy of the approximation.\n\n    The HHL is a quantum algorithm to estimate a function of the solution with running time\n    complexity of :math:`\\mathcal{ O }(\\log(N)s^{2}\\kappa^{2}/\\epsilon)` when\n    :math:`A` is a Hermitian matrix under the assumptions of efficient oracles for loading the\n    data, Hamiltonian simulation and computing a function of the solution. This is an exponential\n    speed up in the size of the system, however one crucial remark to keep in mind is that the\n    classical algorithm returns the full solution, while the HHL can only approximate functions of\n    the solution vector.\n\n    Examples:\n\n        .. jupyter-execute::\n\n            import numpy as np\n            from qiskit import QuantumCircuit\n            from qiskit.algorithms.linear_solvers.hhl import HHL\n            from qiskit.algorithms.linear_solvers.matrices import TridiagonalToeplitz\n            from qiskit.algorithms.linear_solvers.observables import MatrixFunctional\n\n            matrix = TridiagonalToeplitz(2, 1, 1 / 3, trotter_steps=2)\n            right_hand_side = [1.0, -2.1, 3.2, -4.3]\n            observable = MatrixFunctional(1, 1 / 2)\n            rhs = right_hand_side / np.linalg.norm(right_hand_side)\n\n            # Initial state circuit\n            num_qubits = matrix.num_state_qubits\n            qc = QuantumCircuit(num_qubits)\n            qc.isometry(rhs, list(range(num_qubits)), None)\n\n            hhl = HHL()\n            solution = hhl.solve(matrix, qc, observable)\n            approx_result = solution.observable\n\n    References:\n\n        [1]: Harrow, A. W., Hassidim, A., Lloyd, S. (2009).\n        Quantum algorithm for linear systems of equations.\n        `Phys. Rev. Lett. 103, 15 (2009), 1â€“15. <https://doi.org/10.1103/PhysRevLett.103.150502>`_\n\n        [2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2020).\n        Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n        `arXiv:2009.04484 <http://arxiv.org/abs/2009.04484>`_\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.01), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            epsilon: Error tolerance of the approximation to the solution, i.e. if :math:`x` is the\n                exact solution and :math:`\\tilde{x}` the one calculated by the algorithm, then\n                :math:`||x - \\tilde{x}|| \\le epsilon`.\n            expectation: The expectation converter applied to the expectation values before\n                evaluation. If None then PauliExpectation is used.\n            quantum_instance: Quantum Instance or Backend. If None, a Statevector calculation is\n                done.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_s', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=6))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Store())], value=NameConstant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Num(n=1))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=NameConstant(value=None), orelse=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n                If None, a Statevector calculation is done.\n        ')), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))])], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The scaling of the solution vector.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='scaling', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the new scaling of the solution vector.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=Name(id='scaling', ctx=Load()))], decorator_list=[Attribute(value=Name(id='scaling', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ExpectationBase', ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the expectation value algorithm.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_get_delta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n_l', annotation=Name(id='int', ctx=Load())), arg(arg='lambda_min', annotation=Name(id='float', ctx=Load())), arg(arg='lambda_max', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the scaling factor to represent exactly lambda_min on nl binary digits.\n\n        Args:\n            n_l: The number of qubits to represent the eigenvalues.\n            lambda_min: the smallest eigenvalue.\n            lambda_max: the largest eigenvalue.\n\n        Returns:\n            The value of the scaling factor.\n        ')), Assign(targets=[Name(id='formatstr', ctx=Store())], value=BinOp(left=BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])), op=Add(), right=Str(s='b'))), Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), ops=[Lt()], comparators=[Num(n=1e-07)]), body=[Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Num(n=1))], orelse=[]), Assign(targets=[Name(id='binstr', ctx=Store())], value=Subscript(value=Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())), Assign(targets=[Name(id='lamb_min_rep', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='char', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='binstr', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='lamb_min_rep', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))))], orelse=[]), Return(value=Name(id='lamb_min_rep', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='_calculate_norm', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qc', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the value of the euclidean norm of the solution.\n\n        Args:\n            qc: The quantum circuit preparing the solution x to the system.\n\n        Returns:\n            The value of the euclidean norm of the solution.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='qc', ctx=Load()), attr='num_ancillas', ctx=Load())), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))), Assign(targets=[Name(id='norm_2', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='_calculate_observable', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='solution', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Calculates the value of the observable(s) given.\n\n        Args:\n            solution: The quantum circuit preparing the solution x to the system.\n            observable: Information to be extracted from the solution.\n            observable_circuit: Circuit to be applied to the solution to extract information.\n            post_processing: Function to compute the value of the observable.\n\n        Returns:\n            The value of the observable(s) and the circuit results before post-processing as a\n             tuple.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='solution', ctx=Load()), attr='num_ancillas', ctx=Load())), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='post_processing', ctx=Store())], value=Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))]), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=True)), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='observable', ctx=Store())], value=List(elts=[Name(id='observable', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='expectations', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='circ', ctx=Store()), Name(id='obs', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='observable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ob', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='expectation_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='post_processing', ctx=Load()), args=[Name(id='expectation_results', ctx=Load()), Name(id='nb', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='result', ctx=Load()), Name(id='expectation_results', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='neg_vals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=True)]), body=[Expr(value=Str(s='Construct the HHL circuit.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            neg_vals: States whether the matrix has negative eigenvalues. If False the\n            computation becomes cheaper.\n\n        Returns:\n            The HHL circuit.\n\n        Raises:\n            ValueError: If the input is not in the correct format.\n            ValueError: If the type of the input matrix is not supported.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Name(id='vector', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='nf', ctx=Store())], value=Num(n=1)), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Name(id='matrix', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='tolerance')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load()))], orelse=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Num(n=1))]), Assign(targets=[Name(id='nl', ctx=Store())], value=BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[]), op=Add(), right=Name(id='neg_vals', ctx=Load()))), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='delta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load())))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Name(id='lambda_min', ctx=Load()))], orelse=[Assign(targets=[Name(id='delta', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))])), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))], orelse=[Assign(targets=[Name(id='num_values', ctx=Store())], value=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))), Assign(targets=[Name(id='constant', ctx=Store())], value=Name(id='delta', ctx=Load())), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[]))), Assign(targets=[Name(id='degree', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='num_intervals', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[])), Assign(targets=[Name(id='breakpoints', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[])), Assign(targets=[Name(id='na', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='qb', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ql', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nl', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qa', ctx=Store())], value=Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='qf', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nf', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector_circuit', ctx=Load()), Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])), Assign(targets=[Name(id='phase_estimation', ctx=Store())], value=Call(func=Name(id='PhaseEstimation', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='matrix_circuit', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))]), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Tries to solve the given linear system of equations.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            observable: Optional information to be extracted from the solution.\n                Default is the probability of success of the algorithm.\n            observable_circuit: Optional circuit to be applied to the solution to extract\n                information. Default is `None`.\n            post_processing: Optional function to compute the value of the observable.\n                Default is the raw value of measuring the observable.\n\n        Raises:\n            ValueError: If an invalid combination of observable, observable_circuit and\n                post_processing is passed.\n\n        Returns:\n            The result object containing information about the solution vector of the linear\n            system.\n        ')), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)], orelse=[])], orelse=[]), Assign(targets=[Name(id='solution', ctx=Store())], value=Call(func=Name(id='LinearSolverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='vector', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='euclidean_norm', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='solution', ctx=Load()))], decorator_list=[], returns=Name(id='LinearSolverResult', ctx=Load()))], decorator_list=[])])
Expr(value=Str(s='The HHL algorithm.'))
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None), alias(name='List', asname=None), alias(name='Callable', asname=None), alias(name='Tuple', asname=None)], level=0)
Import(names=[alias(name='numpy', asname='np')])
ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None), alias(name='QuantumRegister', asname=None), alias(name='AncillaRegister', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library', names=[alias(name='PhaseEstimation', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library.arithmetic.piecewise_chebyshev', names=[alias(name='PiecewiseChebyshev', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.library.arithmetic.exact_reciprocal', names=[alias(name='ExactReciprocal', asname=None)], level=0)
ImportFrom(module='qiskit.opflow', names=[alias(name='Z', asname=None), alias(name='I', asname=None), alias(name='StateFn', asname=None), alias(name='TensoredOp', asname=None), alias(name='ExpectationBase', asname=None), alias(name='CircuitSampler', asname=None), alias(name='ListOp', asname=None), alias(name='ExpectationFactory', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.quantum_info.operators.base_operator', names=[alias(name='BaseOperator', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='linear_solver', names=[alias(name='LinearSolver', asname=None), alias(name='LinearSolverResult', asname=None)], level=1)
ImportFrom(module='matrices.numpy_matrix', names=[alias(name='NumPyMatrix', asname=None)], level=1)
ImportFrom(module='observables.linear_system_observable', names=[alias(name='LinearSystemObservable', asname=None)], level=1)
ClassDef(name='HHL', bases=[Name(id='LinearSolver', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Systems of linear equations arise naturally in many real-life applications in a wide range\n    of areas, such as in the solution of Partial Differential Equations, the calibration of\n    financial models, fluid simulation or numerical field calculation. The problem can be defined\n    as, given a matrix :math:`A\\in\\mathbb{C}^{N\\times N}` and a vector\n    :math:`\\vec{b}\\in\\mathbb{C}^{N}`, find :math:`\\vec{x}\\in\\mathbb{C}^{N}` satisfying\n    :math:`A\\vec{x}=\\vec{b}`.\n\n    A system of linear equations is called :math:`s`-sparse if :math:`A` has at most :math:`s`\n    non-zero entries per row or column. Solving an :math:`s`-sparse system of size :math:`N` with\n    a classical computer requires :math:`\\mathcal{ O }(Ns\\kappa\\log(1/\\epsilon))` running time\n    using the conjugate gradient method. Here :math:`\\kappa` denotes the condition number of the\n    system and :math:`\\epsilon` the accuracy of the approximation.\n\n    The HHL is a quantum algorithm to estimate a function of the solution with running time\n    complexity of :math:`\\mathcal{ O }(\\log(N)s^{2}\\kappa^{2}/\\epsilon)` when\n    :math:`A` is a Hermitian matrix under the assumptions of efficient oracles for loading the\n    data, Hamiltonian simulation and computing a function of the solution. This is an exponential\n    speed up in the size of the system, however one crucial remark to keep in mind is that the\n    classical algorithm returns the full solution, while the HHL can only approximate functions of\n    the solution vector.\n\n    Examples:\n\n        .. jupyter-execute::\n\n            import numpy as np\n            from qiskit import QuantumCircuit\n            from qiskit.algorithms.linear_solvers.hhl import HHL\n            from qiskit.algorithms.linear_solvers.matrices import TridiagonalToeplitz\n            from qiskit.algorithms.linear_solvers.observables import MatrixFunctional\n\n            matrix = TridiagonalToeplitz(2, 1, 1 / 3, trotter_steps=2)\n            right_hand_side = [1.0, -2.1, 3.2, -4.3]\n            observable = MatrixFunctional(1, 1 / 2)\n            rhs = right_hand_side / np.linalg.norm(right_hand_side)\n\n            # Initial state circuit\n            num_qubits = matrix.num_state_qubits\n            qc = QuantumCircuit(num_qubits)\n            qc.isometry(rhs, list(range(num_qubits)), None)\n\n            hhl = HHL()\n            solution = hhl.solve(matrix, qc, observable)\n            approx_result = solution.observable\n\n    References:\n\n        [1]: Harrow, A. W., Hassidim, A., Lloyd, S. (2009).\n        Quantum algorithm for linear systems of equations.\n        `Phys. Rev. Lett. 103, 15 (2009), 1â€“15. <https://doi.org/10.1103/PhysRevLett.103.150502>`_\n\n        [2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2020).\n        Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n        `arXiv:2009.04484 <http://arxiv.org/abs/2009.04484>`_\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.01), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            epsilon: Error tolerance of the approximation to the solution, i.e. if :math:`x` is the\n                exact solution and :math:`\\tilde{x}` the one calculated by the algorithm, then\n                :math:`||x - \\tilde{x}|| \\le epsilon`.\n            expectation: The expectation converter applied to the expectation values before\n                evaluation. If None then PauliExpectation is used.\n            quantum_instance: Quantum Instance or Backend. If None, a Statevector calculation is\n                done.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_s', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=6))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Store())], value=NameConstant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Num(n=1))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=NameConstant(value=None), orelse=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())), FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n                If None, a Statevector calculation is done.\n        ')), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))])], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The scaling of the solution vector.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load())), FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='scaling', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the new scaling of the solution vector.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=Name(id='scaling', ctx=Load()))], decorator_list=[Attribute(value=Name(id='scaling', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ExpectationBase', ctx=Load())), FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the expectation value algorithm.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None)), FunctionDef(name='_get_delta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n_l', annotation=Name(id='int', ctx=Load())), arg(arg='lambda_min', annotation=Name(id='float', ctx=Load())), arg(arg='lambda_max', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the scaling factor to represent exactly lambda_min on nl binary digits.\n\n        Args:\n            n_l: The number of qubits to represent the eigenvalues.\n            lambda_min: the smallest eigenvalue.\n            lambda_max: the largest eigenvalue.\n\n        Returns:\n            The value of the scaling factor.\n        ')), Assign(targets=[Name(id='formatstr', ctx=Store())], value=BinOp(left=BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])), op=Add(), right=Str(s='b'))), Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), ops=[Lt()], comparators=[Num(n=1e-07)]), body=[Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Num(n=1))], orelse=[]), Assign(targets=[Name(id='binstr', ctx=Store())], value=Subscript(value=Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())), Assign(targets=[Name(id='lamb_min_rep', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='char', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='binstr', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='lamb_min_rep', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))))], orelse=[]), Return(value=Name(id='lamb_min_rep', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='_calculate_norm', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qc', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the value of the euclidean norm of the solution.\n\n        Args:\n            qc: The quantum circuit preparing the solution x to the system.\n\n        Returns:\n            The value of the euclidean norm of the solution.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='qc', ctx=Load()), attr='num_ancillas', ctx=Load())), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))), Assign(targets=[Name(id='norm_2', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load())), FunctionDef(name='_calculate_observable', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='solution', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Calculates the value of the observable(s) given.\n\n        Args:\n            solution: The quantum circuit preparing the solution x to the system.\n            observable: Information to be extracted from the solution.\n            observable_circuit: Circuit to be applied to the solution to extract information.\n            post_processing: Function to compute the value of the observable.\n\n        Returns:\n            The value of the observable(s) and the circuit results before post-processing as a\n             tuple.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='solution', ctx=Load()), attr='num_ancillas', ctx=Load())), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='post_processing', ctx=Store())], value=Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))]), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=True)), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='observable', ctx=Store())], value=List(elts=[Name(id='observable', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='expectations', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='circ', ctx=Store()), Name(id='obs', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='observable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ob', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='expectation_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='post_processing', ctx=Load()), args=[Name(id='expectation_results', ctx=Load()), Name(id='nb', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='result', ctx=Load()), Name(id='expectation_results', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='neg_vals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=True)]), body=[Expr(value=Str(s='Construct the HHL circuit.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            neg_vals: States whether the matrix has negative eigenvalues. If False the\n            computation becomes cheaper.\n\n        Returns:\n            The HHL circuit.\n\n        Raises:\n            ValueError: If the input is not in the correct format.\n            ValueError: If the type of the input matrix is not supported.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Name(id='vector', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='nf', ctx=Store())], value=Num(n=1)), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Name(id='matrix', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='tolerance')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load()))], orelse=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Num(n=1))]), Assign(targets=[Name(id='nl', ctx=Store())], value=BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[]), op=Add(), right=Name(id='neg_vals', ctx=Load()))), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='delta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load())))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Name(id='lambda_min', ctx=Load()))], orelse=[Assign(targets=[Name(id='delta', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))])), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))], orelse=[Assign(targets=[Name(id='num_values', ctx=Store())], value=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))), Assign(targets=[Name(id='constant', ctx=Store())], value=Name(id='delta', ctx=Load())), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[]))), Assign(targets=[Name(id='degree', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='num_intervals', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[])), Assign(targets=[Name(id='breakpoints', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[])), Assign(targets=[Name(id='na', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='qb', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ql', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nl', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qa', ctx=Store())], value=Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='qf', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nf', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector_circuit', ctx=Load()), Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])), Assign(targets=[Name(id='phase_estimation', ctx=Store())], value=Call(func=Name(id='PhaseEstimation', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='matrix_circuit', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))]), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Tries to solve the given linear system of equations.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            observable: Optional information to be extracted from the solution.\n                Default is the probability of success of the algorithm.\n            observable_circuit: Optional circuit to be applied to the solution to extract\n                information. Default is `None`.\n            post_processing: Optional function to compute the value of the observable.\n                Default is the raw value of measuring the observable.\n\n        Raises:\n            ValueError: If an invalid combination of observable, observable_circuit and\n                post_processing is passed.\n\n        Returns:\n            The result object containing information about the solution vector of the linear\n            system.\n        ')), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)], orelse=[])], orelse=[]), Assign(targets=[Name(id='solution', ctx=Store())], value=Call(func=Name(id='LinearSolverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='vector', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='euclidean_norm', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='solution', ctx=Load()))], decorator_list=[], returns=Name(id='LinearSolverResult', ctx=Load()))], decorator_list=[])
Str(s='The HHL algorithm.')
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='List', asname=None)
alias(name='Callable', asname=None)
alias(name='Tuple', asname=None)
alias(name='numpy', asname='np')
alias(name='QuantumCircuit', asname=None)
alias(name='QuantumRegister', asname=None)
alias(name='AncillaRegister', asname=None)
alias(name='PhaseEstimation', asname=None)
alias(name='PiecewiseChebyshev', asname=None)
alias(name='ExactReciprocal', asname=None)
alias(name='Z', asname=None)
alias(name='I', asname=None)
alias(name='StateFn', asname=None)
alias(name='TensoredOp', asname=None)
alias(name='ExpectationBase', asname=None)
alias(name='CircuitSampler', asname=None)
alias(name='ListOp', asname=None)
alias(name='ExpectationFactory', asname=None)
alias(name='Backend', asname=None)
alias(name='BaseOperator', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='LinearSolver', asname=None)
alias(name='LinearSolverResult', asname=None)
alias(name='NumPyMatrix', asname=None)
alias(name='LinearSystemObservable', asname=None)
Name(id='LinearSolver', ctx=Load())
Expr(value=Str(s='Systems of linear equations arise naturally in many real-life applications in a wide range\n    of areas, such as in the solution of Partial Differential Equations, the calibration of\n    financial models, fluid simulation or numerical field calculation. The problem can be defined\n    as, given a matrix :math:`A\\in\\mathbb{C}^{N\\times N}` and a vector\n    :math:`\\vec{b}\\in\\mathbb{C}^{N}`, find :math:`\\vec{x}\\in\\mathbb{C}^{N}` satisfying\n    :math:`A\\vec{x}=\\vec{b}`.\n\n    A system of linear equations is called :math:`s`-sparse if :math:`A` has at most :math:`s`\n    non-zero entries per row or column. Solving an :math:`s`-sparse system of size :math:`N` with\n    a classical computer requires :math:`\\mathcal{ O }(Ns\\kappa\\log(1/\\epsilon))` running time\n    using the conjugate gradient method. Here :math:`\\kappa` denotes the condition number of the\n    system and :math:`\\epsilon` the accuracy of the approximation.\n\n    The HHL is a quantum algorithm to estimate a function of the solution with running time\n    complexity of :math:`\\mathcal{ O }(\\log(N)s^{2}\\kappa^{2}/\\epsilon)` when\n    :math:`A` is a Hermitian matrix under the assumptions of efficient oracles for loading the\n    data, Hamiltonian simulation and computing a function of the solution. This is an exponential\n    speed up in the size of the system, however one crucial remark to keep in mind is that the\n    classical algorithm returns the full solution, while the HHL can only approximate functions of\n    the solution vector.\n\n    Examples:\n\n        .. jupyter-execute::\n\n            import numpy as np\n            from qiskit import QuantumCircuit\n            from qiskit.algorithms.linear_solvers.hhl import HHL\n            from qiskit.algorithms.linear_solvers.matrices import TridiagonalToeplitz\n            from qiskit.algorithms.linear_solvers.observables import MatrixFunctional\n\n            matrix = TridiagonalToeplitz(2, 1, 1 / 3, trotter_steps=2)\n            right_hand_side = [1.0, -2.1, 3.2, -4.3]\n            observable = MatrixFunctional(1, 1 / 2)\n            rhs = right_hand_side / np.linalg.norm(right_hand_side)\n\n            # Initial state circuit\n            num_qubits = matrix.num_state_qubits\n            qc = QuantumCircuit(num_qubits)\n            qc.isometry(rhs, list(range(num_qubits)), None)\n\n            hhl = HHL()\n            solution = hhl.solve(matrix, qc, observable)\n            approx_result = solution.observable\n\n    References:\n\n        [1]: Harrow, A. W., Hassidim, A., Lloyd, S. (2009).\n        Quantum algorithm for linear systems of equations.\n        `Phys. Rev. Lett. 103, 15 (2009), 1â€“15. <https://doi.org/10.1103/PhysRevLett.103.150502>`_\n\n        [2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2020).\n        Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n        `arXiv:2009.04484 <http://arxiv.org/abs/2009.04484>`_\n\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.01), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            epsilon: Error tolerance of the approximation to the solution, i.e. if :math:`x` is the\n                exact solution and :math:`\\tilde{x}` the one calculated by the algorithm, then\n                :math:`||x - \\tilde{x}|| \\le epsilon`.\n            expectation: The expectation converter applied to the expectation values before\n                evaluation. If None then PauliExpectation is used.\n            quantum_instance: Quantum Instance or Backend. If None, a Statevector calculation is\n                done.\n        ')), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_s', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=6))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Store())], value=NameConstant(value=True)), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Num(n=1))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')), Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=NameConstant(value=None), orelse=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())))], decorator_list=[Name(id='property', ctx=Load())], returns=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load()))
FunctionDef(name='quantum_instance', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n                If None, a Statevector calculation is done.\n        ')), If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))])], decorator_list=[Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The scaling of the solution vector.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='float', ctx=Load()))
FunctionDef(name='scaling', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='scaling', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the new scaling of the solution vector.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=Name(id='scaling', ctx=Load()))], decorator_list=[Attribute(value=Name(id='scaling', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')), Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))], decorator_list=[Name(id='property', ctx=Load())], returns=Name(id='ExpectationBase', ctx=Load()))
FunctionDef(name='expectation', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Set the expectation value algorithm.')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))], decorator_list=[Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())], returns=NameConstant(value=None))
FunctionDef(name='_get_delta', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='n_l', annotation=Name(id='int', ctx=Load())), arg(arg='lambda_min', annotation=Name(id='float', ctx=Load())), arg(arg='lambda_max', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the scaling factor to represent exactly lambda_min on nl binary digits.\n\n        Args:\n            n_l: The number of qubits to represent the eigenvalues.\n            lambda_min: the smallest eigenvalue.\n            lambda_max: the largest eigenvalue.\n\n        Returns:\n            The value of the scaling factor.\n        ')), Assign(targets=[Name(id='formatstr', ctx=Store())], value=BinOp(left=BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])), op=Add(), right=Str(s='b'))), Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))], keywords=[])), If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), ops=[Lt()], comparators=[Num(n=1e-07)]), body=[Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Num(n=1))], orelse=[]), Assign(targets=[Name(id='binstr', ctx=Store())], value=Subscript(value=Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())), Assign(targets=[Name(id='lamb_min_rep', ctx=Store())], value=Num(n=0)), For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='char', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='binstr', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='lamb_min_rep', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))))], orelse=[]), Return(value=Name(id='lamb_min_rep', ctx=Load()))], decorator_list=[], returns=Name(id='float', ctx=Load()))
FunctionDef(name='_calculate_norm', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='qc', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Calculates the value of the euclidean norm of the solution.\n\n        Args:\n            qc: The quantum circuit preparing the solution x to the system.\n\n        Returns:\n            The value of the euclidean norm of the solution.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='qc', ctx=Load()), attr='num_ancillas', ctx=Load())), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))), Assign(targets=[Name(id='norm_2', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))], keywords=[]))], decorator_list=[], returns=Name(id='float', ctx=Load()))
FunctionDef(name='_calculate_observable', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='solution', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Calculates the value of the observable(s) given.\n\n        Args:\n            solution: The quantum circuit preparing the solution x to the system.\n            observable: Information to be extracted from the solution.\n            observable_circuit: Circuit to be applied to the solution to extract information.\n            post_processing: Function to compute the value of the observable.\n\n        Returns:\n            The value of the observable(s) and the circuit results before post-processing as a\n             tuple.\n        ')), Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='solution', ctx=Load()), attr='num_ancillas', ctx=Load())), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='post_processing', ctx=Store())], value=Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))]), Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))), Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=True)), If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='observable', ctx=Store())], value=List(elts=[Name(id='observable', ctx=Load())], ctx=Load()))], orelse=[]), Assign(targets=[Name(id='expectations', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Tuple(elts=[Name(id='circ', ctx=Store()), Name(id='obs', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='observable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ob', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[]), If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='expectation_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='post_processing', ctx=Load()), args=[Name(id='expectation_results', ctx=Load()), Name(id='nb', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Name(id='result', ctx=Load()), Name(id='expectation_results', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='neg_vals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=True)]), body=[Expr(value=Str(s='Construct the HHL circuit.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            neg_vals: States whether the matrix has negative eigenvalues. If False the\n            computation becomes cheaper.\n\n        Returns:\n            The HHL circuit.\n\n        Raises:\n            ValueError: If the input is not in the correct format.\n            ValueError: If the type of the input matrix is not supported.\n        ')), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Name(id='vector', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))], orelse=[])]), Assign(targets=[Name(id='nf', ctx=Store())], value=Num(n=1)), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Name(id='matrix', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)])]), If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='tolerance')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load()))], orelse=[]), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load()))], orelse=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Num(n=1))]), Assign(targets=[Name(id='nl', ctx=Store())], value=BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[]), op=Add(), right=Name(id='neg_vals', ctx=Load()))), If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='delta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load())))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Name(id='lambda_min', ctx=Load()))], orelse=[Assign(targets=[Name(id='delta', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))])), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))], orelse=[Assign(targets=[Name(id='num_values', ctx=Store())], value=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))), Assign(targets=[Name(id='constant', ctx=Store())], value=Name(id='delta', ctx=Load())), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[]))), Assign(targets=[Name(id='degree', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='num_intervals', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[])), Assign(targets=[Name(id='breakpoints', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[])), Assign(targets=[Name(id='na', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[]))]), Assign(targets=[Name(id='qb', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='ql', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nl', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qa', ctx=Store())], value=Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='qf', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nf', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))]), Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector_circuit', ctx=Load()), Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])), Assign(targets=[Name(id='phase_estimation', ctx=Store())], value=Call(func=Name(id='PhaseEstimation', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='matrix_circuit', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))]), If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))]), Return(value=Name(id='qc', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='solve', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Tries to solve the given linear system of equations.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            observable: Optional information to be extracted from the solution.\n                Default is the probability of success of the algorithm.\n            observable_circuit: Optional circuit to be applied to the solution to extract\n                information. Default is `None`.\n            post_processing: Optional function to compute the value of the observable.\n                Default is the raw value of measuring the observable.\n\n        Raises:\n            ValueError: If an invalid combination of observable, observable_circuit and\n                post_processing is passed.\n\n        Returns:\n            The result object containing information about the solution vector of the linear\n            system.\n        ')), If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)], orelse=[])], orelse=[]), Assign(targets=[Name(id='solution', ctx=Store())], value=Call(func=Name(id='LinearSolverResult', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='vector', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='euclidean_norm', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())], keywords=[])), If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='solution', ctx=Load()))], decorator_list=[], returns=Name(id='LinearSolverResult', ctx=Load()))
Load()
Str(s='Systems of linear equations arise naturally in many real-life applications in a wide range\n    of areas, such as in the solution of Partial Differential Equations, the calibration of\n    financial models, fluid simulation or numerical field calculation. The problem can be defined\n    as, given a matrix :math:`A\\in\\mathbb{C}^{N\\times N}` and a vector\n    :math:`\\vec{b}\\in\\mathbb{C}^{N}`, find :math:`\\vec{x}\\in\\mathbb{C}^{N}` satisfying\n    :math:`A\\vec{x}=\\vec{b}`.\n\n    A system of linear equations is called :math:`s`-sparse if :math:`A` has at most :math:`s`\n    non-zero entries per row or column. Solving an :math:`s`-sparse system of size :math:`N` with\n    a classical computer requires :math:`\\mathcal{ O }(Ns\\kappa\\log(1/\\epsilon))` running time\n    using the conjugate gradient method. Here :math:`\\kappa` denotes the condition number of the\n    system and :math:`\\epsilon` the accuracy of the approximation.\n\n    The HHL is a quantum algorithm to estimate a function of the solution with running time\n    complexity of :math:`\\mathcal{ O }(\\log(N)s^{2}\\kappa^{2}/\\epsilon)` when\n    :math:`A` is a Hermitian matrix under the assumptions of efficient oracles for loading the\n    data, Hamiltonian simulation and computing a function of the solution. This is an exponential\n    speed up in the size of the system, however one crucial remark to keep in mind is that the\n    classical algorithm returns the full solution, while the HHL can only approximate functions of\n    the solution vector.\n\n    Examples:\n\n        .. jupyter-execute::\n\n            import numpy as np\n            from qiskit import QuantumCircuit\n            from qiskit.algorithms.linear_solvers.hhl import HHL\n            from qiskit.algorithms.linear_solvers.matrices import TridiagonalToeplitz\n            from qiskit.algorithms.linear_solvers.observables import MatrixFunctional\n\n            matrix = TridiagonalToeplitz(2, 1, 1 / 3, trotter_steps=2)\n            right_hand_side = [1.0, -2.1, 3.2, -4.3]\n            observable = MatrixFunctional(1, 1 / 2)\n            rhs = right_hand_side / np.linalg.norm(right_hand_side)\n\n            # Initial state circuit\n            num_qubits = matrix.num_state_qubits\n            qc = QuantumCircuit(num_qubits)\n            qc.isometry(rhs, list(range(num_qubits)), None)\n\n            hhl = HHL()\n            solution = hhl.solve(matrix, qc, observable)\n            approx_result = solution.observable\n\n    References:\n\n        [1]: Harrow, A. W., Hassidim, A., Lloyd, S. (2009).\n        Quantum algorithm for linear systems of equations.\n        `Phys. Rev. Lett. 103, 15 (2009), 1â€“15. <https://doi.org/10.1103/PhysRevLett.103.150502>`_\n\n        [2]: Carrera Vazquez, A., Hiptmair, R., & Woerner, S. (2020).\n        Enhancing the Quantum Linear Systems Algorithm using Richardson Extrapolation.\n        `arXiv:2009.04484 <http://arxiv.org/abs/2009.04484>`_\n\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='epsilon', annotation=Name(id='float', ctx=Load())), arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[Num(n=0.01), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='\n        Args:\n            epsilon: Error tolerance of the approximation to the solution, i.e. if :math:`x` is the\n                exact solution and :math:`\\tilde{x}` the one calculated by the algorithm, then\n                :math:`||x - \\tilde{x}|| \\le epsilon`.\n            expectation: The expectation converter applied to the expectation values before\n                evaluation. If None then PauliExpectation is used.\n            quantum_instance: Quantum Instance or Backend. If None, a Statevector calculation is\n                done.\n        '))
Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())], value=Name(id='epsilon', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3)))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_s', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3)))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Store())], value=BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=6)))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Store())], value=NameConstant(value=True))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Num(n=1))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        '))
Return(value=IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=NameConstant(value=None), orelse=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())))
Name(id='property', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumInstance', ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n                If None, a Statevector calculation is done.\n        '))
If(test=Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))])
Attribute(value=Name(id='quantum_instance', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='The scaling of the solution vector.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='scaling', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the new scaling of the solution vector.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())], value=Name(id='scaling', ctx=Load()))
Attribute(value=Name(id='scaling', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.'))
Return(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()))
Name(id='property', ctx=Load())
Name(id='ExpectationBase', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Set the expectation value algorithm.'))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Name(id='expectation', ctx=Load()))
Attribute(value=Name(id='expectation', ctx=Load()), attr='setter', ctx=Load())
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='n_l', annotation=Name(id='int', ctx=Load())), arg(arg='lambda_min', annotation=Name(id='float', ctx=Load())), arg(arg='lambda_max', annotation=Name(id='float', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Calculates the scaling factor to represent exactly lambda_min on nl binary digits.\n\n        Args:\n            n_l: The number of qubits to represent the eigenvalues.\n            lambda_min: the smallest eigenvalue.\n            lambda_max: the largest eigenvalue.\n\n        Returns:\n            The value of the scaling factor.\n        '))
Assign(targets=[Name(id='formatstr', ctx=Store())], value=BinOp(left=BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])), op=Add(), right=Str(s='b')))
Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))], keywords=[]))
If(test=Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), ops=[Lt()], comparators=[Num(n=1e-07)]), body=[Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Num(n=1))], orelse=[])
Assign(targets=[Name(id='binstr', ctx=Store())], value=Subscript(value=Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load()))
Assign(targets=[Name(id='lamb_min_rep', ctx=Store())], value=Num(n=0))
For(target=Tuple(elts=[Name(id='i', ctx=Store()), Name(id='char', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='binstr', ctx=Load())], keywords=[]), body=[AugAssign(target=Name(id='lamb_min_rep', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))))], orelse=[])
Return(value=Name(id='lamb_min_rep', ctx=Load()))
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='qc', annotation=Name(id='QuantumCircuit', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Calculates the value of the euclidean norm of the solution.\n\n        Args:\n            qc: The quantum circuit preparing the solution x to the system.\n\n        Returns:\n            The value of the euclidean norm of the solution.\n        '))
Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load()))
Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load()))
Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='qc', ctx=Load()), attr='num_ancillas', ctx=Load()))
Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load()))))
Assign(targets=[Name(id='norm_2', ctx=Store())], value=Call(func=Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load()), args=[], keywords=[]))
Return(value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))], keywords=[]))
Name(id='float', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='solution', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='Calculates the value of the observable(s) given.\n\n        Args:\n            solution: The quantum circuit preparing the solution x to the system.\n            observable: Information to be extracted from the solution.\n            observable_circuit: Circuit to be applied to the solution to extract information.\n            post_processing: Function to compute the value of the observable.\n\n        Returns:\n            The value of the observable(s) and the circuit results before post-processing as a\n             tuple.\n        '))
Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load()))
Assign(targets=[Name(id='nl', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load()))
Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='solution', ctx=Load()), attr='num_ancillas', ctx=Load()))
If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Assign(targets=[Name(id='post_processing', ctx=Store())], value=Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load())), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))], orelse=[])], orelse=[Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))])
Assign(targets=[Name(id='zero_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Name(id='one_op', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2)))
Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=True))
If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])), body=[Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=False)), Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load())), Assign(targets=[Name(id='observable', ctx=Store())], value=List(elts=[Name(id='observable', ctx=Load())], ctx=Load()))], orelse=[])
Assign(targets=[Name(id='expectations', ctx=Store())], value=List(elts=[], ctx=Load()))
For(target=Tuple(elts=[Name(id='circ', ctx=Store()), Name(id='obs', ctx=Store())], ctx=Store()), iter=Call(func=Name(id='zip', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='observable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])), Assign(targets=[Name(id='ob', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load()))), Expr(value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[]))], orelse=[])
If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))])
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])])
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='expectation_results', ctx=Store())], value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Name(id='post_processing', ctx=Load()), args=[Name(id='expectation_results', ctx=Load()), Name(id='nb', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())], keywords=[]))
Return(value=Tuple(elts=[Name(id='result', ctx=Load()), Name(id='expectation_results', ctx=Load())], ctx=Load()))
Subscript(value=Name(id='Tuple', ctx=Load()), slice=Index(value=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='neg_vals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=True)])
Expr(value=Str(s='Construct the HHL circuit.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            neg_vals: States whether the matrix has negative eigenvalues. If False the\n            computation becomes cheaper.\n\n        Returns:\n            The HHL circuit.\n\n        Raises:\n            ValueError: If the input is not in the correct format.\n            ValueError: If the type of the input matrix is not supported.\n        '))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Name(id='vector', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))], orelse=[])])
Assign(targets=[Name(id='nf', ctx=Store())], value=Num(n=1))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Name(id='matrix', ctx=Load()))], orelse=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)])])
If(test=Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='tolerance')], keywords=[]), body=[Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load()))], orelse=[])
If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load()))], orelse=[Assign(targets=[Name(id='kappa', ctx=Store())], value=Num(n=1))])
Assign(targets=[Name(id='nl', ctx=Store())], value=BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[]), op=Add(), right=Name(id='neg_vals', ctx=Load())))
If(test=BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='delta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load())))), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Name(id='lambda_min', ctx=Load()))], orelse=[Assign(targets=[Name(id='delta', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[]))])
If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))])), Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))], orelse=[Assign(targets=[Name(id='num_values', ctx=Store())], value=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))), Assign(targets=[Name(id='constant', ctx=Store())], value=Name(id='delta', ctx=Load())), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[])), Assign(targets=[Name(id='r', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[]))), Assign(targets=[Name(id='degree', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='num_intervals', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[])), Assign(targets=[Name(id='breakpoints', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])], orelse=[]), Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[])), Assign(targets=[Name(id='na', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[]))])
Assign(targets=[Name(id='qb', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='ql', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nl', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qa', ctx=Store())], value=Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='qf', ctx=Store())], value=Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nf', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))], orelse=[Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector_circuit', ctx=Load()), Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[]))
Assign(targets=[Name(id='phase_estimation', ctx=Store())], value=Call(func=Name(id='PhaseEstimation', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='matrix_circuit', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))])
If(test=Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))])
If(test=Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))], orelse=[Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))])
Return(value=Name(id='qc', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())), arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())), arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='Tries to solve the given linear system of equations.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            observable: Optional information to be extracted from the solution.\n                Default is the probability of success of the algorithm.\n            observable_circuit: Optional circuit to be applied to the solution to extract\n                information. Default is `None`.\n            post_processing: Optional function to compute the value of the observable.\n                Default is the raw value of measuring the observable.\n\n        Raises:\n            ValueError: If an invalid combination of observable, observable_circuit and\n                post_processing is passed.\n\n        Returns:\n            The result object containing information about the solution vector of the linear\n            system.\n        '))
If(test=Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)], orelse=[])], orelse=[])
Assign(targets=[Name(id='solution', ctx=Store())], value=Call(func=Name(id='LinearSolverResult', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='vector', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='solution', ctx=Load()), attr='euclidean_norm', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())], keywords=[]))
If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Assign(targets=[Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[]))], orelse=[])
Return(value=Name(id='solution', ctx=Load()))
Name(id='LinearSolverResult', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='epsilon', annotation=Name(id='float', ctx=Load()))
arg(arg='expectation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Num(n=0.01)
NameConstant(value=None)
NameConstant(value=None)
Str(s='\n        Args:\n            epsilon: Error tolerance of the approximation to the solution, i.e. if :math:`x` is the\n                exact solution and :math:`\\tilde{x}` the one calculated by the algorithm, then\n                :math:`||x - \\tilde{x}|| \\le epsilon`.\n            expectation: The expectation converter applied to the expectation values before\n                evaluation. If None then PauliExpectation is used.\n            quantum_instance: Quantum Instance or Backend. If None, a Statevector calculation is\n                done.\n        ')
Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon', ctx=Store())
Name(id='epsilon', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Store())
BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_s', ctx=Store())
BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=3))
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Store())
BinOp(left=Name(id='epsilon', ctx=Load()), op=Div(), right=Num(n=6))
Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
Name(id='expectation', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Store())
NameConstant(value=True)
Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())
Num(n=1)
arg(arg='self', annotation=None)
Str(s='Get the quantum instance.\n\n        Returns:\n            The quantum instance used to run this algorithm.\n        ')
IfExp(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)]), body=NameConstant(value=None), orelse=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumInstance', ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
Str(s='Set quantum instance.\n\n        Args:\n            quantum_instance: The quantum instance used to run this algorithm.\n                If None, a Statevector calculation is done.\n        ')
Compare(left=Name(id='quantum_instance', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())], value=NameConstant(value=None))
Name(id='quantum_instance', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='The scaling of the solution vector.')
Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='scaling', annotation=Name(id='float', ctx=Load()))
Str(s='Set the new scaling of the solution vector.')
Attribute(value=Name(id='self', ctx=Load()), attr='_scaling', ctx=Store())
Name(id='scaling', ctx=Load())
Name(id='scaling', ctx=Load())
Load()
arg(arg='self', annotation=None)
Str(s='The expectation value algorithm used to construct the expectation measurement from\n        the observable.')
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load())
Load()
Load()
arg(arg='self', annotation=None)
arg(arg='expectation', annotation=Name(id='ExpectationBase', ctx=Load()))
Str(s='Set the expectation value algorithm.')
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
Name(id='expectation', ctx=Load())
Name(id='expectation', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='n_l', annotation=Name(id='int', ctx=Load()))
arg(arg='lambda_min', annotation=Name(id='float', ctx=Load()))
arg(arg='lambda_max', annotation=Name(id='float', ctx=Load()))
Str(s='Calculates the scaling factor to represent exactly lambda_min on nl binary digits.\n\n        Args:\n            n_l: The number of qubits to represent the eigenvalues.\n            lambda_min: the smallest eigenvalue.\n            lambda_max: the largest eigenvalue.\n\n        Returns:\n            The value of the scaling factor.\n        ')
Name(id='formatstr', ctx=Store())
BinOp(left=BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])), op=Add(), right=Str(s='b'))
Name(id='lambda_min_tilde', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))], keywords=[])
Compare(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]), ops=[Lt()], comparators=[Num(n=1e-07)])
Assign(targets=[Name(id='lambda_min_tilde', ctx=Store())], value=Num(n=1))
Name(id='binstr', ctx=Store())
Subscript(value=Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[]), slice=Slice(lower=Num(n=2), upper=None, step=None), ctx=Load())
Name(id='lamb_min_rep', ctx=Store())
Num(n=0)
Tuple(elts=[Name(id='i', ctx=Store()), Name(id='char', ctx=Store())], ctx=Store())
Call(func=Name(id='enumerate', ctx=Load()), args=[Name(id='binstr', ctx=Load())], keywords=[])
AugAssign(target=Name(id='lamb_min_rep', ctx=Store()), op=Add(), value=BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))))
Name(id='lamb_min_rep', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='qc', annotation=Name(id='QuantumCircuit', ctx=Load()))
Str(s='Calculates the value of the euclidean norm of the solution.\n\n        Args:\n            qc: The quantum circuit preparing the solution x to the system.\n\n        Returns:\n            The value of the euclidean norm of the solution.\n        ')
Name(id='nb', ctx=Store())
Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())
Name(id='nl', ctx=Store())
Attribute(value=Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())
Name(id='na', ctx=Store())
Attribute(value=Name(id='qc', ctx=Load()), attr='num_ancillas', ctx=Load())
Name(id='zero_op', ctx=Store())
BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))
Name(id='one_op', ctx=Store())
BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))
Name(id='observable', ctx=Store())
BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))
Name(id='norm_2', ctx=Store())
Call(func=Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))], keywords=[])
Load()
arg(arg='self', annotation=None)
arg(arg='solution', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
Str(s='Calculates the value of the observable(s) given.\n\n        Args:\n            solution: The quantum circuit preparing the solution x to the system.\n            observable: Information to be extracted from the solution.\n            observable_circuit: Circuit to be applied to the solution to extract information.\n            post_processing: Function to compute the value of the observable.\n\n        Returns:\n            The value of the observable(s) and the circuit results before post-processing as a\n             tuple.\n        ')
Name(id='nb', ctx=Store())
Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='size', ctx=Load())
Name(id='nl', ctx=Store())
Attribute(value=Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load()), attr='size', ctx=Load())
Name(id='na', ctx=Store())
Attribute(value=Name(id='solution', ctx=Load()), attr='num_ancillas', ctx=Load())
Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='post_processing', ctx=Store())], value=Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load()))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='observable', ctx=Store())], value=BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load())))
Name(id='zero_op', ctx=Store())
BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))
Name(id='one_op', ctx=Store())
BinOp(left=BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load())), op=Div(), right=Num(n=2))
Name(id='is_list', ctx=Store())
NameConstant(value=True)
UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='is_list', ctx=Store())], value=NameConstant(value=False))
Assign(targets=[Name(id='observable_circuit', ctx=Store())], value=List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load()))
Assign(targets=[Name(id='observable', ctx=Store())], value=List(elts=[Name(id='observable', ctx=Load())], ctx=Load()))
Name(id='expectations', ctx=Store())
List(elts=[], ctx=Load())
Tuple(elts=[Name(id='circ', ctx=Store()), Name(id='obs', ctx=Store())], ctx=Store())
Call(func=Name(id='zip', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='observable', ctx=Load())], keywords=[])
Assign(targets=[Name(id='circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]))
Assign(targets=[Name(id='ob', ctx=Store())], value=BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load())))
Expr(value=Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[]))
Name(id='is_list', ctx=Load())
Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='expectations', ctx=Store())], value=Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))
If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Name(id='expectations', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[]))
Name(id='expectation_results', ctx=Store())
Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])
Name(id='result', ctx=Store())
Call(func=Name(id='post_processing', ctx=Load()), args=[Name(id='expectation_results', ctx=Load()), Name(id='nb', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())], keywords=[])
Tuple(elts=[Name(id='result', ctx=Load()), Name(id='expectation_results', ctx=Load())], ctx=Load())
Name(id='Tuple', ctx=Load())
Index(value=Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='neg_vals', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load()))
NameConstant(value=True)
Str(s='Construct the HHL circuit.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            neg_vals: States whether the matrix has negative eigenvalues. If False the\n            computation becomes cheaper.\n\n        Returns:\n            The HHL circuit.\n\n        Raises:\n            ValueError: If the input is not in the correct format.\n            ValueError: If the type of the input matrix is not supported.\n        ')
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[])
Assign(targets=[Name(id='nb', ctx=Store())], value=Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load()))
Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Name(id='vector', ctx=Load()))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])), Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))], orelse=[])
Name(id='nf', ctx=Store())
Num(n=1)
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], keywords=[])
Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Name(id='matrix', ctx=Load()))
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[]), body=[If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[]), If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)])
Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='tolerance')], keywords=[])
Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load()))
BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Assign(targets=[Name(id='kappa', ctx=Store())], value=Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load()))
Assign(targets=[Name(id='kappa', ctx=Store())], value=Num(n=1))
Name(id='nl', ctx=Store())
BinOp(left=Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[]), op=Add(), right=Name(id='neg_vals', ctx=Load()))
BoolOp(op=And(), values=[Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[]), Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Assign(targets=[Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='delta', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[]))
Assign(targets=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load()))))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())], value=Name(id='lambda_min', ctx=Load()))
Assign(targets=[Name(id='delta', ctx=Store())], value=BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))))
Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load())
Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))]))
Assign(targets=[Name(id='na', ctx=Store())], value=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()))
Assign(targets=[Name(id='num_values', ctx=Store())], value=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))
Assign(targets=[Name(id='constant', ctx=Store())], value=Name(id='delta', ctx=Load()))
Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[]))
Assign(targets=[Name(id='r', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[])))
Assign(targets=[Name(id='degree', ctx=Store())], value=Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='num_intervals', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[]))
Assign(targets=[Name(id='breakpoints', ctx=Store())], value=List(elts=[], ctx=Load()))
For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])), If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])], orelse=[])
Assign(targets=[Name(id='reciprocal_circuit', ctx=Store())], value=Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='na', ctx=Store())], value=Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[]))
Name(id='qb', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Name(id='ql', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nl', ctx=Load())], keywords=[])
Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Assign(targets=[Name(id='qa', ctx=Store())], value=Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[]))
Name(id='qf', ctx=Store())
Call(func=Name(id='QuantumRegister', ctx=Load()), args=[Name(id='nf', ctx=Load())], keywords=[])
Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='qc', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[]))
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='vector_circuit', ctx=Load()), Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())], keywords=[])
Name(id='phase_estimation', ctx=Store())
Call(func=Name(id='PhaseEstimation', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='matrix_circuit', ctx=Load())], keywords=[])
Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_exact_reciprocal', ctx=Load())
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))
Compare(left=Name(id='na', ctx=Load()), ops=[Gt()], comparators=[Num(n=0)])
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[]))
Name(id='qc', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='matrix', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='vector', annotation=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load()))
arg(arg='observable', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='observable_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
arg(arg='post_processing', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
Str(s='Tries to solve the given linear system of equations.\n\n        Args:\n            matrix: The matrix specifying the system, i.e. A in Ax=b.\n            vector: The vector specifying the right hand side of the equation in Ax=b.\n            observable: Optional information to be extracted from the solution.\n                Default is the probability of success of the algorithm.\n            observable_circuit: Optional circuit to be applied to the solution to extract\n                information. Default is `None`.\n            post_processing: Optional function to compute the value of the observable.\n                Default is the raw value of measuring the observable.\n\n        Raises:\n            ValueError: If an invalid combination of observable, observable_circuit and\n                post_processing is passed.\n\n        Returns:\n            The result object containing information about the solution vector of the linear\n            system.\n        ')
Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
If(test=BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)], orelse=[])
Name(id='solution', ctx=Store())
Call(func=Name(id='LinearSolverResult', ctx=Load()), args=[], keywords=[])
Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='vector', ctx=Load())], keywords=[])
Attribute(value=Name(id='solution', ctx=Load()), attr='euclidean_norm', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())], keywords=[])
BoolOp(op=Or(), values=[Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Assign(targets=[Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[]))
Name(id='solution', ctx=Load())
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='ExpectationBase', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='epsilon', ctx=Load())
Div()
Num(n=3)
Name(id='self', ctx=Load())
Store()
Name(id='epsilon', ctx=Load())
Div()
Num(n=3)
Name(id='self', ctx=Load())
Store()
Name(id='epsilon', ctx=Load())
Div()
Num(n=6)
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='self', ctx=Load())
Store()
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[Is()], comparators=[NameConstant(value=None)])
NameConstant(value=None)
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Name(id='QuantumInstance', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='quantum_instance', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())
Call(func=Name(id='CircuitSampler', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Store())
NameConstant(value=None)
Load()
Name(id='self', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Name(id='int', ctx=Load())
Name(id='float', ctx=Load())
Name(id='float', ctx=Load())
Store()
BinOp(left=Str(s='#0'), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[]))
Add()
Str(s='b')
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
BinOp(left=BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))), op=Div(), right=Name(id='lambda_max', ctx=Load()))
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Lt()
Num(n=1e-07)
Name(id='lambda_min_tilde', ctx=Store())
Num(n=1)
Store()
Call(func=Name(id='format', ctx=Load()), args=[Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[]), Name(id='formatstr', ctx=Load())], keywords=[])
Slice(lower=Num(n=2), upper=None, step=None)
Load()
Store()
Name(id='i', ctx=Store())
Name(id='char', ctx=Store())
Store()
Name(id='enumerate', ctx=Load())
Name(id='binstr', ctx=Load())
Name(id='lamb_min_rep', ctx=Store())
Add()
BinOp(left=Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))))
Load()
Name(id='QuantumCircuit', ctx=Load())
Store()
Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Store()
Subscript(value=Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Load()
Store()
Name(id='qc', ctx=Load())
Load()
Store()
BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load()))
Div()
Num(n=2)
Store()
BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load()))
Div()
Num(n=2)
Store()
BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[]))
BitXor()
BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load()))
Store()
Attribute(value=BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])), attr='eval', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='real', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[]), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Store()
Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Store()
Subscript(value=Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Load()
Store()
Name(id='solution', ctx=Load())
Load()
Name(id='observable', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='observable_circuit', ctx=Store())
Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Name(id='post_processing', ctx=Store())
Attribute(value=Name(id='observable', ctx=Load()), attr='post_processing', ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable', ctx=Load()), Name(id='LinearSystemObservable', ctx=Load())], keywords=[])
Assign(targets=[Name(id='observable', ctx=Store())], value=Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))
Name(id='observable', ctx=Store())
BinOp(left=Name(id='I', ctx=Load()), op=BitXor(), right=Name(id='nb', ctx=Load()))
Store()
BinOp(left=Name(id='I', ctx=Load()), op=Add(), right=Name(id='Z', ctx=Load()))
Div()
Num(n=2)
Store()
BinOp(left=Name(id='I', ctx=Load()), op=Sub(), right=Name(id='Z', ctx=Load()))
Div()
Num(n=2)
Store()
Not()
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='observable_circuit', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Name(id='is_list', ctx=Store())
NameConstant(value=False)
Name(id='observable_circuit', ctx=Store())
List(elts=[Name(id='observable_circuit', ctx=Load())], ctx=Load())
Name(id='observable', ctx=Store())
List(elts=[Name(id='observable', ctx=Load())], ctx=Load())
Store()
Load()
Name(id='circ', ctx=Store())
Name(id='obs', ctx=Store())
Store()
Name(id='zip', ctx=Load())
Name(id='observable_circuit', ctx=Load())
Name(id='observable', ctx=Load())
Name(id='circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='solution', ctx=Load()), Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='circ', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])
Name(id='ob', ctx=Store())
BinOp(left=BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])), op=BitXor(), right=Name(id='obs', ctx=Load()))
Call(func=Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))], keywords=[])
Load()
Name(id='expectations', ctx=Store())
Call(func=Name(id='ListOp', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[])
Name(id='expectations', ctx=Store())
Subscript(value=Name(id='expectations', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='expectations', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[])
Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
If(test=Name(id='is_list', ctx=Load()), body=[Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))], orelse=[Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())], value=Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='expectations', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load()), args=[Name(id='expectations', ctx=Load())], keywords=[])
Store()
Attribute(value=Name(id='expectations', ctx=Load()), attr='eval', ctx=Load())
Store()
Name(id='post_processing', ctx=Load())
Name(id='expectation_results', ctx=Load())
Name(id='nb', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())
Name(id='result', ctx=Load())
Name(id='expectation_results', ctx=Load())
Load()
Load()
Tuple(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='bool', ctx=Load())), ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='vector', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Name(id='nb', ctx=Store())
Attribute(value=Name(id='vector', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='vector_circuit', ctx=Store())
Name(id='vector', ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Name(id='nb', ctx=Store())], value=Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[]))
Assign(targets=[Name(id='vector_circuit', ctx=Store())], value=Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[]))
Store()
Name(id='isinstance', ctx=Load())
Name(id='matrix', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Name(id='matrix_circuit', ctx=Store())
Name(id='matrix', ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())], keywords=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))], orelse=[])
If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)], orelse=[])
If(test=Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)], orelse=[])
If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)], orelse=[])
If(test=Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='matrix_circuit', ctx=Store())], value=Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))]))
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[]), cause=None)
Name(id='hasattr', ctx=Load())
Name(id='matrix_circuit', ctx=Load())
Str(s='tolerance')
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='tolerance', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_a', ctx=Load())
And()
Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='condition_bounds')], keywords=[])
Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])
Name(id='kappa', ctx=Store())
Subscript(value=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[]), slice=Index(value=Num(n=1)), ctx=Load())
Name(id='kappa', ctx=Store())
Num(n=1)
Store()
Call(func=Name(id='max', ctx=Load()), args=[BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1)), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])], keywords=[])
Add()
Name(id='neg_vals', ctx=Load())
And()
Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='matrix_circuit', ctx=Load()), Str(s='eigs_bounds')], keywords=[])
Compare(left=Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[]), ops=[IsNot()], comparators=[NameConstant(value=None)])
Tuple(elts=[Name(id='lambda_min', ctx=Store()), Name(id='lambda_max', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])
Name(id='delta', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load()), args=[BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load())), Name(id='lambda_min', ctx=Load()), Name(id='lambda_max', ctx=Load())], keywords=[])
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='evolution_time', ctx=Store())
BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load())), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load())))
Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Store())
Name(id='lambda_min', ctx=Load())
Name(id='delta', ctx=Store())
BinOp(left=Num(n=1), op=Div(), right=BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load())))
Call(func=Name(id='print', ctx=Load()), args=[Str(s='The solution will be calculated up to a scaling factor.')], keywords=[])
Name(id='self', ctx=Load())
Load()
Name(id='reciprocal_circuit', ctx=Store())
Call(func=Name(id='ExactReciprocal', ctx=Load()), args=[Name(id='nl', ctx=Load()), Name(id='delta', ctx=Load())], keywords=[keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))])
Name(id='na', ctx=Store())
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Name(id='num_values', ctx=Store())
BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))
Name(id='constant', ctx=Store())
Name(id='delta', ctx=Load())
Name(id='a', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])], keywords=[])
Name(id='r', ctx=Store())
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Add(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[]))
Name(id='degree', ctx=Store())
Call(func=Name(id='min', ctx=Load()), args=[Name(id='nb', ctx=Load()), Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])], keywords=[])
Name(id='num_intervals', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])], keywords=[])
Name(id='breakpoints', ctx=Store())
List(elts=[], ctx=Load())
Name(id='i', ctx=Store())
Call(func=Name(id='range', ctx=Load()), args=[Num(n=0), Name(id='num_intervals', ctx=Load())], keywords=[])
Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[]))
If(test=Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))]), body=[Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))], orelse=[])
Name(id='reciprocal_circuit', ctx=Store())
Call(func=Name(id='PiecewiseChebyshev', ctx=Load()), args=[Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])), Name(id='degree', ctx=Load()), Name(id='breakpoints', ctx=Load()), Name(id='nl', ctx=Load())], keywords=[])
Name(id='na', ctx=Store())
Call(func=Name(id='max', ctx=Load()), args=[Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())], keywords=[])
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='nb', ctx=Load())
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='nl', ctx=Load())
Name(id='na', ctx=Load())
Gt()
Num(n=0)
Name(id='qa', ctx=Store())
Call(func=Name(id='AncillaRegister', ctx=Load()), args=[Name(id='na', ctx=Load())], keywords=[])
Store()
Name(id='QuantumRegister', ctx=Load())
Name(id='nf', ctx=Load())
Name(id='na', ctx=Load())
Gt()
Num(n=0)
Name(id='qc', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qa', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[])
Name(id='qc', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='qb', ctx=Load()), Name(id='ql', ctx=Load()), Name(id='qf', ctx=Load())], keywords=[])
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Name(id='vector_circuit', ctx=Load())
Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Store()
Name(id='PhaseEstimation', ctx=Load())
Name(id='nl', ctx=Load())
Name(id='matrix_circuit', ctx=Load())
Name(id='na', ctx=Load())
Gt()
Num(n=0)
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='phase_estimation', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[])
Name(id='self', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Name(id='reciprocal_circuit', ctx=Load()), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[])
Name(id='na', ctx=Load())
Gt()
Num(n=0)
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))], keywords=[])
Call(func=Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[]), BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))], keywords=[])
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='observable', ctx=Load())
IsNot()
NameConstant(value=None)
BoolOp(op=Or(), values=[Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[]), cause=None)
Store()
Name(id='LinearSolverResult', ctx=Load())
Name(id='solution', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='matrix', ctx=Load())
Name(id='vector', ctx=Load())
Name(id='solution', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_norm', ctx=Load())
Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())
Or()
Compare(left=Name(id='observable', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Tuple(elts=[Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store()), Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())], ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load()), args=[Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load()), Name(id='observable', ctx=Load()), Name(id='observable_circuit', ctx=Load()), Name(id='post_processing', ctx=Load())], keywords=[])
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='ExpectationBase', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Call(func=Name(id='super', ctx=Load()), args=[], keywords=[])
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
Is()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Name(id='self', ctx=Load())
Store()
Name(id='CircuitSampler', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Str(s='#0')
Add()
Call(func=Name(id='str', ctx=Load()), args=[BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))], keywords=[])
Name(id='np', ctx=Load())
Load()
BinOp(left=Name(id='lambda_min', ctx=Load()), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1)))
Div()
Name(id='lambda_max', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
BinOp(left=Name(id='lambda_min_tilde', ctx=Load()), op=Sub(), right=Num(n=1))
Store()
Name(id='format', ctx=Load())
Call(func=Name(id='int', ctx=Load()), args=[Name(id='lambda_min_tilde', ctx=Load())], keywords=[])
Name(id='formatstr', ctx=Load())
Num(n=2)
Store()
Store()
Load()
Load()
Store()
Call(func=Name(id='int', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[])
Div()
BinOp(left=Num(n=2), op=Pow(), right=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1)))
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load())
Index(value=Num(n=0))
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='qregs', ctx=Load())
Index(value=Num(n=1))
Load()
Load()
Name(id='I', ctx=Load())
Add()
Name(id='Z', ctx=Load())
Name(id='I', ctx=Load())
Sub()
Name(id='Z', ctx=Load())
Name(id='one_op', ctx=Load())
BitXor()
Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])
Name(id='I', ctx=Load())
BitXor()
Name(id='nb', ctx=Load())
BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[]))
Load()
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Name(id='norm_2', ctx=Load())], keywords=[])
Div()
Attribute(value=Name(id='self', ctx=Load()), attr='scaling', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load())
Index(value=Num(n=0))
Load()
Attribute(value=Name(id='solution', ctx=Load()), attr='qregs', ctx=Load())
Index(value=Num(n=1))
Load()
Load()
Load()
Store()
Attribute(value=Name(id='observable', ctx=Load()), attr='observable_circuit', ctx=Load())
Name(id='nb', ctx=Load())
Store()
Name(id='observable', ctx=Load())
Load()
Name(id='isinstance', ctx=Load())
Name(id='observable', ctx=Load())
Name(id='LinearSystemObservable', ctx=Load())
Name(id='observable', ctx=Store())
Call(func=Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Store()
Name(id='I', ctx=Load())
BitXor()
Name(id='nb', ctx=Load())
Name(id='I', ctx=Load())
Add()
Name(id='Z', ctx=Load())
Name(id='I', ctx=Load())
Sub()
Name(id='Z', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='observable_circuit', ctx=Load())
Name(id='list', ctx=Load())
Store()
Store()
Name(id='observable_circuit', ctx=Load())
Load()
Store()
Name(id='observable', ctx=Load())
Load()
Store()
Store()
Load()
Load()
Load()
Store()
Name(id='QuantumCircuit', ctx=Load())
Attribute(value=Name(id='solution', ctx=Load()), attr='num_qubits', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='solution', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='qubits', ctx=Load())
Attribute(value=Name(id='circuit', ctx=Load()), attr='append', ctx=Load())
Name(id='circ', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Store()
BinOp(left=Name(id='one_op', ctx=Load()), op=BitXor(), right=Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[]))
BitXor()
Name(id='obs', ctx=Load())
Attribute(value=Name(id='expectations', ctx=Load()), attr='append', ctx=Load())
BinOp(left=UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])), op=MatMult(), right=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[]))
Store()
Name(id='ListOp', ctx=Load())
Name(id='expectations', ctx=Load())
Store()
Name(id='expectations', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load()), attr='convert', ctx=Load())
Name(id='expectations', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='is_list', ctx=Load())
Assign(targets=[Name(id='op', ctx=Store())], value=Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()))
Assign(targets=[Name(id='op', ctx=Store())], value=Name(id='expectations', ctx=Load()))
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Store())
Call(func=Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load()), args=[Name(id='op', ctx=Load()), Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='convert', ctx=Load())
Name(id='expectations', ctx=Load())
Name(id='expectations', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='bool', ctx=Load()))
Load()
Load()
Load()
Load()
Store()
Name(id='vector', ctx=Load())
Load()
Store()
Load()
Name(id='isinstance', ctx=Load())
Name(id='vector', ctx=Load())
Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='vector', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='vector', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))
Name(id='nb', ctx=Store())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])], keywords=[])
Name(id='vector_circuit', ctx=Store())
Call(func=Name(id='QuantumCircuit', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load()), args=[BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])), Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[]), NameConstant(value=None)], keywords=[])
Load()
Load()
Load()
Store()
Load()
Name(id='isinstance', ctx=Load())
Name(id='matrix', ctx=Load())
Tuple(elts=[Name(id='list', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())], ctx=Load())
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Name(id='list', ctx=Load())], keywords=[])
Assign(targets=[Name(id='matrix', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]))
Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[]), cause=None)
Compare(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1)), ops=[NotEq()], comparators=[Num(n=0)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[]), cause=None)
UnaryOp(op=Not(), operand=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[]))
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[]), cause=None)
Compare(left=Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), ops=[NotEq()], comparators=[BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[]), cause=None)
Name(id='matrix_circuit', ctx=Store())
Call(func=Name(id='NumPyMatrix', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))])
Call(func=Name(id='ValueError', ctx=Load()), args=[JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])], keywords=[])
Load()
Load()
Name(id='matrix_circuit', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='hasattr', ctx=Load())
Name(id='matrix_circuit', ctx=Load())
Str(s='condition_bounds')
Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[])
IsNot()
NameConstant(value=None)
Store()
Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load()), args=[], keywords=[])
Index(value=Num(n=1))
Load()
Store()
Name(id='max', ctx=Load())
BinOp(left=Name(id='nb', ctx=Load()), op=Add(), right=Num(n=1))
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])], keywords=[])
Load()
Name(id='hasattr', ctx=Load())
Name(id='matrix_circuit', ctx=Load())
Str(s='eigs_bounds')
Call(func=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load()), args=[], keywords=[])
IsNot()
NameConstant(value=None)
Name(id='lambda_min', ctx=Store())
Name(id='lambda_max', ctx=Store())
Store()
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_get_delta', ctx=Load())
BinOp(left=Name(id='nl', ctx=Load()), op=Sub(), right=Name(id='neg_vals', ctx=Load()))
Name(id='lambda_min', ctx=Load())
Name(id='lambda_max', ctx=Load())
Name(id='matrix_circuit', ctx=Load())
Store()
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load())), op=Div(), right=Name(id='lambda_min', ctx=Load()))
Div()
BinOp(left=Num(n=2), op=Pow(), right=Name(id='neg_vals', ctx=Load()))
Name(id='self', ctx=Load())
Store()
Load()
Store()
Num(n=1)
Div()
BinOp(left=Num(n=2), op=Pow(), right=Name(id='nl', ctx=Load()))
Name(id='print', ctx=Load())
Str(s='The solution will be calculated up to a scaling factor.')
Load()
Store()
Name(id='ExactReciprocal', ctx=Load())
Name(id='nl', ctx=Load())
Name(id='delta', ctx=Load())
keyword(arg='neg_vals', value=Name(id='neg_vals', ctx=Load()))
Store()
Name(id='matrix_circuit', ctx=Load())
Load()
Store()
Num(n=2)
Pow()
Name(id='nl', ctx=Load())
Store()
Load()
Store()
Name(id='int', ctx=Load())
Call(func=Name(id='round', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))], keywords=[])
Store()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load()))
Add()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])], keywords=[])
Store()
Name(id='min', ctx=Load())
Name(id='nb', ctx=Load())
Call(func=Name(id='int', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])], keywords=[])
Store()
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))], keywords=[])
Store()
Load()
Store()
Name(id='range', ctx=Load())
Num(n=0)
Name(id='num_intervals', ctx=Load())
Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))], keywords=[])
Compare(left=Name(id='i', ctx=Load()), ops=[Eq()], comparators=[BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))])
Expr(value=Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[]))
Store()
Name(id='PiecewiseChebyshev', ctx=Load())
Lambda(args=arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[]))
Name(id='degree', ctx=Load())
Name(id='breakpoints', ctx=Load())
Name(id='nl', ctx=Load())
Store()
Name(id='max', ctx=Load())
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Store()
Name(id='AncillaRegister', ctx=Load())
Name(id='na', ctx=Load())
Load()
Load()
Load()
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='qb', ctx=Load())
Name(id='ql', ctx=Load())
Name(id='qa', ctx=Load())
Name(id='qf', ctx=Load())
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='qb', ctx=Load())
Name(id='ql', ctx=Load())
Name(id='qf', ctx=Load())
Name(id='qc', ctx=Load())
Load()
Load()
Name(id='qb', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Name(id='phase_estimation', ctx=Load())
BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Name(id='phase_estimation', ctx=Load())
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Name(id='reciprocal_circuit', ctx=Load())
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load()), args=[], keywords=[])
BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))
Load()
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
BinOp(left=BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())), op=Add(), right=Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load()))
Attribute(value=Name(id='qc', ctx=Load()), attr='append', ctx=Load())
Call(func=Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load()), args=[], keywords=[])
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Or()
Compare(left=Name(id='observable_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Compare(left=Name(id='post_processing', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')], keywords=[])
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='solution', ctx=Load())
Load()
Name(id='observable', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='observable_circuit', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='solution', ctx=Load()), attr='observable', ctx=Store())
Attribute(value=Name(id='solution', ctx=Load()), attr='circuit_results', ctx=Store())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_calculate_observable', ctx=Load())
Attribute(value=Name(id='solution', ctx=Load()), attr='state', ctx=Load())
Name(id='observable', ctx=Load())
Name(id='observable_circuit', ctx=Load())
Name(id='post_processing', ctx=Load())
Load()
Name(id='ExpectationBase', ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())), ctx=Load())
Name(id='super', ctx=Load())
Name(id='self', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Name(id='str', ctx=Load())
BinOp(left=Name(id='n_l', ctx=Load()), op=Add(), right=Num(n=2))
Load()
Name(id='lambda_min', ctx=Load())
Mult()
BinOp(left=BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load())), op=Sub(), right=Num(n=1))
Load()
Name(id='np', ctx=Load())
Load()
Name(id='lambda_min_tilde', ctx=Load())
Sub()
Num(n=1)
Load()
Name(id='int', ctx=Load())
Name(id='lambda_min_tilde', ctx=Load())
Load()
Name(id='int', ctx=Load())
Name(id='char', ctx=Load())
Num(n=2)
Pow()
BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Num(n=1))
Name(id='qc', ctx=Load())
Load()
Num(n=0)
Name(id='qc', ctx=Load())
Load()
Num(n=1)
Load()
Load()
Load()
Load()
Load()
Name(id='TensoredOp', ctx=Load())
BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))
Load()
Load()
UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[]))
MatMult()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='qc', ctx=Load())], keywords=[])
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
Name(id='norm_2', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Name(id='solution', ctx=Load())
Load()
Num(n=0)
Name(id='solution', ctx=Load())
Load()
Num(n=1)
Name(id='observable', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Store()
Attribute(value=Name(id='observable', ctx=Load()), attr='observable', ctx=Load())
Name(id='nb', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='solution', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='circuit', ctx=Load())
Load()
Name(id='circuit', ctx=Load())
Load()
Load()
Name(id='range', ctx=Load())
Name(id='nb', ctx=Load())
Name(id='one_op', ctx=Load())
BitXor()
Call(func=Name(id='TensoredOp', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))], keywords=[])
Load()
Name(id='expectations', ctx=Load())
Load()
UnaryOp(op=Invert(), operand=Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[]))
MatMult()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='circuit', ctx=Load())], keywords=[])
Load()
Load()
Load()
Num(n=0)
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_expectation', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='op', ctx=Store())
Subscript(value=Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='op', ctx=Store())
Name(id='expectations', ctx=Load())
Name(id='self', ctx=Load())
Store()
Attribute(value=Name(id='ExpectationFactory', ctx=Load()), attr='build', ctx=Load())
Name(id='op', ctx=Load())
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load()), attr='quantum_instance', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())
Load()
Name(id='bool', ctx=Load())
Load()
Load()
Load()
Name(id='list', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='isinstance', ctx=Load())
Name(id='vector', ctx=Load())
Name(id='list', ctx=Load())
Name(id='vector', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])
Store()
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])], keywords=[])
Store()
Name(id='QuantumCircuit', ctx=Load())
Name(id='nb', ctx=Load())
Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='isometry', ctx=Load())
BinOp(left=Name(id='vector', ctx=Load()), op=Div(), right=Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[]))
Call(func=Name(id='list', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])], keywords=[])
NameConstant(value=None)
Load()
Load()
Name(id='list', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Load()
Name(id='isinstance', ctx=Load())
Name(id='matrix', ctx=Load())
Name(id='list', ctx=Load())
Name(id='matrix', ctx=Store())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[])
Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
NotEq()
Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=1)), ctx=Load())
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be square!')], keywords=[])
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]), op=Mod(), right=Num(n=1))
NotEq()
Num(n=0)
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix dimension must be 2^n!')], keywords=[])
Not()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load()), args=[Name(id='matrix', ctx=Load()), Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())], keywords=[])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Input matrix must be hermitian!')], keywords=[])
Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
NotEq()
BinOp(left=Num(n=2), op=Pow(), right=Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load()))
Call(func=Name(id='ValueError', ctx=Load()), args=[BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))], keywords=[])
Store()
Name(id='NumPyMatrix', ctx=Load())
Name(id='matrix', ctx=Load())
keyword(arg='evolution_time', value=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())))
Name(id='ValueError', ctx=Load())
JoinedStr(values=[Str(s='Invalid type for matrix: '), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None), Str(s='.')])
Load()
Load()
Load()
Load()
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load())
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='condition_bounds', ctx=Load())
Num(n=1)
Load()
Name(id='nb', ctx=Load())
Add()
Num(n=1)
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])], keywords=[])
Load()
Load()
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='eigs_bounds', ctx=Load())
Store()
Store()
Name(id='matrix_circuit', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Name(id='nl', ctx=Load())
Sub()
Name(id='neg_vals', ctx=Load())
Load()
Load()
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())), op=Mult(), right=Name(id='delta', ctx=Load()))
Div()
Name(id='lambda_min', ctx=Load())
Num(n=2)
Pow()
Name(id='neg_vals', ctx=Load())
Load()
Num(n=2)
Pow()
Name(id='nl', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='neg_vals', ctx=Load())
Load()
Load()
Load()
Name(id='round', ctx=Load())
BinOp(left=Name(id='num_values', ctx=Load()), op=Pow(), right=BinOp(left=Num(n=2), op=Div(), right=Num(n=3)))
BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load()))
Div()
Name(id='a', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load()), args=[BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))], keywords=[])
Load()
Load()
Name(id='int', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))], keywords=[])
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load())
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[]), op=Div(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[]))
Load()
Load()
Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load())
BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load())))
Name(id='i', ctx=Load())
Eq()
BinOp(left=Name(id='num_intervals', ctx=Load()), op=Sub(), right=Num(n=1))
Call(func=Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load()), args=[BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))], keywords=[])
Load()
arguments(args=[arg(arg='x', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load()), args=[BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))], keywords=[])
Load()
Load()
Load()
Load()
Name(id='matrix_circuit', ctx=Load())
Load()
Name(id='reciprocal_circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='qc', ctx=Load())
Load()
Load()
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))
Add()
Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load())
Name(id='qc', ctx=Load())
Load()
Load()
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Add()
Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Name(id='qc', ctx=Load())
Load()
Load()
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
Add()
List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())
Name(id='qc', ctx=Load())
Load()
Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='to_instruction', ctx=Load())
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load()))
Add()
Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load())
Name(id='qc', ctx=Load())
Load()
Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load())
BinOp(left=Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()), op=Add(), right=Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load()))
Add()
Subscript(value=Name(id='qa', ctx=Load()), slice=Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None), ctx=Load())
Name(id='qc', ctx=Load())
Load()
Attribute(value=Name(id='phase_estimation', ctx=Load()), attr='inverse', ctx=Load())
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Add()
Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Load()
Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='List', ctx=Load()), Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), Name(id='QuantumCircuit', ctx=Load())], ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Subscript(value=Name(id='Callable', ctx=Load()), slice=Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Name(id='observable_circuit', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='post_processing', ctx=Load())
IsNot()
NameConstant(value=None)
Name(id='ValueError', ctx=Load())
Str(s='If observable is passed, observable_circuit and post_processing cannot be set.')
Load()
Load()
Load()
Load()
Load()
Name(id='solution', ctx=Load())
Store()
Name(id='solution', ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Name(id='solution', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='n_l', ctx=Load())
Add()
Num(n=2)
Load()
BinOp(left=Num(n=2), op=Pow(), right=Name(id='n_l', ctx=Load()))
Sub()
Num(n=1)
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='i', ctx=Load())
Add()
Num(n=1)
Load()
Load()
Load()
BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load()))
Mult()
List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load())
Invert()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='observable', ctx=Load())], keywords=[])
Name(id='StateFn', ctx=Load())
Name(id='qc', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load()))
Load()
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='observable', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='TensoredOp', ctx=Load())
BinOp(left=BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load())), op=Mult(), right=List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load()))
Load()
Invert()
Call(func=Name(id='StateFn', ctx=Load()), args=[Name(id='ob', ctx=Load())], keywords=[])
Name(id='StateFn', ctx=Load())
Name(id='circuit', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Store()
Attribute(value=Name(id='expectations', ctx=Load()), attr='oplist', ctx=Load())
Index(value=Num(n=0))
Load()
Store()
Load()
Load()
Name(id='ExpectationFactory', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_sampler', ctx=Load())
Load()
Name(id='self', ctx=Load())
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Name(id='List', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='List', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Name(id='vector', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load())
Call(func=Name(id='len', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])
Load()
Load()
Name(id='vector_circuit', ctx=Load())
Load()
Name(id='vector', ctx=Load())
Div()
Call(func=Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load()), args=[Name(id='vector', ctx=Load())], keywords=[])
Name(id='list', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Name(id='nb', ctx=Load())], keywords=[])
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Store()
Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())
Name(id='matrix', ctx=Load())
Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load())
Index(value=Num(n=0))
Load()
Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load())
Index(value=Num(n=1))
Load()
Name(id='ValueError', ctx=Load())
Str(s='Input matrix must be square!')
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Mod()
Num(n=1)
Name(id='ValueError', ctx=Load())
Str(s='Input matrix dimension must be 2^n!')
Attribute(value=Name(id='np', ctx=Load()), attr='allclose', ctx=Load())
Name(id='matrix', ctx=Load())
Attribute(value=Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[]), attr='T', ctx=Load())
Name(id='ValueError', ctx=Load())
Str(s='Input matrix must be hermitian!')
Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load())
Index(value=Num(n=0))
Load()
Num(n=2)
Pow()
Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='ValueError', ctx=Load())
BinOp(left=BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: ')), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[]))
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Load()
Str(s='Invalid type for matrix: ')
FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[]), conversion=-1, format_spec=None)
Str(s='.')
Name(id='matrix_circuit', ctx=Load())
Load()
Name(id='matrix_circuit', ctx=Load())
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='ceil', ctx=Load())
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load()), args=[BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))], keywords=[])
Name(id='matrix_circuit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()))
Mult()
Name(id='delta', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='num_values', ctx=Load())
Pow()
BinOp(left=Num(n=2), op=Div(), right=Num(n=3))
Num(n=2)
Mult()
Name(id='constant', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='abs', ctx=Load())
BinOp(left=Num(n=1), op=Sub(), right=BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2)))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=Num(n=1), op=Add(), right=BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))
Name(id='np', ctx=Load())
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))], keywords=[])
Div()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Num(n=5)], keywords=[])
Name(id='breakpoints', ctx=Load())
Load()
Name(id='a', ctx=Load())
Mult()
BinOp(left=Num(n=5), op=Pow(), right=Name(id='i', ctx=Load()))
Load()
Name(id='num_intervals', ctx=Load())
Sub()
Num(n=1)
Attribute(value=Name(id='breakpoints', ctx=Load()), attr='append', ctx=Load())
BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))
arg(arg='x', annotation=None)
Attribute(value=Name(id='np', ctx=Load()), attr='arcsin', ctx=Load())
BinOp(left=Name(id='constant', ctx=Load()), op=Div(), right=Name(id='x', ctx=Load()))
Load()
Load()
Load()
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Add()
Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Name(id='qa', ctx=Load())
Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None)
Load()
Load()
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Name(id='qb', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Name(id='reciprocal_circuit', ctx=Load())
Load()
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Add()
List(elts=[Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], ctx=Load())
Name(id='qa', ctx=Load())
Slice(lower=None, upper=Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None)
Load()
Load()
Name(id='phase_estimation', ctx=Load())
Load()
Subscript(value=Name(id='ql', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Add()
Subscript(value=Name(id='qb', ctx=Load()), slice=Slice(lower=None, upper=None, step=None), ctx=Load())
Name(id='qa', ctx=Load())
Slice(lower=None, upper=Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load()), step=None)
Load()
Load()
Name(id='phase_estimation', ctx=Load())
Load()
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Name(id='qb', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Name(id='List', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='List', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='Callable', ctx=Load())
Index(value=Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[Name(id='Backend', ctx=Load()), Name(id='QuantumInstance', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Num(n=2)
Pow()
Name(id='n_l', ctx=Load())
Load()
Name(id='nl', ctx=Load())
Add()
Name(id='na', ctx=Load())
Name(id='zero_op', ctx=Load())
Load()
Name(id='StateFn', ctx=Load())
Name(id='observable', ctx=Load())
Load()
Load()
Load()
Load()
Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load())], ctx=Load())
Load()
Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Load()
Load()
BinOp(left=Name(id='nl', ctx=Load()), op=Add(), right=Name(id='na', ctx=Load()))
Mult()
List(elts=[Name(id='zero_op', ctx=Load())], ctx=Load())
Name(id='StateFn', ctx=Load())
Name(id='ob', ctx=Load())
Load()
Load()
Load()
Name(id='expectations', ctx=Load())
Load()
Num(n=0)
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Name(id='len', ctx=Load())
Name(id='vector', ctx=Load())
Load()
Load()
Attribute(value=Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load()), attr='norm', ctx=Load())
Name(id='vector', ctx=Load())
Load()
Name(id='range', ctx=Load())
Name(id='nb', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='matrix', ctx=Load())
Load()
Num(n=0)
Name(id='matrix', ctx=Load())
Load()
Num(n=1)
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load())
Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load()), args=[], keywords=[])
Load()
Load()
Name(id='matrix', ctx=Load())
Load()
Num(n=0)
Name(id='vector_circuit', ctx=Load())
Load()
Load()
BinOp(left=BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])), op=Add(), right=Str(s='. Matrix dimension: '))
Add()
Call(func=Name(id='str', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())], keywords=[])
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Call(func=Name(id='type', ctx=Load()), args=[Name(id='matrix', ctx=Load())], keywords=[])
Load()
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log2', ctx=Load())
BinOp(left=Name(id='kappa', ctx=Load()), op=Add(), right=Num(n=1))
Load()
Num(n=2)
Mult()
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Load()
Load()
Num(n=2)
Div()
Num(n=3)
Load()
Load()
Name(id='np', ctx=Load())
Load()
Num(n=1)
Sub()
BinOp(left=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load())), op=Pow(), right=Num(n=2))
Name(id='np', ctx=Load())
Load()
Num(n=1)
Add()
BinOp(left=BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))), op=Div(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
BinOp(left=BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1)), op=Div(), right=Name(id='a', ctx=Load()))
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
Num(n=5)
Load()
Load()
Num(n=5)
Pow()
Name(id='i', ctx=Load())
Load()
Name(id='breakpoints', ctx=Load())
Load()
Name(id='num_values', ctx=Load())
Sub()
Num(n=1)
Name(id='np', ctx=Load())
Load()
Name(id='constant', ctx=Load())
Div()
Name(id='x', ctx=Load())
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Name(id='qb', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Load()
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='qf', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Subscript(value=Name(id='qf', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Load()
Attribute(value=Name(id='reciprocal_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Load()
Name(id='ql', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Name(id='qb', ctx=Load())
Slice(lower=None, upper=None, step=None)
Load()
Load()
Attribute(value=Name(id='matrix_circuit', ctx=Load()), attr='num_ancillas', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
Tuple(elts=[Name(id='LinearSystemObservable', ctx=Load()), Name(id='BaseOperator', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='QuantumCircuit', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Tuple(elts=[List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load()), Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='QuantumInstance', ctx=Load())
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='LinearSystemObservable', ctx=Load())
Name(id='BaseOperator', ctx=Load())
Load()
List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='nl', ctx=Load())
Add()
Name(id='na', ctx=Load())
Name(id='zero_op', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='linalg', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='np', ctx=Load())
Load()
Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Attribute(value=Name(id='matrix', ctx=Load()), attr='conj', ctx=Load())
Load()
Load()
BinOp(left=Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: '), op=Add(), right=Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[]))
Add()
Str(s='. Matrix dimension: ')
Name(id='str', ctx=Load())
Subscript(value=Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Name(id='np', ctx=Load())
Load()
Name(id='type', ctx=Load())
Name(id='matrix', ctx=Load())
Load()
Name(id='np', ctx=Load())
Load()
Name(id='kappa', ctx=Load())
Add()
Num(n=1)
Name(id='np', ctx=Load())
Load()
Load()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load())), op=Div(), right=Name(id='a', ctx=Load()))
Pow()
Num(n=2)
Load()
BinOp(left=BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Mult(), right=BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())))
Div()
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())
Name(id='np', ctx=Load())
Load()
BinOp(left=Name(id='num_values', ctx=Load()), op=Sub(), right=Num(n=1))
Div()
Name(id='a', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='matrix_circuit', ctx=Load())
Load()
USub()
Num(n=1)
Load()
Num(n=0)
Load()
Name(id='qf', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='reciprocal_circuit', ctx=Load())
Load()
Load()
Load()
Name(id='matrix_circuit', ctx=Load())
Load()
Load()
Load()
Name(id='LinearSystemObservable', ctx=Load())
Name(id='BaseOperator', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='LinearSystemObservable', ctx=Load())), ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='BaseOperator', ctx=Load())), ctx=Load())
Load()
Name(id='QuantumCircuit', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Load()
List(elts=[Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())], ctx=Load())
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='float', ctx=Load())
Name(id='np', ctx=Load())
Load()
Load()
Name(id='matrix', ctx=Load())
Load()
Num(n=0)
Name(id='matrix', ctx=Load())
Load()
Str(s='Input vector dimension does not match input matrix dimension! Vector dimension: ')
Add()
Call(func=Name(id='str', ctx=Load()), args=[Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())], keywords=[])
Load()
Attribute(value=Name(id='matrix', ctx=Load()), attr='shape', ctx=Load())
Index(value=Num(n=0))
Load()
Load()
Load()
Load()
Load()
Load()
Load()
BinOp(left=Num(n=2), op=Mult(), right=Name(id='constant', ctx=Load()))
Div()
Name(id='a', ctx=Load())
BinOp(left=BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])), op=Mult(), right=Name(id='kappa', ctx=Load()))
Mult()
BinOp(left=BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load())), op=Sub(), right=Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load()))
Name(id='self', ctx=Load())
Load()
Load()
Name(id='num_values', ctx=Load())
Sub()
Num(n=1)
Load()
Load()
Load()
Load()
Num(n=0)
Load()
Load()
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='LinearSystemObservable', ctx=Load()))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='BaseOperator', ctx=Load()))
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())), ctx=Load())
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Load()
Load()
Load()
Load()
Name(id='str', ctx=Load())
Attribute(value=Name(id='vector_circuit', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='matrix', ctx=Load())
Load()
Num(n=0)
Num(n=2)
Mult()
Name(id='constant', ctx=Load())
Load()
BinOp(left=Num(n=16.23), op=Mult(), right=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[]))
Mult()
Name(id='kappa', ctx=Load())
BinOp(left=Num(n=2), op=Mult(), right=Name(id='kappa', ctx=Load()))
Sub()
Attribute(value=Name(id='self', ctx=Load()), attr='_epsilon_r', ctx=Load())
Load()
Load()
Load()
Name(id='LinearSystemObservable', ctx=Load())
Load()
Name(id='BaseOperator', ctx=Load())
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load()))
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='vector_circuit', ctx=Load())
Load()
Load()
Load()
Num(n=16.23)
Mult()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load()), args=[BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))], keywords=[])
Load()
Num(n=2)
Mult()
Name(id='kappa', ctx=Load())
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Tuple(elts=[Name(id='float', ctx=Load()), Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())], ctx=Load())
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='sqrt', ctx=Load())
BinOp(left=BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2)), op=Add(), right=BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2)))
Load()
Load()
Name(id='float', ctx=Load())
Subscript(value=Name(id='List', ctx=Load()), slice=Index(value=Name(id='float', ctx=Load())), ctx=Load())
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='float', ctx=Load())
Name(id='np', ctx=Load())
Load()
BinOp(left=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[]), op=Pow(), right=Num(n=2))
Add()
BinOp(left=BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2)), op=Pow(), right=Num(n=2))
Load()
Name(id='List', ctx=Load())
Index(value=Name(id='float', ctx=Load()))
Load()
Load()
Name(id='float', ctx=Load())
Load()
Name(id='float', ctx=Load())
Load()
Load()
Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load()), args=[Name(id='r', ctx=Load())], keywords=[])
Pow()
Num(n=2)
BinOp(left=Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load()), op=Div(), right=Num(n=2))
Pow()
Num(n=2)
Load()
Name(id='float', ctx=Load())
Load()
Load()
Attribute(value=Name(id='np', ctx=Load()), attr='log', ctx=Load())
Name(id='r', ctx=Load())
Attribute(value=Name(id='np', ctx=Load()), attr='pi', ctx=Load())
Div()
Num(n=2)
Load()
Name(id='np', ctx=Load())
Load()
Load()
Name(id='np', ctx=Load())
Load()
Load()
Load()
  metric  value
0     NC      0
DONE!
