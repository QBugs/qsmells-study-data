Python 3.7.8
Module(body=[Expr(value=Str(s='The Quantum Phase Estimation Algorithm.')), Import(names=[alias(name='warnings', asname=None)]), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0), Import(names=[alias(name='numpy', asname=None)]), ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None)], level=0), Import(names=[alias(name='qiskit', asname=None)]), ImportFrom(module='qiskit', names=[alias(name='circuit', asname=None)], level=0), ImportFrom(module='qiskit.circuit.classicalregister', names=[alias(name='ClassicalRegister', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='qiskit.result', names=[alias(name='Result', asname=None)], level=0), ImportFrom(module='phase_estimation_result', names=[alias(name='PhaseEstimationResult', asname=None), alias(name='_sort_phases', asname=None)], level=1), ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimator', asname=None)], level=1), ClassDef(name='PhaseEstimation', bases=[Name(id='PhaseEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Run the Quantum Phase Estimation (QPE) algorithm.\n\n    This runs QPE with a multi-qubit register for reading the phases [1]\n    of input states.\n\n    The algorithm takes as input a unitary :math:`U` and a state :math:`|\\psi\\rangle`,\n    which may be written\n\n    .. math::\n\n        |\\psi\\rangle = \\sum_j c_j |\\phi_j\\rangle,\n\n    where :math:`|\\phi_j\\rangle` are eigenstates of :math:`U`. We prepare the quantum register\n    in the state :math:`|\\psi\\rangle` then apply :math:`U` leaving the register in the state\n\n    .. math::\n\n        U|\\psi\\rangle = \\sum_j \\exp(i \\phi_j) c_j |\\phi_j\\rangle.\n\n    In the ideal case, one then measures the phase :math:`\\phi_j` with probability\n    :math:`|c_j|^2`.  In practice, many (or all) of the bit strings may be measured due to\n    noise and the possibility that :math:`\\phi_j` may not be representable exactly by the\n    output register. In the latter case the probability for each eigenphase will be spread\n    across bitstrings, with amplitudes that decrease with distance from the bitstring most\n    closely approximating the eigenphase.\n\n    The main input to the constructor is the number of qubits in the phase-reading register.\n    For phase estimation, there are two methods:\n\n    first. `estimate`, which takes a state preparation circuit to prepare an input state, and\n      a unitary that will act on the the input state. In this case, an instance of\n      :class:`qiskit.circuit.PhaseEstimation`, a QPE circuit, containing\n      the state preparation and input unitary will be constructed.\n    second. `estimate_from_pe_circuit`, which takes a quantum-phase-estimation circuit in which\n      the unitary and state preparation are already embedded.\n\n    In both estimation methods, the QPE circuit is run on a backend\n    and the frequencies or counts of the phases represented by bitstrings\n    are recorded. The results are returned as an instance of\n    :class:`~qiskit.algorithms.phase_estimator_result.PhaseEstimationResult`.\n\n    **Reference:**\n\n    [1]: Michael A. Nielsen and Isaac L. Chuang. 2011.\n         Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n         Cambridge University Press, New York, NY, USA.\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_evaluation_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n                be estimated as a binary string with this many bits.\n            quantum_instance: The quantum instance on which the circuit will be run.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_measurements_added', ctx=Store())], value=NameConstant(value=False)), If(test=Compare(left=Name(id='num_evaluation_qubits', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())], value=Name(id='num_evaluation_qubits', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Return the circuit to be executed to estimate phases.\n\n        This circuit includes as sub-circuits the core phase estimation circuit,\n        with the addition of the state-preparation circuit and possibly measurement instructions.\n        ')), Assign(targets=[Name(id='num_evaluation_qubits', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), Name(id='unitary', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))]))], orelse=[]), Return(value=Name(id='pe_circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_add_measurement_if_required', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())), body=[Assign(targets=[Name(id='regname', ctx=Store())], value=Str(s='meas')), Assign(targets=[Name(id='creg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='_compute_phases', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='circuit_result', annotation=Name(id='Result', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute frequencies/counts of phases from the result of running the QPE circuit.\n\n        How the frequencies are computed depends on whether the backend computes amplitude or\n        samples outcomes.\n\n        1) If the backend is a statevector simulator, then the reduced density matrix of the\n        phase-reading register is computed from the combined phase-reading- and input-state\n        registers. The elements of the diagonal :math:`(i, i)` give the probability to measure the\n        each of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\n        gives the state of the phase-reading register with the LSB leftmost when interpreted as a\n        phase. In order to maintain the compact representation, the phases are maintained as decimal\n        integers.  They may be converted to other forms via the results object,\n        `PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n         2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\n        binary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\n        converted to frequencies. Then the keys are sorted according to increasing phase, so that\n        they can be easily understood when displaying or plotting a histogram.\n\n        Args:\n            num_unitary_qubits: The number of qubits in the unitary.\n            circuit_result: the result object returned by the backend that ran the QPE circuit.\n\n        Returns:\n            Either a dict or numpy.ndarray representing the frequencies of the phases.\n\n        ')), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='evaluation_density_matrix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='num_shots', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load())), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))]))]), Return(value=Name(id='phases', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate_from_pe_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the the phase estimation algorithm on a phase estimation circuit\n\n        Args:\n            pe_circuit: The phase estimation circuit.\n            num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load()), args=[Name(id='num_unitary_qubits', ctx=Load()), Name(id='circuit_result', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='PhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load())), keyword(arg='phases', value=Name(id='phases', ctx=Load()))]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='pe_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='num_unitary_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Build a phase estimation circuit and run the corresponding algorithm.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n                will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                measured.  If this parameter is omitted, no preparation circuit\n                will be run and input state will be the all-zero state in the\n                computational basis.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), If(test=Compare(left=Name(id='unitary', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)])]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load()), Name(id='num_unitary_qubits', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load()))], decorator_list=[])])
Expr(value=Str(s='The Quantum Phase Estimation Algorithm.'))
Import(names=[alias(name='warnings', asname=None)])
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0)
Import(names=[alias(name='numpy', asname=None)])
ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None)], level=0)
Import(names=[alias(name='qiskit', asname=None)])
ImportFrom(module='qiskit', names=[alias(name='circuit', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.classicalregister', names=[alias(name='ClassicalRegister', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='qiskit.result', names=[alias(name='Result', asname=None)], level=0)
ImportFrom(module='phase_estimation_result', names=[alias(name='PhaseEstimationResult', asname=None), alias(name='_sort_phases', asname=None)], level=1)
ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimator', asname=None)], level=1)
ClassDef(name='PhaseEstimation', bases=[Name(id='PhaseEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Run the Quantum Phase Estimation (QPE) algorithm.\n\n    This runs QPE with a multi-qubit register for reading the phases [1]\n    of input states.\n\n    The algorithm takes as input a unitary :math:`U` and a state :math:`|\\psi\\rangle`,\n    which may be written\n\n    .. math::\n\n        |\\psi\\rangle = \\sum_j c_j |\\phi_j\\rangle,\n\n    where :math:`|\\phi_j\\rangle` are eigenstates of :math:`U`. We prepare the quantum register\n    in the state :math:`|\\psi\\rangle` then apply :math:`U` leaving the register in the state\n\n    .. math::\n\n        U|\\psi\\rangle = \\sum_j \\exp(i \\phi_j) c_j |\\phi_j\\rangle.\n\n    In the ideal case, one then measures the phase :math:`\\phi_j` with probability\n    :math:`|c_j|^2`.  In practice, many (or all) of the bit strings may be measured due to\n    noise and the possibility that :math:`\\phi_j` may not be representable exactly by the\n    output register. In the latter case the probability for each eigenphase will be spread\n    across bitstrings, with amplitudes that decrease with distance from the bitstring most\n    closely approximating the eigenphase.\n\n    The main input to the constructor is the number of qubits in the phase-reading register.\n    For phase estimation, there are two methods:\n\n    first. `estimate`, which takes a state preparation circuit to prepare an input state, and\n      a unitary that will act on the the input state. In this case, an instance of\n      :class:`qiskit.circuit.PhaseEstimation`, a QPE circuit, containing\n      the state preparation and input unitary will be constructed.\n    second. `estimate_from_pe_circuit`, which takes a quantum-phase-estimation circuit in which\n      the unitary and state preparation are already embedded.\n\n    In both estimation methods, the QPE circuit is run on a backend\n    and the frequencies or counts of the phases represented by bitstrings\n    are recorded. The results are returned as an instance of\n    :class:`~qiskit.algorithms.phase_estimator_result.PhaseEstimationResult`.\n\n    **Reference:**\n\n    [1]: Michael A. Nielsen and Isaac L. Chuang. 2011.\n         Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n         Cambridge University Press, New York, NY, USA.\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_evaluation_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n                be estimated as a binary string with this many bits.\n            quantum_instance: The quantum instance on which the circuit will be run.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_measurements_added', ctx=Store())], value=NameConstant(value=False)), If(test=Compare(left=Name(id='num_evaluation_qubits', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())], value=Name(id='num_evaluation_qubits', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Return the circuit to be executed to estimate phases.\n\n        This circuit includes as sub-circuits the core phase estimation circuit,\n        with the addition of the state-preparation circuit and possibly measurement instructions.\n        ')), Assign(targets=[Name(id='num_evaluation_qubits', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), Name(id='unitary', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))]))], orelse=[]), Return(value=Name(id='pe_circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_add_measurement_if_required', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())), body=[Assign(targets=[Name(id='regname', ctx=Store())], value=Str(s='meas')), Assign(targets=[Name(id='creg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='_compute_phases', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='circuit_result', annotation=Name(id='Result', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute frequencies/counts of phases from the result of running the QPE circuit.\n\n        How the frequencies are computed depends on whether the backend computes amplitude or\n        samples outcomes.\n\n        1) If the backend is a statevector simulator, then the reduced density matrix of the\n        phase-reading register is computed from the combined phase-reading- and input-state\n        registers. The elements of the diagonal :math:`(i, i)` give the probability to measure the\n        each of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\n        gives the state of the phase-reading register with the LSB leftmost when interpreted as a\n        phase. In order to maintain the compact representation, the phases are maintained as decimal\n        integers.  They may be converted to other forms via the results object,\n        `PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n         2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\n        binary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\n        converted to frequencies. Then the keys are sorted according to increasing phase, so that\n        they can be easily understood when displaying or plotting a histogram.\n\n        Args:\n            num_unitary_qubits: The number of qubits in the unitary.\n            circuit_result: the result object returned by the backend that ran the QPE circuit.\n\n        Returns:\n            Either a dict or numpy.ndarray representing the frequencies of the phases.\n\n        ')), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='evaluation_density_matrix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='num_shots', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load())), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))]))]), Return(value=Name(id='phases', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate_from_pe_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the the phase estimation algorithm on a phase estimation circuit\n\n        Args:\n            pe_circuit: The phase estimation circuit.\n            num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load()), args=[Name(id='num_unitary_qubits', ctx=Load()), Name(id='circuit_result', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='PhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load())), keyword(arg='phases', value=Name(id='phases', ctx=Load()))]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='pe_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='num_unitary_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Build a phase estimation circuit and run the corresponding algorithm.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n                will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                measured.  If this parameter is omitted, no preparation circuit\n                will be run and input state will be the all-zero state in the\n                computational basis.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), If(test=Compare(left=Name(id='unitary', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)])]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load()), Name(id='num_unitary_qubits', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load()))], decorator_list=[])
Str(s='The Quantum Phase Estimation Algorithm.')
alias(name='warnings', asname=None)
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='numpy', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='qiskit', asname=None)
alias(name='circuit', asname=None)
alias(name='ClassicalRegister', asname=None)
alias(name='Backend', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='Result', asname=None)
alias(name='PhaseEstimationResult', asname=None)
alias(name='_sort_phases', asname=None)
alias(name='PhaseEstimator', asname=None)
Name(id='PhaseEstimator', ctx=Load())
Expr(value=Str(s='Run the Quantum Phase Estimation (QPE) algorithm.\n\n    This runs QPE with a multi-qubit register for reading the phases [1]\n    of input states.\n\n    The algorithm takes as input a unitary :math:`U` and a state :math:`|\\psi\\rangle`,\n    which may be written\n\n    .. math::\n\n        |\\psi\\rangle = \\sum_j c_j |\\phi_j\\rangle,\n\n    where :math:`|\\phi_j\\rangle` are eigenstates of :math:`U`. We prepare the quantum register\n    in the state :math:`|\\psi\\rangle` then apply :math:`U` leaving the register in the state\n\n    .. math::\n\n        U|\\psi\\rangle = \\sum_j \\exp(i \\phi_j) c_j |\\phi_j\\rangle.\n\n    In the ideal case, one then measures the phase :math:`\\phi_j` with probability\n    :math:`|c_j|^2`.  In practice, many (or all) of the bit strings may be measured due to\n    noise and the possibility that :math:`\\phi_j` may not be representable exactly by the\n    output register. In the latter case the probability for each eigenphase will be spread\n    across bitstrings, with amplitudes that decrease with distance from the bitstring most\n    closely approximating the eigenphase.\n\n    The main input to the constructor is the number of qubits in the phase-reading register.\n    For phase estimation, there are two methods:\n\n    first. `estimate`, which takes a state preparation circuit to prepare an input state, and\n      a unitary that will act on the the input state. In this case, an instance of\n      :class:`qiskit.circuit.PhaseEstimation`, a QPE circuit, containing\n      the state preparation and input unitary will be constructed.\n    second. `estimate_from_pe_circuit`, which takes a quantum-phase-estimation circuit in which\n      the unitary and state preparation are already embedded.\n\n    In both estimation methods, the QPE circuit is run on a backend\n    and the frequencies or counts of the phases represented by bitstrings\n    are recorded. The results are returned as an instance of\n    :class:`~qiskit.algorithms.phase_estimator_result.PhaseEstimationResult`.\n\n    **Reference:**\n\n    [1]: Michael A. Nielsen and Isaac L. Chuang. 2011.\n         Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n         Cambridge University Press, New York, NY, USA.\n\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_evaluation_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n                be estimated as a binary string with this many bits.\n            quantum_instance: The quantum instance on which the circuit will be run.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_measurements_added', ctx=Store())], value=NameConstant(value=False)), If(test=Compare(left=Name(id='num_evaluation_qubits', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())], value=Name(id='num_evaluation_qubits', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Return the circuit to be executed to estimate phases.\n\n        This circuit includes as sub-circuits the core phase estimation circuit,\n        with the addition of the state-preparation circuit and possibly measurement instructions.\n        ')), Assign(targets=[Name(id='num_evaluation_qubits', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), Name(id='unitary', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))]))], orelse=[]), Return(value=Name(id='pe_circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='_add_measurement_if_required', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())), body=[Assign(targets=[Name(id='regname', ctx=Store())], value=Str(s='meas')), Assign(targets=[Name(id='creg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=None)
FunctionDef(name='_compute_phases', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='circuit_result', annotation=Name(id='Result', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute frequencies/counts of phases from the result of running the QPE circuit.\n\n        How the frequencies are computed depends on whether the backend computes amplitude or\n        samples outcomes.\n\n        1) If the backend is a statevector simulator, then the reduced density matrix of the\n        phase-reading register is computed from the combined phase-reading- and input-state\n        registers. The elements of the diagonal :math:`(i, i)` give the probability to measure the\n        each of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\n        gives the state of the phase-reading register with the LSB leftmost when interpreted as a\n        phase. In order to maintain the compact representation, the phases are maintained as decimal\n        integers.  They may be converted to other forms via the results object,\n        `PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n         2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\n        binary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\n        converted to frequencies. Then the keys are sorted according to increasing phase, so that\n        they can be easily understood when displaying or plotting a histogram.\n\n        Args:\n            num_unitary_qubits: The number of qubits in the unitary.\n            circuit_result: the result object returned by the backend that ran the QPE circuit.\n\n        Returns:\n            Either a dict or numpy.ndarray representing the frequencies of the phases.\n\n        ')), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='evaluation_density_matrix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='num_shots', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load())), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))]))]), Return(value=Name(id='phases', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='estimate_from_pe_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the the phase estimation algorithm on a phase estimation circuit\n\n        Args:\n            pe_circuit: The phase estimation circuit.\n            num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load()), args=[Name(id='num_unitary_qubits', ctx=Load()), Name(id='circuit_result', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='PhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load())), keyword(arg='phases', value=Name(id='phases', ctx=Load()))]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load()))
FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='pe_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='num_unitary_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Build a phase estimation circuit and run the corresponding algorithm.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n                will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                measured.  If this parameter is omitted, no preparation circuit\n                will be run and input state will be the all-zero state in the\n                computational basis.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), If(test=Compare(left=Name(id='unitary', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)])]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load()), Name(id='num_unitary_qubits', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load()))
Load()
Str(s='Run the Quantum Phase Estimation (QPE) algorithm.\n\n    This runs QPE with a multi-qubit register for reading the phases [1]\n    of input states.\n\n    The algorithm takes as input a unitary :math:`U` and a state :math:`|\\psi\\rangle`,\n    which may be written\n\n    .. math::\n\n        |\\psi\\rangle = \\sum_j c_j |\\phi_j\\rangle,\n\n    where :math:`|\\phi_j\\rangle` are eigenstates of :math:`U`. We prepare the quantum register\n    in the state :math:`|\\psi\\rangle` then apply :math:`U` leaving the register in the state\n\n    .. math::\n\n        U|\\psi\\rangle = \\sum_j \\exp(i \\phi_j) c_j |\\phi_j\\rangle.\n\n    In the ideal case, one then measures the phase :math:`\\phi_j` with probability\n    :math:`|c_j|^2`.  In practice, many (or all) of the bit strings may be measured due to\n    noise and the possibility that :math:`\\phi_j` may not be representable exactly by the\n    output register. In the latter case the probability for each eigenphase will be spread\n    across bitstrings, with amplitudes that decrease with distance from the bitstring most\n    closely approximating the eigenphase.\n\n    The main input to the constructor is the number of qubits in the phase-reading register.\n    For phase estimation, there are two methods:\n\n    first. `estimate`, which takes a state preparation circuit to prepare an input state, and\n      a unitary that will act on the the input state. In this case, an instance of\n      :class:`qiskit.circuit.PhaseEstimation`, a QPE circuit, containing\n      the state preparation and input unitary will be constructed.\n    second. `estimate_from_pe_circuit`, which takes a quantum-phase-estimation circuit in which\n      the unitary and state preparation are already embedded.\n\n    In both estimation methods, the QPE circuit is run on a backend\n    and the frequencies or counts of the phases represented by bitstrings\n    are recorded. The results are returned as an instance of\n    :class:`~qiskit.algorithms.phase_estimator_result.PhaseEstimationResult`.\n\n    **Reference:**\n\n    [1]: Michael A. Nielsen and Isaac L. Chuang. 2011.\n         Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n         Cambridge University Press, New York, NY, USA.\n\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_evaluation_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='\n        Args:\n            num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n                be estimated as a binary string with this many bits.\n            quantum_instance: The quantum instance on which the circuit will be run.\n        '))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_measurements_added', ctx=Store())], value=NameConstant(value=False))
If(test=Compare(left=Name(id='num_evaluation_qubits', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())], value=Name(id='num_evaluation_qubits', ctx=Load()))], orelse=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='Return the circuit to be executed to estimate phases.\n\n        This circuit includes as sub-circuits the core phase estimation circuit,\n        with the addition of the state-preparation circuit and possibly measurement instructions.\n        '))
Assign(targets=[Name(id='num_evaluation_qubits', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()))
Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))
Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), Name(id='unitary', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))]))], orelse=[])
Return(value=Name(id='pe_circuit', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())), body=[Assign(targets=[Name(id='regname', ctx=Store())], value=Str(s='meas')), Assign(targets=[Name(id='creg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])
Return(value=Name(id='circuit', ctx=Load()))
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='circuit_result', annotation=Name(id='Result', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Compute frequencies/counts of phases from the result of running the QPE circuit.\n\n        How the frequencies are computed depends on whether the backend computes amplitude or\n        samples outcomes.\n\n        1) If the backend is a statevector simulator, then the reduced density matrix of the\n        phase-reading register is computed from the combined phase-reading- and input-state\n        registers. The elements of the diagonal :math:`(i, i)` give the probability to measure the\n        each of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\n        gives the state of the phase-reading register with the LSB leftmost when interpreted as a\n        phase. In order to maintain the compact representation, the phases are maintained as decimal\n        integers.  They may be converted to other forms via the results object,\n        `PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n         2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\n        binary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\n        converted to frequencies. Then the keys are sorted according to increasing phase, so that\n        they can be easily understood when displaying or plotting a histogram.\n\n        Args:\n            num_unitary_qubits: The number of qubits in the unitary.\n            circuit_result: the result object returned by the backend that ran the QPE circuit.\n\n        Returns:\n            Either a dict or numpy.ndarray representing the frequencies of the phases.\n\n        '))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='evaluation_density_matrix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='num_shots', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load())), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))]))])
Return(value=Name(id='phases', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Run the the phase estimation algorithm on a phase estimation circuit\n\n        Args:\n            pe_circuit: The phase estimation circuit.\n            num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        '))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='circuit_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load()), args=[Name(id='num_unitary_qubits', ctx=Load()), Name(id='circuit_result', ctx=Load())], keywords=[]))
Return(value=Call(func=Name(id='PhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load())), keyword(arg='phases', value=Name(id='phases', ctx=Load()))]))
Name(id='PhaseEstimationResult', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='pe_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='num_unitary_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='Build a phase estimation circuit and run the corresponding algorithm.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n                will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                measured.  If this parameter is omitted, no preparation circuit\n                will be run and input state will be the all-zero state in the\n                computational basis.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        '))
If(test=Compare(left=Name(id='unitary', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)])])
Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load()), Name(id='num_unitary_qubits', ctx=Load())], keywords=[]))
Name(id='PhaseEstimationResult', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='num_evaluation_qubits', annotation=Name(id='int', ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='\n        Args:\n            num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n                be estimated as a binary string with this many bits.\n            quantum_instance: The quantum instance on which the circuit will be run.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_measurements_added', ctx=Store())
NameConstant(value=False)
Compare(left=Name(id='num_evaluation_qubits', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())], value=Name(id='num_evaluation_qubits', ctx=Load()))
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='Return the circuit to be executed to estimate phases.\n\n        This circuit includes as sub-circuits the core phase estimation circuit,\n        with the addition of the state-preparation circuit and possibly measurement instructions.\n        ')
Name(id='num_evaluation_qubits', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
Name(id='num_unitary_qubits', ctx=Store())
Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='pe_circuit', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), Name(id='unitary', ctx=Load())], keywords=[])
Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))]))
Name(id='pe_circuit', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='pe_circuit', annotation=None)
UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()))
Assign(targets=[Name(id='regname', ctx=Store())], value=Str(s='meas'))
Assign(targets=[Name(id='creg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[]))
Name(id='circuit', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))
arg(arg='circuit_result', annotation=Name(id='Result', ctx=Load()))
Str(s='Compute frequencies/counts of phases from the result of running the QPE circuit.\n\n        How the frequencies are computed depends on whether the backend computes amplitude or\n        samples outcomes.\n\n        1) If the backend is a statevector simulator, then the reduced density matrix of the\n        phase-reading register is computed from the combined phase-reading- and input-state\n        registers. The elements of the diagonal :math:`(i, i)` give the probability to measure the\n        each of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\n        gives the state of the phase-reading register with the LSB leftmost when interpreted as a\n        phase. In order to maintain the compact representation, the phases are maintained as decimal\n        integers.  They may be converted to other forms via the results object,\n        `PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n         2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\n        binary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\n        converted to frequencies. Then the keys are sorted according to increasing phase, so that\n        they can be easily understood when displaying or plotting a histogram.\n\n        Args:\n            num_unitary_qubits: The number of qubits in the unitary.\n            circuit_result: the result object returned by the backend that ran the QPE circuit.\n\n        Returns:\n            Either a dict or numpy.ndarray representing the frequencies of the phases.\n\n        ')
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='evaluation_density_matrix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[]))
Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='num_shots', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load()))
Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='phases', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))
Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))]))
Name(id='phases', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='pe_circuit', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))
Str(s='Run the the phase estimation algorithm on a phase estimation circuit\n\n        Args:\n            pe_circuit: The phase estimation circuit.\n            num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])
Name(id='circuit_result', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])
  Found a method call call at line 201
Name(id='phases', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load()), args=[Name(id='num_unitary_qubits', ctx=Load()), Name(id='circuit_result', ctx=Load())], keywords=[])
Call(func=Name(id='PhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load())), keyword(arg='phases', value=Name(id='phases', ctx=Load()))])
Load()
arg(arg='self', annotation=None)
arg(arg='unitary', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='pe_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='num_unitary_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
Str(s='Build a phase estimation circuit and run the corresponding algorithm.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n                will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                measured.  If this parameter is omitted, no preparation circuit\n                will be run and input state will be the all-zero state in the\n                computational basis.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')
Compare(left=Name(id='unitary', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))
If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)])
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load()), Name(id='num_unitary_qubits', ctx=Load())], keywords=[])
Load()
Name(id='int', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='num_evaluation_qubits', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())
Name(id='num_evaluation_qubits', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='QuantumCircuit', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Store()
Name(id='unitary', ctx=Load())
Load()
Store()
Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load())
Name(id='num_evaluation_qubits', ctx=Load())
Name(id='unitary', ctx=Load())
Name(id='state_preparation', ctx=Load())
IsNot()
NameConstant(value=None)
Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))])
Load()
Not()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Name(id='regname', ctx=Store())
Str(s='meas')
Name(id='creg', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[])
Load()
Name(id='int', ctx=Load())
Name(id='Result', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='state_vec', ctx=Store())
Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[])
Name(id='evaluation_density_matrix', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[])
Name(id='phases', ctx=Store())
Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[])
Name(id='num_shots', ctx=Store())
Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load())
Name(id='counts', ctx=Store())
Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[])
Name(id='phases', ctx=Store())
DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])
Name(id='phases', ctx=Store())
Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[])
Name(id='phases', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))])
Load()
Load()
Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Name(id='int', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load())
Name(id='pe_circuit', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='pe_circuit', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load())
Name(id='num_unitary_qubits', ctx=Load())
Name(id='circuit_result', ctx=Load())
Name(id='PhaseEstimationResult', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load()))
keyword(arg='phases', value=Name(id='phases', ctx=Load()))
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='unitary', ctx=Load())
IsNot()
NameConstant(value=None)
Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)
Name(id='pe_circuit', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])
Name(id='num_unitary_qubits', ctx=Store())
Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())
Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)
Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load())
Name(id='pe_circuit', ctx=Load())
Name(id='num_unitary_qubits', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Load()
Load()
Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load())
Name(id='state_preparation', ctx=Load())
keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[]))
keyword(arg='inplace', value=NameConstant(value=True))
keyword(arg='front', value=NameConstant(value=True))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Store()
Store()
Name(id='ClassicalRegister', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
Name(id='regname', ctx=Load())
Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load())
Name(id='creg', ctx=Load())
Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load())
Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load())
Name(id='state_vec', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])
Store()
Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load())
Store()
Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Store()
Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load())
Store()
Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load()))
comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)
Store()
Name(id='_sort_phases', ctx=Load())
Name(id='phases', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())
Name(id='phases', ctx=Load())
keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load()))
keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))
Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='circuit_result', ctx=Load())
Name(id='phases', ctx=Load())
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Name(id='pe_circuit', ctx=Load())
IsNot()
NameConstant(value=None)
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='unitary', ctx=Load())
Name(id='state_preparation', ctx=Load())
Store()
Name(id='unitary', ctx=Load())
Load()
Name(id='pe_circuit', ctx=Load())
IsNot()
NameConstant(value=None)
Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[])
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Name(id='pe_circuit', ctx=Load())
Load()
Load()
Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])
NameConstant(value=True)
NameConstant(value=True)
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='pe_circuit', ctx=Load())
Load()
Load()
Name(id='pe_circuit', ctx=Load())
Load()
Name(id='pe_circuit', ctx=Load())
Load()
Name(id='range', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
Name(id='range', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
Load()
Name(id='circuit_result', ctx=Load())
Load()
Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load())
Load()
Load()
Name(id='range', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))
Name(id='evaluation_density_matrix', ctx=Load())
Load()
Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='circuit_result', ctx=Load())
Load()
Name(id='k', ctx=Load())
Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load())
Div()
Name(id='num_shots', ctx=Load())
Name(id='k', ctx=Store())
Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])
Load()
Load()
Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load())
Load()
Load()
Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())
Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load())
Name(id='numpy', ctx=Load())
Load()
Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Name(id='ValueError', ctx=Load())
Str(s='Only one of `pe_circuit` and `unitary` may be passed.')
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load())
Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.')
Name(id='DeprecationWarning', ctx=Load())
keyword(arg='stacklevel', value=Num(n=2))
Name(id='ValueError', ctx=Load())
Str(s='One of `pe_circuit` and `unitary` must be passed.')
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='range', ctx=Load())
Name(id='num_evaluation_qubits', ctx=Load())
BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='qiskit', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
Add()
Name(id='num_unitary_qubits', ctx=Load())
Load()
Name(id='circuit_result', ctx=Load())
Load()
Num(n=0)
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='counts', ctx=Load())
Index(value=Name(id='k', ctx=Load()))
Load()
Load()
Store()
Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load())
Name(id='qiskit', ctx=Load())
Load()
Name(id='counts', ctx=Load())
Load()
Name(id='counts', ctx=Load())
Load()
Load()
Name(id='qiskit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='warnings', ctx=Load())
Load()
Load()
Num(n=2)
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='num_evaluation_qubits', ctx=Load())
Add()
Name(id='num_unitary_qubits', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
USub()
Num(n=1)
Load()
Name(id='k', ctx=Load())
Name(id='counts', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Module(body=[Expr(value=Str(s='The Quantum Phase Estimation Algorithm.')), Import(names=[alias(name='warnings', asname=None)]), ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0), Import(names=[alias(name='numpy', asname=None)]), ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None)], level=0), Import(names=[alias(name='qiskit', asname=None)]), ImportFrom(module='qiskit', names=[alias(name='circuit', asname=None)], level=0), ImportFrom(module='qiskit.circuit.classicalregister', names=[alias(name='ClassicalRegister', asname=None)], level=0), ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0), ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0), ImportFrom(module='qiskit.result', names=[alias(name='Result', asname=None)], level=0), ImportFrom(module='phase_estimation_result', names=[alias(name='PhaseEstimationResult', asname=None), alias(name='_sort_phases', asname=None)], level=1), ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimator', asname=None)], level=1), ClassDef(name='PhaseEstimation', bases=[Name(id='PhaseEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Run the Quantum Phase Estimation (QPE) algorithm.\n\n    This runs QPE with a multi-qubit register for reading the phases [1]\n    of input states.\n\n    The algorithm takes as input a unitary :math:`U` and a state :math:`|\\psi\\rangle`,\n    which may be written\n\n    .. math::\n\n        |\\psi\\rangle = \\sum_j c_j |\\phi_j\\rangle,\n\n    where :math:`|\\phi_j\\rangle` are eigenstates of :math:`U`. We prepare the quantum register\n    in the state :math:`|\\psi\\rangle` then apply :math:`U` leaving the register in the state\n\n    .. math::\n\n        U|\\psi\\rangle = \\sum_j \\exp(i \\phi_j) c_j |\\phi_j\\rangle.\n\n    In the ideal case, one then measures the phase :math:`\\phi_j` with probability\n    :math:`|c_j|^2`.  In practice, many (or all) of the bit strings may be measured due to\n    noise and the possibility that :math:`\\phi_j` may not be representable exactly by the\n    output register. In the latter case the probability for each eigenphase will be spread\n    across bitstrings, with amplitudes that decrease with distance from the bitstring most\n    closely approximating the eigenphase.\n\n    The main input to the constructor is the number of qubits in the phase-reading register.\n    For phase estimation, there are two methods:\n\n    first. `estimate`, which takes a state preparation circuit to prepare an input state, and\n      a unitary that will act on the the input state. In this case, an instance of\n      :class:`qiskit.circuit.PhaseEstimation`, a QPE circuit, containing\n      the state preparation and input unitary will be constructed.\n    second. `estimate_from_pe_circuit`, which takes a quantum-phase-estimation circuit in which\n      the unitary and state preparation are already embedded.\n\n    In both estimation methods, the QPE circuit is run on a backend\n    and the frequencies or counts of the phases represented by bitstrings\n    are recorded. The results are returned as an instance of\n    :class:`~qiskit.algorithms.phase_estimator_result.PhaseEstimationResult`.\n\n    **Reference:**\n\n    [1]: Michael A. Nielsen and Isaac L. Chuang. 2011.\n         Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n         Cambridge University Press, New York, NY, USA.\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_evaluation_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n                be estimated as a binary string with this many bits.\n            quantum_instance: The quantum instance on which the circuit will be run.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_measurements_added', ctx=Store())], value=NameConstant(value=False)), If(test=Compare(left=Name(id='num_evaluation_qubits', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())], value=Name(id='num_evaluation_qubits', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Return the circuit to be executed to estimate phases.\n\n        This circuit includes as sub-circuits the core phase estimation circuit,\n        with the addition of the state-preparation circuit and possibly measurement instructions.\n        ')), Assign(targets=[Name(id='num_evaluation_qubits', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), Name(id='unitary', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))]))], orelse=[]), Return(value=Name(id='pe_circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_add_measurement_if_required', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())), body=[Assign(targets=[Name(id='regname', ctx=Store())], value=Str(s='meas')), Assign(targets=[Name(id='creg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='_compute_phases', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='circuit_result', annotation=Name(id='Result', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute frequencies/counts of phases from the result of running the QPE circuit.\n\n        How the frequencies are computed depends on whether the backend computes amplitude or\n        samples outcomes.\n\n        1) If the backend is a statevector simulator, then the reduced density matrix of the\n        phase-reading register is computed from the combined phase-reading- and input-state\n        registers. The elements of the diagonal :math:`(i, i)` give the probability to measure the\n        each of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\n        gives the state of the phase-reading register with the LSB leftmost when interpreted as a\n        phase. In order to maintain the compact representation, the phases are maintained as decimal\n        integers.  They may be converted to other forms via the results object,\n        `PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n         2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\n        binary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\n        converted to frequencies. Then the keys are sorted according to increasing phase, so that\n        they can be easily understood when displaying or plotting a histogram.\n\n        Args:\n            num_unitary_qubits: The number of qubits in the unitary.\n            circuit_result: the result object returned by the backend that ran the QPE circuit.\n\n        Returns:\n            Either a dict or numpy.ndarray representing the frequencies of the phases.\n\n        ')), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='evaluation_density_matrix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='num_shots', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load())), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))]))]), Return(value=Name(id='phases', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate_from_pe_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the the phase estimation algorithm on a phase estimation circuit\n\n        Args:\n            pe_circuit: The phase estimation circuit.\n            num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load()), args=[Name(id='num_unitary_qubits', ctx=Load()), Name(id='circuit_result', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='PhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load())), keyword(arg='phases', value=Name(id='phases', ctx=Load()))]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='pe_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='num_unitary_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Build a phase estimation circuit and run the corresponding algorithm.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n                will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                measured.  If this parameter is omitted, no preparation circuit\n                will be run and input state will be the all-zero state in the\n                computational basis.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), If(test=Compare(left=Name(id='unitary', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)])]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load()), Name(id='num_unitary_qubits', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load()))], decorator_list=[])])
Expr(value=Str(s='The Quantum Phase Estimation Algorithm.'))
Import(names=[alias(name='warnings', asname=None)])
ImportFrom(module='typing', names=[alias(name='Optional', asname=None), alias(name='Union', asname=None)], level=0)
Import(names=[alias(name='numpy', asname=None)])
ImportFrom(module='qiskit.circuit', names=[alias(name='QuantumCircuit', asname=None)], level=0)
Import(names=[alias(name='qiskit', asname=None)])
ImportFrom(module='qiskit', names=[alias(name='circuit', asname=None)], level=0)
ImportFrom(module='qiskit.circuit.classicalregister', names=[alias(name='ClassicalRegister', asname=None)], level=0)
ImportFrom(module='qiskit.providers', names=[alias(name='Backend', asname=None)], level=0)
ImportFrom(module='qiskit.utils', names=[alias(name='QuantumInstance', asname=None)], level=0)
ImportFrom(module='qiskit.result', names=[alias(name='Result', asname=None)], level=0)
ImportFrom(module='phase_estimation_result', names=[alias(name='PhaseEstimationResult', asname=None), alias(name='_sort_phases', asname=None)], level=1)
ImportFrom(module='phase_estimator', names=[alias(name='PhaseEstimator', asname=None)], level=1)
ClassDef(name='PhaseEstimation', bases=[Name(id='PhaseEstimator', ctx=Load())], keywords=[], body=[Expr(value=Str(s='Run the Quantum Phase Estimation (QPE) algorithm.\n\n    This runs QPE with a multi-qubit register for reading the phases [1]\n    of input states.\n\n    The algorithm takes as input a unitary :math:`U` and a state :math:`|\\psi\\rangle`,\n    which may be written\n\n    .. math::\n\n        |\\psi\\rangle = \\sum_j c_j |\\phi_j\\rangle,\n\n    where :math:`|\\phi_j\\rangle` are eigenstates of :math:`U`. We prepare the quantum register\n    in the state :math:`|\\psi\\rangle` then apply :math:`U` leaving the register in the state\n\n    .. math::\n\n        U|\\psi\\rangle = \\sum_j \\exp(i \\phi_j) c_j |\\phi_j\\rangle.\n\n    In the ideal case, one then measures the phase :math:`\\phi_j` with probability\n    :math:`|c_j|^2`.  In practice, many (or all) of the bit strings may be measured due to\n    noise and the possibility that :math:`\\phi_j` may not be representable exactly by the\n    output register. In the latter case the probability for each eigenphase will be spread\n    across bitstrings, with amplitudes that decrease with distance from the bitstring most\n    closely approximating the eigenphase.\n\n    The main input to the constructor is the number of qubits in the phase-reading register.\n    For phase estimation, there are two methods:\n\n    first. `estimate`, which takes a state preparation circuit to prepare an input state, and\n      a unitary that will act on the the input state. In this case, an instance of\n      :class:`qiskit.circuit.PhaseEstimation`, a QPE circuit, containing\n      the state preparation and input unitary will be constructed.\n    second. `estimate_from_pe_circuit`, which takes a quantum-phase-estimation circuit in which\n      the unitary and state preparation are already embedded.\n\n    In both estimation methods, the QPE circuit is run on a backend\n    and the frequencies or counts of the phases represented by bitstrings\n    are recorded. The results are returned as an instance of\n    :class:`~qiskit.algorithms.phase_estimator_result.PhaseEstimationResult`.\n\n    **Reference:**\n\n    [1]: Michael A. Nielsen and Isaac L. Chuang. 2011.\n         Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n         Cambridge University Press, New York, NY, USA.\n\n    ')), FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_evaluation_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n                be estimated as a binary string with this many bits.\n            quantum_instance: The quantum instance on which the circuit will be run.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_measurements_added', ctx=Store())], value=NameConstant(value=False)), If(test=Compare(left=Name(id='num_evaluation_qubits', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())], value=Name(id='num_evaluation_qubits', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None)), FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Return the circuit to be executed to estimate phases.\n\n        This circuit includes as sub-circuits the core phase estimation circuit,\n        with the addition of the state-preparation circuit and possibly measurement instructions.\n        ')), Assign(targets=[Name(id='num_evaluation_qubits', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), Name(id='unitary', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))]))], orelse=[]), Return(value=Name(id='pe_circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load())), FunctionDef(name='_add_measurement_if_required', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())), body=[Assign(targets=[Name(id='regname', ctx=Store())], value=Str(s='meas')), Assign(targets=[Name(id='creg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=None), FunctionDef(name='_compute_phases', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='circuit_result', annotation=Name(id='Result', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute frequencies/counts of phases from the result of running the QPE circuit.\n\n        How the frequencies are computed depends on whether the backend computes amplitude or\n        samples outcomes.\n\n        1) If the backend is a statevector simulator, then the reduced density matrix of the\n        phase-reading register is computed from the combined phase-reading- and input-state\n        registers. The elements of the diagonal :math:`(i, i)` give the probability to measure the\n        each of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\n        gives the state of the phase-reading register with the LSB leftmost when interpreted as a\n        phase. In order to maintain the compact representation, the phases are maintained as decimal\n        integers.  They may be converted to other forms via the results object,\n        `PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n         2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\n        binary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\n        converted to frequencies. Then the keys are sorted according to increasing phase, so that\n        they can be easily understood when displaying or plotting a histogram.\n\n        Args:\n            num_unitary_qubits: The number of qubits in the unitary.\n            circuit_result: the result object returned by the backend that ran the QPE circuit.\n\n        Returns:\n            Either a dict or numpy.ndarray representing the frequencies of the phases.\n\n        ')), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='evaluation_density_matrix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='num_shots', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load())), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))]))]), Return(value=Name(id='phases', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load())), ctx=Load())), FunctionDef(name='estimate_from_pe_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the the phase estimation algorithm on a phase estimation circuit\n\n        Args:\n            pe_circuit: The phase estimation circuit.\n            num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load()), args=[Name(id='num_unitary_qubits', ctx=Load()), Name(id='circuit_result', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='PhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load())), keyword(arg='phases', value=Name(id='phases', ctx=Load()))]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load())), FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='pe_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='num_unitary_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Build a phase estimation circuit and run the corresponding algorithm.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n                will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                measured.  If this parameter is omitted, no preparation circuit\n                will be run and input state will be the all-zero state in the\n                computational basis.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), If(test=Compare(left=Name(id='unitary', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)])]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load()), Name(id='num_unitary_qubits', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load()))], decorator_list=[])
Str(s='The Quantum Phase Estimation Algorithm.')
alias(name='warnings', asname=None)
alias(name='Optional', asname=None)
alias(name='Union', asname=None)
alias(name='numpy', asname=None)
alias(name='QuantumCircuit', asname=None)
alias(name='qiskit', asname=None)
alias(name='circuit', asname=None)
alias(name='ClassicalRegister', asname=None)
alias(name='Backend', asname=None)
alias(name='QuantumInstance', asname=None)
alias(name='Result', asname=None)
alias(name='PhaseEstimationResult', asname=None)
alias(name='_sort_phases', asname=None)
alias(name='PhaseEstimator', asname=None)
Name(id='PhaseEstimator', ctx=Load())
Expr(value=Str(s='Run the Quantum Phase Estimation (QPE) algorithm.\n\n    This runs QPE with a multi-qubit register for reading the phases [1]\n    of input states.\n\n    The algorithm takes as input a unitary :math:`U` and a state :math:`|\\psi\\rangle`,\n    which may be written\n\n    .. math::\n\n        |\\psi\\rangle = \\sum_j c_j |\\phi_j\\rangle,\n\n    where :math:`|\\phi_j\\rangle` are eigenstates of :math:`U`. We prepare the quantum register\n    in the state :math:`|\\psi\\rangle` then apply :math:`U` leaving the register in the state\n\n    .. math::\n\n        U|\\psi\\rangle = \\sum_j \\exp(i \\phi_j) c_j |\\phi_j\\rangle.\n\n    In the ideal case, one then measures the phase :math:`\\phi_j` with probability\n    :math:`|c_j|^2`.  In practice, many (or all) of the bit strings may be measured due to\n    noise and the possibility that :math:`\\phi_j` may not be representable exactly by the\n    output register. In the latter case the probability for each eigenphase will be spread\n    across bitstrings, with amplitudes that decrease with distance from the bitstring most\n    closely approximating the eigenphase.\n\n    The main input to the constructor is the number of qubits in the phase-reading register.\n    For phase estimation, there are two methods:\n\n    first. `estimate`, which takes a state preparation circuit to prepare an input state, and\n      a unitary that will act on the the input state. In this case, an instance of\n      :class:`qiskit.circuit.PhaseEstimation`, a QPE circuit, containing\n      the state preparation and input unitary will be constructed.\n    second. `estimate_from_pe_circuit`, which takes a quantum-phase-estimation circuit in which\n      the unitary and state preparation are already embedded.\n\n    In both estimation methods, the QPE circuit is run on a backend\n    and the frequencies or counts of the phases represented by bitstrings\n    are recorded. The results are returned as an instance of\n    :class:`~qiskit.algorithms.phase_estimator_result.PhaseEstimationResult`.\n\n    **Reference:**\n\n    [1]: Michael A. Nielsen and Isaac L. Chuang. 2011.\n         Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n         Cambridge University Press, New York, NY, USA.\n\n    '))
FunctionDef(name='__init__', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_evaluation_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='\n        Args:\n            num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n                be estimated as a binary string with this many bits.\n            quantum_instance: The quantum instance on which the circuit will be run.\n        ')), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_measurements_added', ctx=Store())], value=NameConstant(value=False)), If(test=Compare(left=Name(id='num_evaluation_qubits', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())], value=Name(id='num_evaluation_qubits', ctx=Load()))], orelse=[]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))], decorator_list=[], returns=NameConstant(value=None))
FunctionDef(name='construct_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)]), body=[Expr(value=Str(s='Return the circuit to be executed to estimate phases.\n\n        This circuit includes as sub-circuits the core phase estimation circuit,\n        with the addition of the state-preparation circuit and possibly measurement instructions.\n        ')), Assign(targets=[Name(id='num_evaluation_qubits', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), Name(id='unitary', ctx=Load())], keywords=[])), If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))]))], orelse=[]), Return(value=Name(id='pe_circuit', ctx=Load()))], decorator_list=[], returns=Name(id='QuantumCircuit', ctx=Load()))
FunctionDef(name='_add_measurement_if_required', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())), body=[Assign(targets=[Name(id='regname', ctx=Store())], value=Str(s='meas')), Assign(targets=[Name(id='creg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[]))], orelse=[]), Return(value=Name(id='circuit', ctx=Load()))], decorator_list=[], returns=None)
FunctionDef(name='_compute_phases', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='circuit_result', annotation=Name(id='Result', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Compute frequencies/counts of phases from the result of running the QPE circuit.\n\n        How the frequencies are computed depends on whether the backend computes amplitude or\n        samples outcomes.\n\n        1) If the backend is a statevector simulator, then the reduced density matrix of the\n        phase-reading register is computed from the combined phase-reading- and input-state\n        registers. The elements of the diagonal :math:`(i, i)` give the probability to measure the\n        each of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\n        gives the state of the phase-reading register with the LSB leftmost when interpreted as a\n        phase. In order to maintain the compact representation, the phases are maintained as decimal\n        integers.  They may be converted to other forms via the results object,\n        `PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n         2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\n        binary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\n        converted to frequencies. Then the keys are sorted according to increasing phase, so that\n        they can be easily understood when displaying or plotting a histogram.\n\n        Args:\n            num_unitary_qubits: The number of qubits in the unitary.\n            circuit_result: the result object returned by the backend that ran the QPE circuit.\n\n        Returns:\n            Either a dict or numpy.ndarray representing the frequencies of the phases.\n\n        ')), If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='evaluation_density_matrix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='num_shots', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load())), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))]))]), Return(value=Name(id='phases', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load())), ctx=Load()))
FunctionDef(name='estimate_from_pe_circuit', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Expr(value=Str(s='Run the the phase estimation algorithm on a phase estimation circuit\n\n        Args:\n            pe_circuit: The phase estimation circuit.\n            num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='circuit_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load()), args=[Name(id='num_unitary_qubits', ctx=Load()), Name(id='circuit_result', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='PhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load())), keyword(arg='phases', value=Name(id='phases', ctx=Load()))]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load()))
FunctionDef(name='estimate', args=arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='pe_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='num_unitary_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)]), body=[Expr(value=Str(s='Build a phase estimation circuit and run the corresponding algorithm.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n                will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                measured.  If this parameter is omitted, no preparation circuit\n                will be run and input state will be the all-zero state in the\n                computational basis.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')), If(test=Compare(left=Name(id='unitary', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)])]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load()), Name(id='num_unitary_qubits', ctx=Load())], keywords=[]))], decorator_list=[], returns=Name(id='PhaseEstimationResult', ctx=Load()))
Load()
Str(s='Run the Quantum Phase Estimation (QPE) algorithm.\n\n    This runs QPE with a multi-qubit register for reading the phases [1]\n    of input states.\n\n    The algorithm takes as input a unitary :math:`U` and a state :math:`|\\psi\\rangle`,\n    which may be written\n\n    .. math::\n\n        |\\psi\\rangle = \\sum_j c_j |\\phi_j\\rangle,\n\n    where :math:`|\\phi_j\\rangle` are eigenstates of :math:`U`. We prepare the quantum register\n    in the state :math:`|\\psi\\rangle` then apply :math:`U` leaving the register in the state\n\n    .. math::\n\n        U|\\psi\\rangle = \\sum_j \\exp(i \\phi_j) c_j |\\phi_j\\rangle.\n\n    In the ideal case, one then measures the phase :math:`\\phi_j` with probability\n    :math:`|c_j|^2`.  In practice, many (or all) of the bit strings may be measured due to\n    noise and the possibility that :math:`\\phi_j` may not be representable exactly by the\n    output register. In the latter case the probability for each eigenphase will be spread\n    across bitstrings, with amplitudes that decrease with distance from the bitstring most\n    closely approximating the eigenphase.\n\n    The main input to the constructor is the number of qubits in the phase-reading register.\n    For phase estimation, there are two methods:\n\n    first. `estimate`, which takes a state preparation circuit to prepare an input state, and\n      a unitary that will act on the the input state. In this case, an instance of\n      :class:`qiskit.circuit.PhaseEstimation`, a QPE circuit, containing\n      the state preparation and input unitary will be constructed.\n    second. `estimate_from_pe_circuit`, which takes a quantum-phase-estimation circuit in which\n      the unitary and state preparation are already embedded.\n\n    In both estimation methods, the QPE circuit is run on a backend\n    and the frequencies or counts of the phases represented by bitstrings\n    are recorded. The results are returned as an instance of\n    :class:`~qiskit.algorithms.phase_estimator_result.PhaseEstimationResult`.\n\n    **Reference:**\n\n    [1]: Michael A. Nielsen and Isaac L. Chuang. 2011.\n         Quantum Computation and Quantum Information: 10th Anniversary Edition (10th ed.).\n         Cambridge University Press, New York, NY, USA.\n\n    ')
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_evaluation_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='\n        Args:\n            num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n                be estimated as a binary string with this many bits.\n            quantum_instance: The quantum instance on which the circuit will be run.\n        '))
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_measurements_added', ctx=Store())], value=NameConstant(value=False))
If(test=Compare(left=Name(id='num_evaluation_qubits', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())], value=Name(id='num_evaluation_qubits', ctx=Load()))], orelse=[])
If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))], orelse=[])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())], value=Name(id='quantum_instance', ctx=Load()))
NameConstant(value=None)
arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None)])
Expr(value=Str(s='Return the circuit to be executed to estimate phases.\n\n        This circuit includes as sub-circuits the core phase estimation circuit,\n        with the addition of the state-preparation circuit and possibly measurement instructions.\n        '))
Assign(targets=[Name(id='num_evaluation_qubits', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()))
Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))
Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), Name(id='unitary', ctx=Load())], keywords=[]))
If(test=Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))]))], orelse=[])
Return(value=Name(id='pe_circuit', ctx=Load()))
Name(id='QuantumCircuit', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
If(test=UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())), body=[Assign(targets=[Name(id='regname', ctx=Store())], value=Str(s='meas')), Assign(targets=[Name(id='creg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[]))], orelse=[])
Return(value=Name(id='circuit', ctx=Load()))
arguments(args=[arg(arg='self', annotation=None), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load())), arg(arg='circuit_result', annotation=Name(id='Result', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Compute frequencies/counts of phases from the result of running the QPE circuit.\n\n        How the frequencies are computed depends on whether the backend computes amplitude or\n        samples outcomes.\n\n        1) If the backend is a statevector simulator, then the reduced density matrix of the\n        phase-reading register is computed from the combined phase-reading- and input-state\n        registers. The elements of the diagonal :math:`(i, i)` give the probability to measure the\n        each of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\n        gives the state of the phase-reading register with the LSB leftmost when interpreted as a\n        phase. In order to maintain the compact representation, the phases are maintained as decimal\n        integers.  They may be converted to other forms via the results object,\n        `PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n         2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\n        binary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\n        converted to frequencies. Then the keys are sorted according to increasing phase, so that\n        they can be easily understood when displaying or plotting a histogram.\n\n        Args:\n            num_unitary_qubits: The number of qubits in the unitary.\n            circuit_result: the result object returned by the backend that ran the QPE circuit.\n\n        Returns:\n            Either a dict or numpy.ndarray representing the frequencies of the phases.\n\n        '))
If(test=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()), body=[Assign(targets=[Name(id='state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='evaluation_density_matrix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[]))], orelse=[Assign(targets=[Name(id='num_shots', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load())), Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[])), Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))]))])
Return(value=Name(id='phases', ctx=Load()))
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load())), ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='pe_circuit', annotation=Name(id='QuantumCircuit', ctx=Load())), arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[])
Expr(value=Str(s='Run the the phase estimation algorithm on a phase estimation circuit\n\n        Args:\n            pe_circuit: The phase estimation circuit.\n            num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        '))
Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='circuit_result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load()), args=[Name(id='num_unitary_qubits', ctx=Load()), Name(id='circuit_result', ctx=Load())], keywords=[]))
Return(value=Call(func=Name(id='PhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load())), keyword(arg='phases', value=Name(id='phases', ctx=Load()))]))
Name(id='PhaseEstimationResult', ctx=Load())
arguments(args=[arg(arg='self', annotation=None), arg(arg='unitary', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='pe_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())), arg(arg='num_unitary_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[NameConstant(value=None), NameConstant(value=None), NameConstant(value=None), NameConstant(value=None)])
Expr(value=Str(s='Build a phase estimation circuit and run the corresponding algorithm.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n                will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                measured.  If this parameter is omitted, no preparation circuit\n                will be run and input state will be the all-zero state in the\n                computational basis.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        '))
If(test=Compare(left=Name(id='unitary', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)], orelse=[]), Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])), Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)])])
Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load()), Name(id='num_unitary_qubits', ctx=Load())], keywords=[]))
Name(id='PhaseEstimationResult', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='num_evaluation_qubits', annotation=Name(id='int', ctx=Load()))
arg(arg='quantum_instance', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='\n        Args:\n            num_evaluation_qubits: The number of qubits used in estimating the phase. The phase will\n                be estimated as a binary string with this many bits.\n            quantum_instance: The quantum instance on which the circuit will be run.\n        ')
Attribute(value=Name(id='self', ctx=Load()), attr='_measurements_added', ctx=Store())
NameConstant(value=False)
Compare(left=Name(id='num_evaluation_qubits', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())], value=Name(id='num_evaluation_qubits', ctx=Load()))
Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load()), Name(id='Backend', ctx=Load())], keywords=[])
Assign(targets=[Name(id='quantum_instance', ctx=Store())], value=Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[]))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Store())
Name(id='quantum_instance', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='unitary', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
NameConstant(value=None)
Str(s='Return the circuit to be executed to estimate phases.\n\n        This circuit includes as sub-circuits the core phase estimation circuit,\n        with the addition of the state-preparation circuit and possibly measurement instructions.\n        ')
Name(id='num_evaluation_qubits', ctx=Store())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
Name(id='num_unitary_qubits', ctx=Store())
Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())
Name(id='pe_circuit', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), Name(id='unitary', ctx=Load())], keywords=[])
Compare(left=Name(id='state_preparation', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))]))
Name(id='pe_circuit', ctx=Load())
Load()
arg(arg='self', annotation=None)
arg(arg='pe_circuit', annotation=None)
UnaryOp(op=Not(), operand=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load()))
Assign(targets=[Name(id='regname', ctx=Store())], value=Str(s='meas'))
Assign(targets=[Name(id='creg', ctx=Store())], value=Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[]))
Expr(value=Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[]))
Name(id='circuit', ctx=Load())
arg(arg='self', annotation=None)
arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))
arg(arg='circuit_result', annotation=Name(id='Result', ctx=Load()))
Str(s='Compute frequencies/counts of phases from the result of running the QPE circuit.\n\n        How the frequencies are computed depends on whether the backend computes amplitude or\n        samples outcomes.\n\n        1) If the backend is a statevector simulator, then the reduced density matrix of the\n        phase-reading register is computed from the combined phase-reading- and input-state\n        registers. The elements of the diagonal :math:`(i, i)` give the probability to measure the\n        each of the states `i`. The index `i` expressed as a binary integer with the LSB rightmost\n        gives the state of the phase-reading register with the LSB leftmost when interpreted as a\n        phase. In order to maintain the compact representation, the phases are maintained as decimal\n        integers.  They may be converted to other forms via the results object,\n        `PhaseEstimationResult` or `HamiltonianPhaseEstimationResult`.\n\n         2) If the backend samples bitstrings, then the counts are first retrieved as a dict.  The\n        binary strings (the keys) are then reversed so that the LSB is rightmost and the counts are\n        converted to frequencies. Then the keys are sorted according to increasing phase, so that\n        they can be easily understood when displaying or plotting a histogram.\n\n        Args:\n            num_unitary_qubits: The number of qubits in the unitary.\n            circuit_result: the result object returned by the backend that ran the QPE circuit.\n\n        Returns:\n            Either a dict or numpy.ndarray representing the frequencies of the phases.\n\n        ')
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Assign(targets=[Name(id='state_vec', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='evaluation_density_matrix', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[]))
Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='num_shots', ctx=Store())], value=Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load()))
Assign(targets=[Name(id='counts', ctx=Store())], value=Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[]))
Assign(targets=[Name(id='phases', ctx=Store())], value=DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))
Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='phases', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))]))
Name(id='phases', ctx=Load())
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load()))
Load()
arg(arg='self', annotation=None)
arg(arg='pe_circuit', annotation=Name(id='QuantumCircuit', ctx=Load()))
arg(arg='num_unitary_qubits', annotation=Name(id='int', ctx=Load()))
Str(s='Run the the phase estimation algorithm on a phase estimation circuit\n\n        Args:\n            pe_circuit: The phase estimation circuit.\n            num_unitary_qubits: Must agree with the number of qubits in the unitary in `pe_circuit`.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])
Name(id='circuit_result', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load())], keywords=[])
Name(id='phases', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load()), args=[Name(id='num_unitary_qubits', ctx=Load()), Name(id='circuit_result', ctx=Load())], keywords=[])
Call(func=Name(id='PhaseEstimationResult', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load())), keyword(arg='phases', value=Name(id='phases', ctx=Load()))])
Load()
arg(arg='self', annotation=None)
arg(arg='unitary', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='state_preparation', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='pe_circuit', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load()))
arg(arg='num_unitary_qubits', annotation=Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load()))
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
NameConstant(value=None)
Str(s='Build a phase estimation circuit and run the corresponding algorithm.\n\n        Args:\n            unitary: The circuit representing the unitary operator whose eigenvalues (via phase)\n                will be measured.\n            state_preparation: The circuit that prepares the state whose eigenphase will be\n                measured.  If this parameter is omitted, no preparation circuit\n                will be run and input state will be the all-zero state in the\n                computational basis.\n\n        Returns:\n            An instance of qiskit.algorithms.phase_estimator_result.PhaseEstimationResult.\n        ')
Compare(left=Name(id='unitary', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)], orelse=[])
Assign(targets=[Name(id='pe_circuit', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[]))
Assign(targets=[Name(id='num_unitary_qubits', ctx=Store())], value=Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load()))
If(test=Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))], orelse=[Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)])
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load()), args=[Name(id='pe_circuit', ctx=Load()), Name(id='num_unitary_qubits', ctx=Load())], keywords=[])
Load()
Name(id='int', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())), ctx=Load())
Name(id='self', ctx=Load())
Store()
Name(id='num_evaluation_qubits', ctx=Load())
IsNot()
NameConstant(value=None)
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Store())
Name(id='num_evaluation_qubits', ctx=Load())
Name(id='isinstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Name(id='Backend', ctx=Load())
Name(id='quantum_instance', ctx=Store())
Call(func=Name(id='QuantumInstance', ctx=Load()), args=[Name(id='quantum_instance', ctx=Load())], keywords=[])
Name(id='self', ctx=Load())
Store()
Load()
Name(id='QuantumCircuit', ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Store()
Name(id='self', ctx=Load())
Load()
Store()
Name(id='unitary', ctx=Load())
Load()
Store()
Attribute(value=Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load()), attr='PhaseEstimation', ctx=Load())
Name(id='num_evaluation_qubits', ctx=Load())
Name(id='unitary', ctx=Load())
Name(id='state_preparation', ctx=Load())
IsNot()
NameConstant(value=None)
Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load()), args=[Name(id='state_preparation', ctx=Load())], keywords=[keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])), keyword(arg='inplace', value=NameConstant(value=True)), keyword(arg='front', value=NameConstant(value=True))])
Load()
Not()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='is_statevector', ctx=Load())
Name(id='regname', ctx=Store())
Str(s='meas')
Name(id='creg', ctx=Store())
Call(func=Name(id='ClassicalRegister', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), Name(id='regname', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load()), args=[Name(id='creg', ctx=Load())], keywords=[])
Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load()), args=[], keywords=[])
Call(func=Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load()), args=[Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[]), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])], keywords=[])
Load()
Name(id='int', ctx=Load())
Name(id='Result', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Name(id='state_vec', ctx=Store())
Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load()), args=[], keywords=[])
Name(id='evaluation_density_matrix', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load()), args=[Name(id='state_vec', ctx=Load()), Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])], keywords=[])
Name(id='phases', ctx=Store())
Call(func=Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load()), args=[], keywords=[])
Name(id='num_shots', ctx=Store())
Attribute(value=Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load()), attr='shots', ctx=Load())
Name(id='counts', ctx=Store())
Call(func=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load()), args=[], keywords=[])
Name(id='phases', ctx=Store())
DictComp(key=Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load()), value=BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load())), generators=[comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])
Name(id='phases', ctx=Store())
Call(func=Name(id='_sort_phases', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[])
Name(id='phases', ctx=Store())
Call(func=Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load()), args=[Name(id='phases', ctx=Load())], keywords=[keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())), keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))])
Load()
Load()
Tuple(elts=[Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load()), Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())], ctx=Load())
Name(id='QuantumCircuit', ctx=Load())
Name(id='int', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_add_measurement_if_required', ctx=Load())
Name(id='pe_circuit', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load()), attr='execute', ctx=Load())
Name(id='pe_circuit', ctx=Load())
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='_compute_phases', ctx=Load())
Name(id='num_unitary_qubits', ctx=Load())
Name(id='circuit_result', ctx=Load())
Name(id='PhaseEstimationResult', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
keyword(arg='circuit_result', value=Name(id='circuit_result', ctx=Load()))
keyword(arg='phases', value=Name(id='phases', ctx=Load()))
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='QuantumCircuit', ctx=Load())), ctx=Load())
Subscript(value=Name(id='Optional', ctx=Load()), slice=Index(value=Name(id='int', ctx=Load())), ctx=Load())
Name(id='unitary', ctx=Load())
IsNot()
NameConstant(value=None)
Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[]), cause=None)
Name(id='pe_circuit', ctx=Store())
Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load()), args=[Name(id='unitary', ctx=Load()), Name(id='state_preparation', ctx=Load())], keywords=[])
Name(id='num_unitary_qubits', ctx=Store())
Attribute(value=Name(id='unitary', ctx=Load()), attr='num_qubits', ctx=Load())
Compare(left=Name(id='pe_circuit', ctx=Load()), ops=[IsNot()], comparators=[NameConstant(value=None)])
Expr(value=Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))]))
Raise(exc=Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[]), cause=None)
Attribute(value=Name(id='self', ctx=Load()), attr='estimate_from_pe_circuit', ctx=Load())
Name(id='pe_circuit', ctx=Load())
Name(id='num_unitary_qubits', ctx=Load())
Load()
Name(id='Optional', ctx=Load())
Index(value=Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load()))
Load()
Load()
Load()
Name(id='self', ctx=Load())
Store()
Load()
Load()
Load()
Load()
Store()
Name(id='QuantumInstance', ctx=Load())
Name(id='quantum_instance', ctx=Load())
Load()
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Load()
Load()
Attribute(value=Name(id='circuit', ctx=Load()), attr='library', ctx=Load())
Load()
Load()
Load()
Load()
Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='compose', ctx=Load())
Name(id='state_preparation', ctx=Load())
keyword(arg='qubits', value=Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[]))
keyword(arg='inplace', value=NameConstant(value=True))
keyword(arg='front', value=NameConstant(value=True))
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Store()
Store()
Name(id='ClassicalRegister', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
Name(id='regname', ctx=Load())
Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='add_register', ctx=Load())
Name(id='creg', ctx=Load())
Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='barrier', ctx=Load())
Attribute(value=Name(id='pe_circuit', ctx=Load()), attr='measure', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())], keywords=[])
Load()
Load()
Name(id='self', ctx=Load())
Load()
Store()
Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_statevector', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load()), attr='partial_trace', ctx=Load())
Name(id='state_vec', ctx=Load())
Call(func=Name(id='range', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])
Store()
Attribute(value=Name(id='evaluation_density_matrix', ctx=Load()), attr='probabilities', ctx=Load())
Store()
Subscript(value=Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load()), slice=Index(value=Num(n=0)), ctx=Load())
Load()
Store()
Attribute(value=Name(id='circuit_result', ctx=Load()), attr='get_counts', ctx=Load())
Store()
Subscript(value=Name(id='k', ctx=Load()), slice=Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1))), ctx=Load())
BinOp(left=Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load()), op=Div(), right=Name(id='num_shots', ctx=Load()))
comprehension(target=Name(id='k', ctx=Store()), iter=Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)
Store()
Name(id='_sort_phases', ctx=Load())
Name(id='phases', ctx=Load())
Store()
Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())
Name(id='phases', ctx=Load())
keyword(arg='memory_slots', value=Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load()))
keyword(arg='creg_sizes', value=Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load()))
Attribute(value=Name(id='numpy', ctx=Load()), attr='ndarray', ctx=Load())
Attribute(value=Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load()), attr='Counts', ctx=Load())
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_quantum_instance', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Name(id='circuit_result', ctx=Load())
Name(id='phases', ctx=Load())
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='QuantumCircuit', ctx=Load()))
Load()
Name(id='Optional', ctx=Load())
Index(value=Name(id='int', ctx=Load()))
Load()
Load()
Name(id='pe_circuit', ctx=Load())
IsNot()
NameConstant(value=None)
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='Only one of `pe_circuit` and `unitary` may be passed.')], keywords=[])
Store()
Attribute(value=Name(id='self', ctx=Load()), attr='construct_circuit', ctx=Load())
Name(id='unitary', ctx=Load())
Name(id='state_preparation', ctx=Load())
Store()
Name(id='unitary', ctx=Load())
Load()
Name(id='pe_circuit', ctx=Load())
IsNot()
NameConstant(value=None)
Call(func=Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load()), args=[Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.'), Name(id='DeprecationWarning', ctx=Load())], keywords=[keyword(arg='stacklevel', value=Num(n=2))])
Call(func=Name(id='ValueError', ctx=Load()), args=[Str(s='One of `pe_circuit` and `unitary` must be passed.')], keywords=[])
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Subscript(value=Name(id='Union', ctx=Load()), slice=Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())), ctx=Load())
Load()
Load()
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Name(id='circuit', ctx=Load())
Load()
Name(id='pe_circuit', ctx=Load())
Load()
Load()
Call(func=Name(id='range', ctx=Load()), args=[Name(id='num_evaluation_qubits', ctx=Load()), BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))], keywords=[])
NameConstant(value=True)
NameConstant(value=True)
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='pe_circuit', ctx=Load())
Load()
Load()
Name(id='pe_circuit', ctx=Load())
Load()
Name(id='pe_circuit', ctx=Load())
Load()
Name(id='range', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
Name(id='range', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
Load()
Name(id='circuit_result', ctx=Load())
Load()
Attribute(value=Name(id='qiskit', ctx=Load()), attr='quantum_info', ctx=Load())
Load()
Load()
Name(id='range', ctx=Load())
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
BinOp(left=Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))
Name(id='evaluation_density_matrix', ctx=Load())
Load()
Attribute(value=Name(id='circuit_result', ctx=Load()), attr='results', ctx=Load())
Index(value=Num(n=0))
Load()
Name(id='circuit_result', ctx=Load())
Load()
Name(id='k', ctx=Load())
Slice(lower=None, upper=None, step=UnaryOp(op=USub(), operand=Num(n=1)))
Load()
Subscript(value=Name(id='counts', ctx=Load()), slice=Index(value=Name(id='k', ctx=Load())), ctx=Load())
Div()
Name(id='num_shots', ctx=Load())
Name(id='k', ctx=Store())
Call(func=Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])
Load()
Load()
Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load())
Load()
Load()
Attribute(value=Name(id='counts', ctx=Load()), attr='memory_slots', ctx=Load())
Attribute(value=Name(id='counts', ctx=Load()), attr='creg_sizes', ctx=Load())
Name(id='numpy', ctx=Load())
Load()
Attribute(value=Name(id='qiskit', ctx=Load()), attr='result', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='QuantumCircuit', ctx=Load())
Load()
Name(id='int', ctx=Load())
Load()
Name(id='ValueError', ctx=Load())
Str(s='Only one of `pe_circuit` and `unitary` may be passed.')
Name(id='self', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Attribute(value=Name(id='warnings', ctx=Load()), attr='warn', ctx=Load())
Str(s='Passing `pe_circuit` to the PhaseEstimation.estimate() method is deprecated as of 0.18, and will be removed no earlier than 3 months after that release date. You should use the PhaseEstimation.estimate_from_pe_circuit() method instead.')
Name(id='DeprecationWarning', ctx=Load())
keyword(arg='stacklevel', value=Num(n=2))
Name(id='ValueError', ctx=Load())
Str(s='One of `pe_circuit` and `unitary` must be passed.')
Load()
Name(id='Union', ctx=Load())
Index(value=Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load()))
Load()
Load()
Load()
Load()
Name(id='range', ctx=Load())
Name(id='num_evaluation_qubits', ctx=Load())
BinOp(left=Name(id='num_evaluation_qubits', ctx=Load()), op=Add(), right=Name(id='num_unitary_qubits', ctx=Load()))
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Name(id='qiskit', ctx=Load())
Load()
Load()
Name(id='self', ctx=Load())
Load()
Attribute(value=Name(id='self', ctx=Load()), attr='_num_evaluation_qubits', ctx=Load())
Add()
Name(id='num_unitary_qubits', ctx=Load())
Load()
Name(id='circuit_result', ctx=Load())
Load()
Num(n=0)
Load()
Load()
UnaryOp(op=USub(), operand=Num(n=1))
Name(id='counts', ctx=Load())
Index(value=Name(id='k', ctx=Load()))
Load()
Load()
Store()
Attribute(value=Name(id='counts', ctx=Load()), attr='keys', ctx=Load())
Name(id='qiskit', ctx=Load())
Load()
Name(id='counts', ctx=Load())
Load()
Name(id='counts', ctx=Load())
Load()
Load()
Name(id='qiskit', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='warnings', ctx=Load())
Load()
Load()
Num(n=2)
Load()
Load()
Tuple(elts=[Name(id='QuantumInstance', ctx=Load()), Name(id='Backend', ctx=Load())], ctx=Load())
Load()
Load()
Name(id='num_evaluation_qubits', ctx=Load())
Add()
Name(id='num_unitary_qubits', ctx=Load())
Load()
Load()
Load()
Load()
Name(id='self', ctx=Load())
Load()
Load()
Load()
USub()
Num(n=1)
Load()
Name(id='k', ctx=Load())
Name(id='counts', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Name(id='QuantumInstance', ctx=Load())
Name(id='Backend', ctx=Load())
Load()
Load()
Load()
Load()
Load()
Load()
Load()
Load()
  metric  value
0     NC      1
DONE!
